[
{
	"uri": "http://localhost:4444/asset-management/asset-types/overriding_assets/",
	"title": "Adding &amp; Overriding Assets",
	"tags": [],
	"description": "",
	"content": "In RGL you can easily override existing assets or create new ones within the editor for your custom mode. Override mechanism works by replacing existing assets with the one you supplied in your module\u0026rsquo;s assets directory. It tries to match your custom assets with the ones previously registered by other modules by their names. This happens with respect to loading order of the modules.\nIf Module A and Module B are loaded in addition to the Native module respectively, list of final assets and their sources will be as follow :\nCurrently moddable asset types are:\n Material Mesh Texture Physics Shape  Folder Hierarchy Asset system treats some folders in module directory specially according to their names. Here is the list of these folders and their uesages :\n Assets : Includes editable *.tpac files which stores meta data of each asset. AssetSources : Includes source files of imported assets(.psd, .fbx). AssetPackages : Includes read-only *.tpac files. It is generated when a module is packed for client builds. EmAssetPackages : Includes read-only *.tpac files. It is generated when a module is packed for editor builds. DsAssetPackages : Includes read-only *.tpac files. It is generated when a module is packed for server builds. RuntimeDataCache : Includes auto-generated data required by engine for each asset. Can be deleted but it might take time to generate from scratch during startup.  Modding Permissions Asset system looks for different folders according to the version of game\u0026rsquo;s running executable. According to presence of these folders it decides whether a module can be modified or it can be used only in read-only mode. If you want to distribute your module you can pack your assets and share packed folders without distributing thousands of files and their sources. You have three options to pack your assets :\n Client : Others can activate your module to play. You must distribute AssetPackages folder. Editor : Others can use your module in editor but can not modify it. Used if you want others to derive modules from your module. You must distribute EmAssetPackages folder. Server : Used for server builds. All data which is not related to server is stripped out. You must distribute DsAssetPackages folder.  You can also share your module just like you are using it to allow others to modify it. In this case you must distribute Assets, AssetSources and optionally RuntimeDataCache folders.\nOverriding Materials Overriding materials can be done by creating a new material with the same name of the material you want to override. Navigate to assets directory of your module and right click on an empty place in the browser pane. Create a new material and rename it to the same name with the material you want to override.\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/material_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;Material of an existing mesh overriden by ModuleA\u0026lt;/div\u0026gt;  At this point all material references in the system will be redirected to your custom material. Overriding Meshes Models can be imported from several file formats(e.g. Trf, Fbx). Resources imported from a single file are grouped by their names according to \u0026lt;\u0026gt;asset naming convetions\u0026lt;\u0026gt;. Imagine an fbx file as follow :\n Model.fbx  wall(Mesh) wall.lod1(Mesh) wall.lod3(Mesh) bo_wall(Physics Shape)    According to asset naming conventions, first three resources will be grouped into a single mesh which has three submeshes belong to different LODs. At the end two asset will be imported from Model.fbx : wall(Mesh) and bo_wall(Physics shape).\nBy following these rules you can export a new geometry file(e.g. fbx) which contains a group of meshes with their names begin with wall. In this case a new wall mesh will be created from these submeshes and existing mesh will be replaced completely with the one you supplied. Name of the geometry file is not taken into account. It is worth to mention that mesh overrides occur on mesh level. It is not possible to override single submesh via module override.\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/metamesh_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;Existing cube mesh with name \u0026lt;strong\u0026gt;testbox\u0026lt;/strong\u0026gt; overriden by ModuleA with a teapot\u0026lt;/div\u0026gt;  Overriding Textures Overriding textures is very similar to materials. You need to import a new texture with the same name of the texture you want to override. You can also rename any texture already imported to something that matches with the name of the texture to override.\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/texture_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;Existing albedo texture with name \u0026lt;strong\u0026gt;roman_ground_d\u0026lt;/strong\u0026gt; overriden by ModuleA with a white texture\u0026lt;/div\u0026gt;  Overriding Physics Shapes Overriding physics shapes requires you to import a physics shape with the same name of asset you want to replace. Check \u0026lt;\u0026gt;Asset naming conventions\u0026lt;\u0026gt; to see hot to import physics shapes\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/physics_shape_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;Existing torus shape overriden by ModuleA with a custom aquila shape\u0026lt;/div\u0026gt;  "
},
{
	"uri": "http://localhost:4444/playing-sounds/adding-custom-sounds/",
	"title": "Adding Sounds to Your Module",
	"tags": [],
	"description": "",
	"content": "Bannerlord audio system is built on proprietary FMOD Sound system. To keep audio engine performant while making it accessible to anyone, we needed to create an interlayer.\nKey Elements  ...\\Modules\\*YOUR_MOD*\\ModuleData\\module_sounds.xml file, where you add custom definitions for your own sounds ...\\Modules\\*YOUR_MOD*\\ModuleSounds folder where you put audio files (.ogg, .wav)  You can see examples in \u0026lsquo;Native\u0026rsquo; module.\nBasic Guide  Copy example files and folder to your own module Add new sounds into the ModuleSounds folder Open the module_sounds.xml of your module You will see sound categories, code example for playing sounds and example module_sound entries in the original module_sounds.xml file Add new entry to your mod\u0026rsquo;s module_sounds.xml Play the new sound entry from the code  Moving Further Using module_sounds.xml \u0026lt;module_sound name=\u0026#34;example/combat/hit\u0026#34; is_2d=\u0026#34;true\u0026#34; sound_category=\u0026#34;mission_combat\u0026#34; path=\u0026#34;example_sound_modders.ogg\u0026#34; /\u0026gt;  \u0026lsquo;name\u0026rsquo;: Any unique name you want. This is the identifier for your sound.  Use while playing sound from the code. Use to play animation sound. Add to animation\u0026rsquo;s \u0026lsquo;sound_code\u0026rsquo; attribute.   \u0026lsquo;is_2d\u0026rsquo;: If the sound\u0026rsquo;s spatial properties won\u0026rsquo;t be used. 3d sounds have properties as position, velocity etc. \u0026lsquo;sound_category\u0026rsquo;: All sounds must be assigned to a category to route it correctly through our pipes. Available categories are,  mission_ambient_bed (2D ambient loops like base wind) mission_ambient_3d_big (Sounds that should be heard from long distance, like a burning castle) mission_ambient_3d_medium (Sounds that should be heard from medium distance, like bonfires) mission_ambient_3d_small (Sounds that should be heard from nearby, like campfires) mission_material_impact (Physics material impacts like metal sword hitting stone wall) mission_combat_trivial (Unimportant damage sounds, like low/no damage) mission_combat (Damage sounds) mission_foley (Swings, movement sounds, animal movements) mission_voice_shout (Human/Animal voices that should be heard from long distance like battle yells) mission_voice (Human/Animal grunts, knockouts etc.) mission_voice_trivial (Quiet vocalizations like climbing, jumping) mission_siege_loud (Big siege sounds like boulder hits wall, Catapult fires, Door breaks) mission_footstep (Standard footsteps for humans and smaller animals) mission_footstep_run (Louder footsteps that could be head from distance when in crowds) mission_horse_gallop (Horse, camel gallops) mission_horse_walk (Horse, camel single soft footstep) ui (2D sounds for UI and notifications) alert (Psuedo-3d sounds for alerting the player from mid distance) campaign_node (Positional sound nodes for World Map, farms, seas, waterfalls) campaign_bed (2D ambient sounds for World Map, desert gusts, pasture winds etc.)   \u0026lsquo;path\u0026rsquo;: The sound file to be played. Path is relative to your module\u0026rsquo;s ModuleSounds folder. You can create child folders.  Playing Sound from Code Example int soundIndex = SoundEvent.GetEventIdFromString(\u0026#34;example/voice/charge\u0026#34;); //to avoid string operations in runtime soundIndex can be cached.  if (playOneshot) { MakeSound(soundIndex, MainAgent.Position, false, true, -1, -1); //plays one shot sound at position with given parameters.  } else { SoundEvent eventRef = SoundEvent.CreateEvent(soundIndex, Scene); //get a reference to sound and update parameters later.  eventRef.SetPosition(MainAgent.Position); eventRef.Play(); } You have two ways to play sound:\n One Shot Better performance less control. Fire and forget. Good for combat-related sounds. Creating and holding a reference Worse performance. Control every parameter of sound whenever you want. i.e. Pause, Update position.  "
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/animations/",
	"title": "Animations",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/asset-management/asset-browser/",
	"title": "Asset Browser",
	"tags": [],
	"description": "",
	"content": "Asset browser shows assets 5256+2+56\n"
},
{
	"uri": "http://localhost:4444/asset-management/",
	"title": "Asset Management",
	"tags": [],
	"description": "",
	"content": "Asset BrowserAsset TypesCreating a Module - Quick GuideFrequently Asked Questions"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/",
	"title": "Asset Types",
	"tags": [],
	"description": "",
	"content": "Adding \u0026amp; Overriding AssetsAnimationsBodiesEntities \u0026amp; PrefabsMaterialsMeshesNaming ConventionsOverriding Scenes and PrefabsPathsScriptsSkeletonsTextures"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/",
	"title": "Bannerlord Missions",
	"tags": [],
	"description": "",
	"content": "Mission Tactical PositionsWhat Makes a Village SceneDestructible ComponentScene Barrier BuilderScene Spawn Point GuideScript Component CallbacksSpawn Point Debug Tool"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/bodies/",
	"title": "Bodies",
	"tags": [],
	"description": "",
	"content": "Bodies define the physics boundaries of objects. They can be assigned to entities in scenes or prefabs. Users can edit the Body Flags to change their behaviour.\nBody Flags  Two Sided: Forces the physics engine to use both sides of the polygons for this body. AI Limiter: Used to tag bodies which will only used against AI agents, excluding the player. Destructible Door: Used by the automatic navigation mesh generator to not put nav mesh under destructable doors. Disabled: Disables the physics for this prefab or entity instance. Barrier: Enables smooth exit for agents exiting the interior of the body. Exclude Path Snap: Path points does not snap to these bodies. Don\u0026rsquo;t Collide With Camera: Camera for the player does not collide with these bodies. Dynamic: Physics engine simulates the movement of this entity. Moveable: This flag indicates that this body and its owner entity can move. Ladder: Should be given to the ladder meshes so that they function properly. Has Steps: Should be given to the bodies of the staircases so that the agent can climb them correctly. (The body of the stairs should be seperated from the other parts of the entity).  Agent physics require smooth and low poly physics objects for performance. Missile ones require more precision so that the stuck missiles are simulated better. The below flags can be used to have two different bodies per object which is the best of both worlds. If none of the flags are given, both missiles and agents react to the bodies.\n Agent Only: Only the agents react into these bodies. Missile Only: Only the missiles react into these bodies.  Occluders Occluders are bodies which are placed at mesh surfaces to tell the rendering system to not render the contents on the other side of that surface. They do not contribute to the physics simulation. Big towns and villages benefit largely from carefully placed occluders. User can place occluders directly to the scene or attach them to entities \u0026amp; prefabs.\n"
},
{
	"uri": "http://localhost:4444/asset-management/quickguide_create_a_mod/",
	"title": "Creating a Module - Quick Guide",
	"tags": [],
	"description": "",
	"content": "Modules can contain assets ranging from meshes to physics bodies, scenes, gameplay entities like factions, lords, troops, items, sounds, scripts and behaviours that can run any gameplay logic. In this guide, the process of creating one will be explained.\nCreating A New Module Modules reside inside the \u0026ldquo;Modules\u0026rdquo; folder in the root directory. It must contain an XML file named SubModule.xml. This file contains basic information like \u0026ldquo;Name\u0026rdquo;, \u0026ldquo;ID\u0026rdquo; and \u0026ldquo;Version\u0026rdquo; nodes. Also, one can define dependent modules inside the \u0026ldquo;DepenendedModules\u0026rdquo; node. If you want to make a Single Player mod, it should also contain a \u0026ldquo;SingleplayerModule\u0026rdquo; node. After this, the module will be visible at the Launcher.\nSubModules can define DLL\u0026rsquo;s to be loaded at runtime. These DLL\u0026rsquo;s should contain a Class which inherits from \u0026ldquo;MBSubModuleBase\u0026rdquo; and the name should match with the \u0026ldquo;SubModuleClassType\u0026rdquo; node inside the xml. That class will be constructed and certain callbacks willl be called so that od can registers its behaviours to the game.\nModule Hierarchy Modules can have several folders which contains different types of content:\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/creating_entity/",
	"title": "Creating Entity",
	"tags": [],
	"description": "",
	"content": "Game Entities are basic building blocks of Scenes. Every mesh, light, decal, script behaviour are components of entities. \\\nCreating an empty entity In the editor, you can begin by creating a new, empty entity by using the Add Empty Entitybutton from tool bar, then you can attach different components for different needs.\nAll entities can be composed of multiple components.\nAdding Component Component can be added from the toolbar after selecting an entity. There are 5 different components you can add. Mesh, Decal, Light, Particle, and Script.\nA - Mesh:##### Meshes are pretty straighforward and represent every visible geometry within the scene. After clicking add mesh button, select any mesh you want from mesh selection dialog. B - Decal:#####  C - Light:##### Lights can be used to illuminate the scene. Usually attached to other entities that supposed to emit light. (Like, torches, camp fires etc.)\nEvery light is fully customizable, you can enable/disable dynamic/static shadow, change light radius / shadow casting radius, intensity, and color from properties panel of light.\nYou can also specify custom effects like flickering for more natural lights. After clicking add light button, you can change properties of the light under Components panel in Entity Inspector.\nEngine uses a technique called Tiled Deferred Rendering, so using lots of lights are pretty cheap as long as they are not overlapping too much.\nThese parameters can be tweaked to further optimize scenes.\nIn the scene visualizer, Yellow sphere represent light radius, and blue sphere represents shadow casting radius. (D) Particle System:##### Particles simulates and renders many small images or Meshes, to produce a visual effect.\nParticles are useful when you want to create dynamic objects or volumetric effects like fire, smoke, or splash effects since they are quite hard, or even in most cases, not possible to create with regular meshes.\nAfter clicking add particle button, and selecting an exsiting particle from the Particle selection dialog, you can edit this particular instance from Component panel by clicking Edit Instance, (E) Script:##### Scripts are the basic building blocks of game related behaviours that can be attached to entities.\nScripts can be written in C# and has full access to attached entity, its Scene, and therefore all other entities in that Scene.\nAfter clicking add script button, you can select the script you want from the dropdown menu, then you can change the script parameters from Scrips panel under Entity Inspector.\nEntity Hierarchies Entities can have a parent child hierarcy to organize related entities together.\nChild entities automatically get their world position relative to their parents, moving a parent entity will move all of their children. More imformation about manipulating an entity can be found HereYou can use the Entity Outliner to create hierarcies by simply dragging an entity over another entity.\nYou can also detach a child entity from its parent by right clicking and selecting Detach from parent.\n                "
},
{
	"uri": "http://localhost:4444/editor/",
	"title": "Editor",
	"tags": [],
	"description": "editor",
	"content": "Resource EditorsScene Editor"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/editor_shortcuts/",
	"title": "Editor Shortcuts",
	"tags": [],
	"description": "",
	"content": "   General Editor Usage Shortcut Editor State     Show/hide helpers H Any mode   New scene Alt + 1 Any mode   Save scene Alt + 2 Any mode   Open scene Alt + 3 Any mode   Start mission Alt + 4 Any mode   Start mission as Alt + 5 Any mode   Scene Options Alt + 6 Any mode   Terrain Options Alt + 7 Terrain select   Terrain Elevation Alt + 8 Terrain Paint Elevate   Terrain Paint Alt + 9 Terrain Paint Paint   Shift between relevant 2 editor modes (select-add, select-elevatepaint etc) Space Any mode   Undo/Redo Ctrl+Z, Ctrl+Y Any mode       Camera Controls Shortcut Editor State     Focus on selected entity F Entity Select   Editor camera orbiting mode Alt (Hold) + Right Mouse Button Entity Select   Pan Alt (Hold) + Middle Mouse Button Entity Select   Zoom in/out Alt (Hold) + Mouse scroll wheel Entity Select   Camera speed increase/decrease Ctrl + Mouse scroll wheel Any mode   Camera speed set to 1 Ctrl + Middle mouse button Any mode       Prefab transform Shortcut Editor State     Rotate while placing Z, X, C, T, reset to default with R Entity Add   Move entity with placing on terrain Hold P Entity Select   Move entity vertically Hold N Entity Select   Move entity on the XY plane Hold G Entity Select   Show translate triad T Entity Select   Show rotating triad R Entity Select   Show scaling triad Y Entity Select   Duplicate the entity dragging on the translate triad Shift+Click or Shift+Drag to side Entity Select   Hide any triad on selected entity V Entity Select   Triads shown based on local coordinates (default) Alt+L Entity Select   Triads shown based on world coordinates Alt+W Entity Select   Material of an object under mouse opens in material editor (or material comes to inspector) M+Click Entity Select       Terrain Shortcut Editor State     Select all terrain nodes Ctrl + A Terrain Select   Lower when rise selected Alt + Click Terrain Paint Elevate   Rise when lower selected Alt + Click Terrain Paint Elevate   Flatten when Rise or Lower selected Ctrl + Left Mouse Click Terrain Paint Elevate   Smoothen when Rise or Lower selected Shift + Click Terrain Paint Elevate   Transfer height value to Flatten (when flatten selected) Alt + Click Terrain Paint Elevate   Flora paint (Not from layers) Left Mouse Click Entity Paint   Resize currently selected flora B (hold) + Mouse drag left/right Entity Paint   Place 1 flora (flora seen on brush) Ctrl + Left Mouse Click Entity Paint       Navmesh hotkeys Shortcut Editor State     Fill in closest 4 vertices (creates a quad) Shift + Click Navigation Mesh Add   Fill in the last 4 vertices (creates a quad) Ctrl + Space Navigation Mesh Add   Move vertex without selecting Ctrl + Drag Navigation Mesh Add   Delete face with mouse over (leaves vertices) Alt + Click Navigation Mesh Add   Delete face and remove all vertices Alt + X + Click Navigation Mesh Add   Selection mode - vertex 1 Navigation Mesh Select   Selection mode - edge 2 Navigation Mesh Select   Selection mode - face 3 Navigation Mesh Select   Select all vertices, edges or face (depends on the current selection) Ctrl + A Navigation Mesh Select   Delete selected vertices, edges or face Delete Navigation Mesh Select    "
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/prefabs/",
	"title": "Entities &amp; Prefabs",
	"tags": [],
	"description": "",
	"content": "In RGL, entities are containers for all of the meshes, particles, script components, occluders and physics objects. They can also contain other entities as children. They have their own transformation that determines their position, scale and rotation in the world.\nPrefabs Prefabs are template entities which do not sever the connection to the prefab even after it is saved in a scene. Complex entities can be constructed one time and saved as a prefab to be used at any time, in any scene. Later updates to the prefab will affect the already done scenes as well. In Bannerlord, nearly all of the mission objects and scene props are prefabs.\nConnection Rules Once a prefab is placed into a scene, all of the values under prefab(mesh colors, child entity transforms, script values) are connected to the original prefab and will be updated after every change to the original one. Any change in the scene for those values will sever the connection. Beware that any “Addition” operation to the prefab in the scene, will break the prefab connection all together. Examples: adding a new mesh, particle system, light, child entity or script component.\n"
},
{
	"uri": "http://localhost:4444/asset-management/faq/",
	"title": "Frequently Asked Questions",
	"tags": [],
	"description": "",
	"content": "How to install the tools? You can download the “Mount \u0026amp; Blade Bannerlord Modding Tools” from the Tools section of steam. Note that the tools use some of the files downloaded within the game itself. Thus, the tools and game should be at the same version and installed on the same harddrive.\nHow to launch the tools? You can use the SinglePlayer option from the Launcher and once you are in the Initial Menu, you can either press the Editor button or press the Ctrl + E key combination to start up the editor.\nHow to create your own module? We have a built-in functionality in the editor which creates a new module and populates it with example xml files registered to the module for ease of adding new content. After opening the editor, you can use the “Create New Module” option in the “File” menu from the top toolbar. Note that you need to restart the game in order to register the module from the Launcher.\nHow to edit Native resources? You cannot edit native resources, you can override them on your own module. For details look at http://docs.modding.bannerlord.com/asset-management/asset-types/overriding_assets/\nI can’t add new meshes, textures etc. You cannot add resources to native modules, you should add them to your own module. First, you need to create a new module: http://docs.modding.bannerlord.com/asset-management/quickguide_create_a_mod/ For the details of adding new assets: http://docs.modding.bannerlord.com/asset-management/asset-types/overriding_assets/\nExample scenes to look at? empire_village_003 khuzait_castle_002 sturgia_town_b battle_terrain_v empire_castle_keep_a_l3_interior empire_house_c_tavern_a empire_dungeon_a arena_empire_a Main_map\nWhere to find example assets? You can inspect native resources from Resource Browser but there aren\u0026rsquo;t source files for these and you cannot export them. We will be providing some example source files soon.\nI have mods with DLL’s and my modding tools does not launch. If you have any mods with DLL’s enabled, be sure to copy them to the Modules\\MOD_NAME\\bin\\Win64_Shipping_wEditor folder as well.\nMy modding tool does not launch. Be sure that Visual Studio 2013 Redist x64 is installed in your machine. Also, check whether the version numbers for the base game and modding tools match. If all of the above checks does not work, you can create a new topic in the “Bug \u0026amp; Crashes” section of the modding forums(https://forums.taleworlds.com/index.php?forums/bug-crash-reports.784/).\n"
},
{
	"uri": "http://localhost:4444/",
	"title": "Live",
	"tags": [],
	"description": "",
	"content": "Welcome to the Mount\u0026amp;Blade Bannerlord Modding Documentation To acces the \u0026ldquo;Frequently Asked Questions\u0026rdquo; section, see F.A.Q.\nFor a quick guide on creating and registering modules, see Modules-Quickguide.\nFor further information:\n [Asset Management]Creating \u0026amp; editing a module which can contain assets, scripts, scenes and gamelogic data which is either new or an override for an existing one in the base game. [Bannerlord Missions]Detail about how script components work, when does the callbacks get triggered and some specific script templates that Bannerlord use to create the gameplay experience. [Editor]Information about how to use the scene and content editors with maximum efficency.  "
},
{
	"uri": "http://localhost:4444/editor/resource-editors/material_editor/",
	"title": "Material Editor",
	"tags": [],
	"description": "",
	"content": "Overview Inspector Shader pbr_shading This shader is heavily used and exists just because our engine did not use PBR shading pipeline in the early years of development, most content was not created for PBR pipeline, so this shader is created to support our already existing content and only used during the transition phase. New content should not use this shader, instead you should use pbr_metallic.\npbr_metallic This is what you should use most of the time. This shader uses standard metallic PBR pipeline and inputs are compatible with most texture authoring softwares.Inputs:Albedo and Normal: These are pretty standard, outputs of texture authoring softwares can directly be used. Specular: This texture uses its 4 channel for different purposes. Red channel contains Metallic information, Green channel contains Glossiness (inverse of Roughness), Blue channel contains Ambient Occlusion, and Alpha channel contains Translucency (for vegetation shaders only) grass This shader is a derivative of pbr_metallic, and should only be used on grass meshes. Contains special effects like wind animation, sway animation, smooth LOD transition, color multiplication from terrain, etc.\nflora_leaf This shader is a derivative of pbr_metallic, and should only be used on leaf parts of trees / bushes. Contains special effects like wind animation, sway animation, color multiplication from terrain, smooth LOD transition, translucency (Alpha channel of Specular texture), etc.\nflora_bark This shader is a derivative of pbr_metallic, and should only be used on bark parts of trees / bushes. Contains special effects like wind animation, smooth LOD transition, etc.\nTextures Diffuse2Map This input is used internally by engine to create special effects / blendings like Shield Banner Paintings, Banner texture in this slot will only appear where Diffuse 1 Texture contains alpha. Usage of this texture really depends on the shader used.\nDetailNormalMap This input is used to create micro imperfections and additional high frequency detail on top on regular normal mapping. Scale of this texture can be adjusted in Texture Settingspanel\nHeightMap This input is used in both Parallax Occlusion Shading, and Displacement.\nDecal(___)Map These inputs are used internally by engine to create skinned decals on entities (like blood and mud on agents).\nTexture Settings Areamap Scale Used internally for parameter passing.\nSpecular Coef Metallic channel (Red channel of Specular texture) is multiplied by this value in shader.\nGloss Coef Gloss channel (Green channel of Specular texture) is multiplied by this value in shader.\nAmbient Occlusion Coef AO channel (Blue channel of Specular texture) is multiplied by this value in shader.\nNormal Depth Normal textures X and Y channels are multiplied by this value. If you set a value close to Zero, surface will appear more flat since X and Y values will be close to zero and only Z direction is contributed to normal mapping.\nDetail Normal Scale This parameters sets how many times the detail textures should tile. Higher values increases frequency.\nParallax Mode You can select displacement method to use for this material. Options are, Parallax or Displacement. Both require a heightmap texture. Parallax uses Parallax Occlusion Mapping in shader, Displacement uses hardware tesselation.\nParallax Amount Intensity of displacement effect.\nParallax Offset Sets the middle value to a desired height. (Value of 0.5 in heightmap).\nMaterial Shader Flags use_detailnormalmap This flag should be enabled to utilize Detail Normal Map feature.\nalpha_test Diffuse 1 textures alpha values are used as a cut-out texture. Alpha threshold can be specified in Transparencypanel.\nuse_specular This flag should be enabled in all cases. It is only here for lagecy reasons.\nuse_procedural_wind_animation Can be enabled to create a very simple and cheap, sine wave wind effect. Mostly used for tents / flags. (Should not be mistaken with cloth physics feature).\nself_illumination Enables self illumination. Illumination texture should be specified in Diffuse 2. Brightness parameters can be adjusted in Vector Arguments panel.\nuse_specular_from_diffuse Never ever use this. It is only used in pbr pipeline transitioning phase and only here for legacy reasons. Simply grayscales the diffuse texture, and uses it as specular texture.\nuse_double_colormap_with_mask_texture Used internally to create team color effect in clothing. A special texture is created to specify which parts of clothing should be affected by team colors. A simple Red / green texture for primary and secondary colors is specified in Diffuse 2 texture. Primary and Secondary colors are set by gameplay code as Factor Colors.\nTransparency Others Vector Arguments Factor Colors Vertex Layout Bump Map Should be enabled in most cases (Standard PBR requires this).\nSkinning and Skinning Precise If your material is going to be used with a skinned mesh, enable Skinning, if your skinned mesh is quite large that has important small polygons (like eyes) enable Skinning Precise. (This disables some optimizations so only use if it is really necessary).\nDouble UV Enable if your custom shaders require double UV channels.\nPostFX Used internally by engine.\n"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/materials/",
	"title": "Materials",
	"tags": [],
	"description": "",
	"content": "Materials define the rendering characteristics of meshes. They contain the shader and texture information, also the rendering flags (defined from by shader and the global ones). A mesh can have a single material. The initial value of a mesh\u0026rsquo;s material will be assigned through it\u0026rsquo;s given material name in the 3rd party mesh editing applications. Materials can be created and edited through the Material Browser which can be accessed through the Resource Browser. The material can also be edited at runtime through scripts and behaviours. More information about material editing and default materials of the engine can be found at the Material Editor.\n"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/meshes/",
	"title": "Meshes",
	"tags": [],
	"description": "",
	"content": "Meshes contain the polygon positions and attributes to be used at the rendering pass. Every mesh has one material that defines their rendering behaviour. They are grouped inside MetaMesh\u0026rsquo;s by their LOD level. Also, at the same LOD level, there can be multiple meshes with different materials. More information about importing meshes to the engine can be found at Material Editor.\nLOD System Modern engines use LOD(level of detail) systems to ensure that the amount of GPU share used by the closer parts of the screen is more than the far ones. This is done by reducing the mesh qualiy with respect to the distance to the camera. This system ensures that the polygon per pixel ratio is similar across the screen as much as possible. The default LOD distances are as follows: 15, 22.5, 30, 50, 70, 130, 210 meters. These distances are for the best graphics quality and they can be reduced via the Environment Quality and Character Quality options.\n"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/tactical_positions/",
	"title": "Mission Tactical Positions",
	"tags": [],
	"description": "",
	"content": "TACTICAL POSITIONS AND TACTICAL REGIONS These are scripted entities that let the AI know of the terrain\u0026rsquo;s features. They do not work like siege, the AI will not always use the tactical positions or regions you may place. They may use them under conditions that favor the use of these.\nDepending on player movement and spawn path randomization, there are a very high number of scenarios that can occur during battles. Because of this, it is better to have as many meaningful positions and regions marked as possible but not having these or not marking some of the meaningful positions will not result in obvious errors like in siege but will result in less interesting battles because AI won\u0026rsquo;t be aware of their surroundings. Types and how to use different tactical positions and regions:\nTactical Positions High Ground, Slope facing direction These are for advantageous high ground positions facing one direction. The AI may hold these positions if the enemy is approaching from the direction the tactical position is facing. Direction is the most important part. The position to defend will face the forward direction(green arrow in editor) of the position. Paramaters are as follows:\nTop of Hill, Defendable against all directions This is for high ground positions at the top of hills, easy to defend against all directions. AI may hold these positions regardless of the enemy approach direction. AI will position themselves on top of the hill according to enemy position. Direction is not important.\nChoke Points These are for positions with impassable barriers on either side. AI with inferior numbers may try to hold these positions in order to mitigate their number disadvantage.\nCliff Positions These tactical positions are meaningless by themselves. They should be put in entity hierarchy under choke point tactical positions. If placed under a choke point and the AI employs that choke point, only then cliff positions will be used.\nTACTICAL REGIONS These are for marking regions in scenes. Only a radius is given and the region is circular in shape. Obviously scenes will have regions with completely custom/random shaped forests, difficult terrains and openings. Therefore multiple tactical regions with various circular areas should be defined, as many as needed can be added. The radius and the circular area of each region can be a rough estimate, doesn\u0026rsquo;t need to be precise.\nForest Areas AI may use positions inside forest areas if the enemy has a superior number of ranged and cavalry units because archers and cavalry are less effective in forests. Any other region that is disadvantageous for both missile units and cavalry can be given a forest region, it doesn’t necessarily need to be a forest and have trees etc., it can be a marketplace with lots of obstacles and cover or something like that.\nDifficult Terrain This includes rocky terrain as well as swamps, or may be even marketplaces or some location with many obstacles on the ground, any area that does not hinder ranged fire(like forests) but impede and slow down cavalry should be considered and marked difficult terrain. AI may use positions inside difficult terrain areas if the enemy has a superior number of cavalry units.\nOpen Areas Positions that allow fast cavalry movement and clear missile fire. This region type is for marking suitable battlegrounds. The AI may choose to make their defense in Opening areas if they have superior or equal number of ranged and cavalry units.\nTACTICAL REGIONS AND POSITIONS COMBINATIONS Tactical Positions described in section A can also be placed under Tactical Region entities. Their _tacticalRegionMembership should be correctly selected. In this situation, AI will realize the choke point is also in a forest region and under right conditions, can prefer that choke position or high ground accordingly.\n"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/asset_naming_conventions/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": "To distinguish and organize assets and simplfy asset authoring process there are some predefined rules to consider.\nMeshes All meshes imported from a single geometry file(e.g. fbx) are grouped by their names. To add a LOD mesh simply append \u0026quot;.lod\u0026lt;n\u0026gt;\u0026quot; to the name of your mesh. Here n is the number of lod.\nConsider an fbx file as below :\nasset.fbx :\n wall_damaged wall_damaged_v2 wall_damaged_v2.lod1 wall_damaged.lod1 wall_damaged.lod2  Two meshes will be imported from asset.fbx file : wall_damaged, wall_damaged_v2. These meshes will have one and two lods respectively. If your modelling software does not support dots in names(e.g. Maya) you can also use \u0026ldquo;_\u0026rdquo; insted of \u0026ldquo;.\u0026rdquo; to specifiy lods(e.g. wall_damaged_v2_lod1).\nA mesh can not have more than one material so during import phase meshes wil be divided into submeshes according to material usages of polygons. Consecutive numbers will be appended to the names of these auto generated meshes. Consider a mesh wall_damaged using three different materials. Name of the imported mesh will be wall_damaged and it will have three submeshes with names wall_damaged.1, wall_damaged.2, wall_damaged.3.\nPhysics shapes You can export physics shapes just like regular meshes. The only difference between a mesh and a physics shape is that name of physics shapes begin with \u0026ldquo;bo_\u0026rdquo; prefix. You can also export analytical capsules and spheres as well.\nCapsules\nIf name of a node begins with \u0026ldquo;bo_capsule\u0026rdquo; it will be imported as an analytical capsule shape. Sizes of this capsule is determined by following rules :\n Local XY axes assumed as the radial plane of capsule Local Z axis assumed as the direction of capsule(height) Scale of object in XY directions should be equal  Only orientation and extents of capsule nodes are used. Any content attached to them(like mesh) is ignored.\nSpheres\nIf name of a node begins with \u0026ldquo;bo_sphere\u0026rdquo; it will be imported as an analytical sphere shape. Sizes of this sphere is determined by the extents of the node. Center of the node will also be the center of the sphere shape. Only orientation and extents of sphere nodes are used. Any content attached to them(like mesh) is ignored.\nComposite Shapes\nYou can combine different shape types to create more complex shapes. To export a composite shape you must create a node whose name begins with \u0026ldquo;bo_composite\u0026rdquo;. You can append child nodes with different shape types to this node.\n bo_composite_building1 bo_capsule1 bo_capsule2 bo_sphere bo_building_walls  This shape will be imported as a single asset with name bo_composite_building1.\nTextures You can provide basic hints for your texture by following by following these rules:\n Albedo textures ends with _d Normal textures ends with _n Specular textures ends with _s Heightmap textures ends with _h  Despite these rules are not obligatory, it will help engine to decide best compilation rules during first import and help some features of editor to work(e.g. auto completing normal texture slot of material). If your textures do not follow them you can change import settings later though.\nSkeletons Most of in-house assets are organized so that skeletons, meshes and animations using these skeletons are stored in separate files. So we follow some naming rules to correctly establish cross-references between these files. If you are also planning to import skeletons, meshes and animations from different files :\n Bone hierarchy of skeletons must match Every bone node should have its name ending with a hardcoded bone number(e.g. _0, _1) to make sure skeletons originating from different files have their bone numbers match regardless of export process of your modelling software or exporting tool. There are these rules that each bone name must follow : Appended bone indices must start from zero Appended bone indices must not be greater than or equal to number of bones Two bones can not have same bone index  Skeletons take their names from the root node of bone hierarchy in your geometry file. This is to let you name your skeletons something other than the name of root bone. If your root bone does not have a parent node, you can create a dummy node and make your root bone child of it. By renaming dummy node you will be able to rename your skeleton without affecting bone names.\n"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/overriding_scenes_prefabs/",
	"title": "Overriding Scenes and Prefabs",
	"tags": [],
	"description": "",
	"content": "You can override existing scenes and prefabs by creating new one with the same name.\nPrefabs Prefab definitions are stored in xml files located in Prefabs folder in each module\u0026rsquo;s directory.\nScenes Scenes are stored in two separate folders SceneObj and SceneEditData in each module\u0026rsquo;s directory. SceneObj folder stores necessary files to open scene in client mode while SceneEditData stores files necessary for editing operations.\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/path_editing/",
	"title": "Path Editing",
	"tags": [],
	"description": "",
	"content": "Level designer can easily add, edit or delete paths and path points by the scene editor.\nAdding a new path User can use the Add New Path button at the upper toolbar. User should enter a unique name for every path. After the path is added, the editor\u0026rsquo;s editing state will become \u0026ldquo;Path Select\u0026rdquo;. By spacing either space or the \u0026ldquo;Add a new path point\u0026rdquo; button from the upper toolbar, user can transition to the \u0026ldquo;Path Node Add\u0026rdquo; mode and start adding new path nodes. At every click one more path node will be added to the current selected path. By pressing space again, user can start selecting and editing the existing path nodes. Every path node has three transform points. These are the center(cube) and the two tangents(spheres). User can hover onto them and select them by pressing the left mouse button. Then, pressing \u0026ldquo;T\u0026rdquo; button will spawn the transformation triad which can be used to move these points. Every operation can be undone by the \u0026ldquo;Control z\u0026rdquo; key combination. Selected path nodes can be deleted via the \u0026ldquo;Del\u0026rdquo; key. A path can be deleted by selecting the path and hitting the \u0026ldquo;Del\u0026rdquo; button. Also, to select another path, one can just hover into one of its node poinmts and pressing the left mouse button.\n   Add a new path Add a new path point Select a path point           "
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/path/",
	"title": "Paths",
	"tags": [],
	"description": "",
	"content": "In RGL, \u0026lsquo;Paths\u0026rsquo; are used to define continous points within a scene. They have unique names and can be used by the gameplay logic for different reasons. Paths define how the siege engines move in missions. Also, for field battle missions, initial spawn point candidates are defined via a path. The spawn logic selects two positions for the teams with respect to the size of the battle. Detailed information about path editing can be found at Path Editing.\n"
},
{
	"uri": "http://localhost:4444/playing-sounds/",
	"title": "Playing Sounds",
	"tags": [],
	"description": "",
	"content": "Adding Sounds to Your Module"
},
{
	"uri": "http://localhost:4444/editor/resource-editors/",
	"title": "Resource Editors",
	"tags": [],
	"description": "",
	"content": "Material EditorSkeleton EditorCloth SimulationMeta Mesh EditorModel ViewerTexture Editor"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/",
	"title": "Scene Editor",
	"tags": [],
	"description": "",
	"content": "Creating EntityEditor ShortcutsPath EditingTerrain CreationEntity InspectorNavigation Mesh InspectorAlignment and Snapping ToolsDistance ToolMass SelectionPrecomputed Radiance Transfer - GI SystemResizing TerrainScene Level SystemTerrain Mesh Blend System"
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/scripts/",
	"title": "Scripts",
	"tags": [],
	"description": "",
	"content": "Script components are executable scripts that are attached to entities and can be used to implement various gameplay functionalities. In Bannerlord, many gameplay logic are written via script components. For example chairs, dropped weapon, siege machines. There are many different callbacks that can be inherited and filled in these script components.\nCallbacks  Constructor: In constructor one needs to assign default values to its public variables(variables which can be changed by the scene maker). In constructor script component is not assigned to an entity or scene. Also, you should not write any logic that has any side effect because , even though it is created, the script component may be deleted once the scene is opened because of the upgrade level system. OnPreInit: This is called after the script component is assigned to its owner entity in the scene. Once you are in this callback , you can be sure that the user defined variables from that script instance are set. However, the other script components of the other entities may not be assigned yet. Thus, in pre init there should not be any logic code that relies on other script components. Example, in pre-init ManagedObject registers himself to the managed object array in the current mission instance. OnInit: This is called once the mission is loaded and all of the script components of the entities are initialized. You can use any type of logic code inside this callback. Run time instantiated scripts also get this callback called. OnEditorInit: Editor version of on init. It is called when the scene is loaded from the editor. Beware that there is no mission or game state in editor. OnTick: This is called for every script component every frame on mission from the same thread. OnEditorTick: Editor version of the OnTick function. IsOnlyVisual: If you have a script component which is only visual and does not have any logic code that should be running in the dedicated server , you should return true in this function. This ensures that this type of scripts does not run on dedicated server. OnEditorVariableChanged: This is called in editor whenever a public variable in that script component is changed by the user. This callback can be used for any visual-logic state change if the artist needs instant feedback on the editor scene. OnRemoved: Called when the entity or the script component is being removed. If you have any allocated objects which are stored in somewhere else (for example static containers), you can use this callback to ensure that they are not leaked.  "
},
{
	"uri": "http://localhost:4444/editor/resource-editors/skeleton_editor/",
	"title": "Skeleton Editor",
	"tags": [],
	"description": "",
	"content": "Skeleton editor can be used to edit, bones, joints, and ragdoll parameters of skeletons after importing them using resource browser.\nEditing Bones and Joints To edit a bone or joint, you can select the item you want from the outliner panel. This will create an Inspector of bones/joints for you to edit. All parameters are visualized and all edits will immediately be visible in the preview. Joint Properties Axis lock Axis lock limits the movement the child bone in translation space. Can be adjusted independetly for every axis. None:means This joint is not allowed to move in this axis. Free:means This joint is allowed to move freely as far as it can go in this axis. Limited:means This joint is allowed to move to as far as specified distance in this axis. (Axis Limit parameter) Twist Lock Twist lock limits the rotation the child bone in Z axis (Twist axis). Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to rotate. Free:means This joint is allowed to rotate freely as much as it can. Limited:means This joint is allowed to rotate to a certain limit. (Twist Limit parameters) Swing Lock Swing lock limits the rotation the child bone in X and Y axis. Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to swing. Free:means This joint is allowed to swing freely as much as it can. Limited:means This joint is allowed to swing to a certain limit. (Swing Limit parameters) All of these parameters are visualized in the preview. Feel free to modify and see the effects for yourself.\nBone Properties Bone properties can be used to change ragdoll and collision capsules. Capsule visualization can be enabled in Display panel. You can change capsule radius, Position 1 (Top of capsule), Position 2 (Bottom of capsule) from Properties panel.               Ragdoll Simulation Best way to visualize your changes is to enable ragdoll simulation and see your changes in real time. Simple select a skeleton from outliner, and hit Red \u0026ldquo;Simulation Enabled/Disabled\u0026rdquo; button. This will enable ragdoll simulation. Pressing this button again will disable ragdoll simulation and reset the skeleton to T-Pose.\nTesting and Saving changes "
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/skeletons/",
	"title": "Skeletons",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/editor/scene-editor/terrain_creation/",
	"title": "Terrain Creation",
	"tags": [],
	"description": "",
	"content": " Create a new terrain Terrain creation, removal, and node modifications can be done in Terrain Inspector \u0026gt; Propertiestab. Terrain node count in both dimensions, their resolution and size can be specified in New Terrain Propertiespanel.This parameters must be specified proir to the creation, although they can be canged per-node basis later.\n              Adjusting node properties Node resolution can be adjusted by selection nodes (Hold CTRL for multiple selection)m and change the resolution parameter in Node Propertiespanel. This feature can be used to further optimize terrain in places where resolution is not that important (eg. Outside of Settlemets where player is not allowed to go, or nodes that are completely under water). Import / Export Materialmaps or Heightmap To support external terrain generation softwares, engine can Import / Export terrain layer materialmaps or heightmap. You can easly create believable terrains by importing various layers (Debris, flowmap, vegetation, bedrock), and 16-bit heightmaps. To import a materialmap, first you must create a new terrain layer, after selecting this layer, go to Properties tab, select some nodes (CTRL + A to select all) and hit Import Materialmap button. This will open file selection dialog, you can select any 8-bit (grayscale) texture to use as materialmap. You can do the same to import Heightmap, heightmaps can be 8-bit or 16-bit (png or raw).\n                    "
},
{
	"uri": "http://localhost:4444/asset-management/asset-types/textures/",
	"title": "Textures",
	"tags": [],
	"description": "",
	"content": "Textures can be imported through the Asset Browser. They can be assigned to materials via the Material Editor. The texture slots of the PBR materials can be found at Material Editor.\n"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/villages/",
	"title": "What Makes a Village Scene",
	"tags": [],
	"description": "",
	"content": "Introduction This list of checkpoints should aid you in creation of village scenes and provide you with an insight into what we pay attention to when creating village scenes.\nNavigation Mesh  Navigation mesh consists of triangles and quads. It is used by the AI for pathfinding. The global illumination system also uses it to find the visible locations of the scene. Keep in mind that the navigation mesh faces should not be too far away from the physics below it. The distance should at 1.5m maximum. The faces can be labeled to give cues to the agent spawning and the navigation inside the scene. In order to make the agents follow roads, we label the faces on top of the roads with the ID 2. Note that all of the agent spawnpoints should be connected by navigation mesh faces with ID 2. For the animals, navigation mesh ID 3 can be used. Typically, these faces are kept within separate islands in structures like ditches. The animals will then roam inside those islands only. All other faces should have the ID 0. Remember that the agents should use the navigation mesh ID\u0026rsquo;s 1 in order to create realistic pathing (on roads), scene designer should put an entity with the Navigation Mesh Deactivator (prefab name is Navigation_Mesh_Deactivator). It can be placed anywhere in the scene. Its purpose is to disable the ID 0 faces in civilian modes. The DisableFaceWithID variable of the script should be 1. For the animals, the variable \u0026ldquo;DisableFaceWithIDForAnimals\u0026rdquo; within the same script should be 3. Make sure the faces are fairly equal in size outside of the village area / where troops will maneuver. Make sure there are no disconnected navmeshes. The better the navmesh, the better will AI perform on it. Always think about that there might be big field battle inside the village. So try to avoid having many enclosed areas like a pig farm with only 1 entrance (for example: throw over some fences to create more entries) Avoid having big areas accessible to the player but not AI. Player will be able to shoot AI from places without navmesh. Use “_barrier_ai_x” to prevent AI from falling off from cliffs or getting stuck in tight areas (like a market booth) off the navmesh.  Spawn Points As noted before, all spawn points need to be placed on top of navmesh (ID 2) and inside the soft borders. Remember that some prefabs (like chairs and benches) come with spawn points attached to them. If the spawn points aren\u0026rsquo;t compatible with the village mission, they will most likely crash the game or cause errors. One example is \u0026ldquo;sp_blacksmith_with_smithing_machine\u0026rdquo;. The most important thing about the entry points are their tags. They decide what type of NPC will spawn there. For your own sake, don\u0026rsquo;t play around with those tags too much and keep them as they are from the prefabs.\n![](/img/village_scenes/3. Entry Points.png)\nPlayer Spawnpoint  Prefab: sp_player. Make sure it\u0026rsquo;s placed in a location where it can be seen from or at least has a clear path leading towards it. Do not place it too far away. There should be a navigation mesh under the spawnpoint.  Battle Spawnpoints  Prefab: Sp_battle_set. Make sure the attacker and defender spawns aren\u0026rsquo;t too close to each other or at least don\u0026rsquo;t have direct line of sight to each other. Make sure to move the reinforcement point out of sight as best as possible while still not being too far from the front lines. Make sure all spawnpoints have some empty space around for troops to properly spawn in.  Conversation Spawnpoints (civilian)  Prefab: sp_player_conversation. Conversation points define where the agent and the conversation partner spawn when the player enters the village via the \u0026ldquo;Talk to Notable\u0026rdquo; button from the World Map. Make sure they have a nice vista but keep them relatively close to the village center.  Animation Points (civilian)  Prefab: sp_npc_x. These are used for normal villagers. You can use around 40 positions. They define the positions in scenes where the villagers will spawn and walk to. Make sure they are nicely spaced throughout the village and close surroundings. Villagers will wonder along paths to get to them. If the paths are too long you might find your villagers wondering around at all times with nobody actually doing anything. Try to avoid long distances and place points close to the main paths. Placing more or less spawnpoints doesn\u0026rsquo;t influence how many villagers will populate the scene.  Rural Noteable Spawnpoints  Prefab: sp_notable_x. The number of prefabs should be around 6. These are the spawnpoints for the notables of the village (quest givers) and lords. Make sure they are in a prominent location of the village or generally places where village elder / lords would hang around. You can check the Debug Window (documentation will cover that) to make sure you have placed the correct notable positions. Go to the “Scene Entity Check Tab” and tick the “NPCs” Box and count.  Bandit Camps  Prefab: common_area_x. Each village scene has 3 Bandit Camps outside the village (place 3 prefabs), used for scene quests. Use the same spawns as for normal villagers (~15 per camp). Try to not have them do chores like farming. You can also use patrol spawnpoints: sp_guard_patrol_simple, sp_guard_patrol”. All spawn points in the radius will spawn bandits instead of villagers. You can increase the radius by scaling the common area prefab. Use civilian animation points as spawn points for bandits, some suggestions: “sp_npc_wait_wall, lookout, sp_npc_argue_set, sp_npc_wait”. Make sure that there is some indication to where they could be so that the player has a chance of finding them (especially at night). Don\u0026rsquo;t place them too close to each other.  ![](/img/village_scenes/4. Bandit Camps.png)\nAnimal Spawnpoints  Prefab: sp_animalName. Use “DisableWandering” in the AnimalSpawnSettings script, to stop animals from walking around your scene. Overall its best to put it on all bigger animals like cows and pigs if they aren\u0026rsquo;t there to wonder around.  Tactical Region  Prefab: TacticalRegion. Used to tell the AI where there are relevant bigger regions (forests, hills etc.). AI will position themselves inside the radius or avoid it. Don\u0026rsquo;t overuse it, stick to ~5 (make sure there is some variety).  Tactical Positions  Prefab: TacticalPosition. Used to tell the AI where there are relevant smaller positions (like choke points between buildings, cliffs for archers and so on). AI will position themselves according to the rotation of the Prefab and in regards to the width given by the script. You can use them quite often. The higher the slope the “better” is the position.  ![](/img/village_scenes/5. Tactical Positions.png)\nFlee Positions  Positions to which fleeing troops and also horses will run away too. Make sure they are inside the Soft Border and that there is a navmesh below them.  ![](/img/village_scenes/7. Flee Positions.png)\nDebug Window  Prefab: SpawnPointDebugView. There is a built-in debug tool which can be enabled by adding the above prefab to the scene. Place the prefab anywhere in the scene and activate the window with the check box in its script. This prefab opens a little debug window in the editor that helps you make sure you meet the requirements for the mission (like spawn points, navmesh). In the “Scene Entity Check Tab” you can count your Entry Points and make sure you have placed enough of them (or too many). In the “Navigation Mesh Check Tab” you can make sure all your Entry Points are connected to the navmesh properly.  ![](/img/village_scenes/2. Debug Window.png)\nSoft Border  Prefab: border_soft. They define the red borders of the scene. When placed they form a polygon where the 2 edges connect between the closest two border entities (but never more than two). To check the current borders, go into the \u0026ldquo;Visibility Window\u0026rdquo; → \u0026ldquo;Visibility Masks\u0026rdquo; and enable \u0026ldquo;Borders\u0026rdquo;. After crossing them the player has a few seconds to return inside the map borders, make sure this can\u0026rsquo;t be abused somehow.  ![](/img/village_scenes/6. Borders.png)\nSounds Master Ambient Sound  Prefab: x_ambient_sound. Choose a mandatory master ambient sound. You can place the prefab for the mandatory ambient sound anywhere. Make sure it has the “Is Master Sound” enabled. Make sure it doesn\u0026rsquo;t have the “Is Triggered” enabled.  Additional Ambient sounds  Used for bigger areas (like forests). Needs to have the “Is Triggered” bool. To see how far it reaches, from the \u0026ldquo;Visibility Window\u0026rdquo; enable \u0026ldquo;Sound Entities\u0026rdquo; under the \u0026ldquo;\u0026ldquo;Visibility Masks\u0026rdquo; group. To change their reach, you can scale them like you would do with other editor entities (using the “b” key or the gizmo).  ![](/img/village_scenes/8. Sounds.png)\nReverb  There are different prefabs for each use case: reverb_x. Adds reverb effect to any sound spawned inside its boundary. They are generally used for tight or underground areas. You can place these in tight alleys between taller buildings, cliffs, in caves or in dense forests. Needs to have the “Is Triggered” enabled.  Detail  Used for small details. Make sure “Is Triggered” is disabled. Place them where ever you want them to play.  Moving sounds on paths (for rivers and such) Sometimes it\u0026rsquo;s useful to move sounds along a coast line or a river. The below technique is more performance-friendly and more precise than placing multiple sound entities along your river for example.\n Place a path on the river. For more information, see Path Editing. Add the sound to the scene. Place any additional Ambient sound as explained above. Add the “path_converger” script to your ambient sound\u0026rsquo;s entity. Enter the name of your path to the \u0026ldquo;path_converger\u0026rdquo;. The sound will now follow the path according to the camera position.  Sounds in the Engine You can check the \u0026ldquo;MODDING_TOOLS_DIRECTORY/Sounds/GUIDs.txt\u0026rdquo; file for the list of the sounds in the game. These names can be used inside the script of the sound entities.\nLights  Have at least one “envmap_prop” in your scene. For darker areas like caves use “local_envmap_prop”. It will affect the lighting in an area depending on the values of its “ReflectionCapturer” script. Make sure the village and bandit camps are nicely lit. Take extra care for the conversation points. Use torches and other entities. Make sure torches inside buildings and other dark areas have “alwaysBurn” enabled in the LightCycle script. Try to avoid placing “artificial lights” without an actual source. You can bake the ambient lighting in your scene with the GI system. This will make the ambient lighting much more realistic. For more information, see GI System.  ![](/img/village_scenes/9. Lights.png)\nAtmosphere  Make sure your scene works and looks fine with all of the “TOD_x” atmospheres and in all seasons! (since it will be tested with those). Choose a “Color Grade” that fits your scene (we suggest using the ones for the faction your scene is for, like: “color_grade_empire_soft”).  ![](/img/village_scenes/10. Atmosphere.png)\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/entity_inspector/",
	"title": "Entity Inspector",
	"tags": [],
	"description": "",
	"content": "Transform Panel Transform panel allows you to change position, rotation and scale properties of the selected entities. All of these values are relative to the parent of the selected entity. If Entity has no parent, then they are the Global values. (in Worldspace).\nScale Locked If the lock icon is in locked state, changing any component of scale parameter will set all scale components to the same value, entity will be in uniform scaling mode.\nUnlocked If the lock icon is in unlocked state, every scale component can be changed independently, and will allow non-uniform scaling.\nTransform with Gizmo Transform modes All of the transformation can also be done using Gizmo. Gizmo can be activated by selecting an entity (or multiple entities) and pressing one of the hotkeys below.\n   Rotate Translate Scale     Hotkey: R Hotkey: T Hotkey: Y         Transform spaces Gizmo can work in three different spaces; Worldspace, Localspace and Screenspace.\nWorld space World coordinates is just a fixed, parent coordinate system. This is the global coordinate system that everything is defined relative to. World Coordinate has a fixed [1, 0, 0] in the Xdirection, [0, 1, 0] in the Ydirection, and [0, 0, 1] in the Zdirection.\nLocal space Local coordinates are relative to the entity itself, every transform is defined such as that the center of the entity is center of the universe.\nScreen space Screen space coordinates are relative to the camera. Right of your viewport is always the Xaxis, Top is always the Yaxis, and forward is always the -Z(minus Z) axis.\nEntity Tag System An entity on editor can be identified by a tag defined by the user.\nAdding Tags In the Entity Inspector, under the \u0026ldquo;Tags\u0026rdquo; title, there is a button with label \u0026ldquo;Add New Tag\u0026rdquo;. This button opens a window asking for the name of the tag.\nUsing an Existing Tag After clicking on the \u0026ldquo;Add New Tag\u0026rdquo; button, from the dropdown menu in the window, you can select tags, which were added to the current scene entities before.\nA Special Case: Prefabs If you are modifying a prefab entity, adding tags to the prefab does not break it. In other words, if you change the prefab after tagging the prefab entity in the scene, the scene entity will have all the changes as well. The tags are stored in the xml files with \u0026ldquo;\u0026lt; tags \u0026gt;\u0026hellip; \u0026lt; / tags \u0026gt;\u0026rdquo; syntax. (without the white spaces between characters)\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/nav_mesh_inspector/",
	"title": "Navigation Mesh Inspector",
	"tags": [],
	"description": "",
	"content": "Tools These tools help you to generate and manipulate the navigation mesh:\nGeneration Tools  Auto Generate: As the name implies, automatically generates the navigation mesh with resppect to the parameters above. Generate Grids: Generates grid navigation mesh for the terrain only. It ignores the entities on the scene. Create New Face: Creates a new navigation mesh quad face on the coordinates where the camera is. Extrude: Remove: Removes the selected navigation mesh edge. Fill: Fills between the selected navigation mesh vertices and forms a face. Grow Selection: Grows the selection by selecting the adjacent elements to the selected elements (Works for all vertex, edge and face structures) Connect: Connects the selected two navigation mesh vertices by drawing an edge between them. Subdivide: Divides the navigation mesh edge by putting a vertex on the middle of it. This vertex is connected to the adjacent vertices and divides the face of interest. Weld: Removes vertices forming the edge and makes the edge one single vertex. It connects the old adjacent vertices to the newly generated vertex. Import Faces From Prefabs: Imports faces which were exported for later use. Import Body: \u0026lt;not_known\u0026gt; Make Quads When Possible: Selects adjacent triangle faces, which can construct quads (which do not form a concave polygon). This is not going to construct the most optimal nav mesh, having faces with the greatest surface areas, but it will locally select the triangles forming the greatest surface area. It will still reduce the total number of faces strongly.  Debugging Tools  X-Z Keys: Puts two different spheres per key, and when both are put, gives statistics about the path defined between these two spheres. Select Vertices Below Entities: The name implies the purpose. Select Unwalkable Edges: \u0026lt;not_known\u0026gt; Fix Concave Faces: Makes the concave faces convex. Select Unconnected Faces: \u0026lt;not_known\u0026gt; Calculate Auto Weld Points: \u0026lt;not_known\u0026gt; Select Inverted Faces: Finds and selects the inverse faces, facing towards the terrain. Find Path: \u0026lt;not_known\u0026gt; Paste Copied Faces: The name implies the purpose. Copy Selected Faces: The name implies the purpose. Export Faces as Prefab: Exports the selected faces for later use. Ensure Faces Are Not Below Ground: The name implies the puspose. Remove Unreachable Faces: Removes the faces which are not connected to any island, in which there is a spawn point. (Spawn points are decided according to the entities in Prefabs/editor_spawnpoints.xml, also entities containing AnimationPoint script.) Find Tight Faces: Finds faces whose surface area is below the desired value, and selects them. You can press the \u0026ldquo;delete\u0026rdquo; button to remove these faces. After doing this, do not forget to \u0026ldquo;Remove Unused Vertices\u0026rdquo;, which I\u0026rsquo;ll be mentioning a few lines below. Remove Unused Vertices: This will remove the vertices which are not connected to any face. Select Vertices At The Edges: Selects the vertices connected to only 2 edges, hence, not being a part of a continuous face component. Select Vertices Without Edges: This will just select the faces which are not connected to any edge or face. Mark Elevation Problem Faces: Faces having distance greater than 1.2 meters to the bottom (a mesh or the terrain) will be selected for debug purposes.  Auto Generation Parameters These parameters arrange the precision, extend and operation details of the navigation mesh generation. Explanation of the parameters are as following:\n Build Detailed Nav Mesh: Checking this box makes use of the following parameters and builds a detailed nav mesh according to them. If not checked, the following parameters won\u0026rsquo;t make any difference. Cell Size: Defines the horizontal edge length of the sample voxel examined by the Recast Library. Cell Height: Defines the vertical edge length of the sample voxel examined by the Recast Library. Agent Max Slope: Maximum angle in which the agent can climb (in degrees). Agent Height: The name defines itself. Agent Max Climb: Maximum meters the agent can step on. Agent Radius: The name defines itself. Edge Max Length: Maximum possible edge length of the polygons generated by Recast. Edge Max Error: The maximum distance a simplfied contour\u0026rsquo;s border edges should deviate the original raw contour. (Definition from the Recast document) Region Min Size: The minimum number of cells [voxels] allowed to form isolated island areas. (Definition from the Recast document) Region Merge Size: Any regions with a span count smaller than this value will, if possible, be merged with larger regions. (Definition from the Recast document) Detail Sample Distance: Sets the sampling distance to use when generating the detail mesh. (For height detail only.) (Definition from the Recast document) Detail Sample Max Error: The maximum distance the detail mesh surface should deviate from heightfield data. (For height detail only.) (Definition from the Recast document)  Auto Generation Steps  First, fill in the blank fields in the parameters tab. You may prefer to stick to the default parameters as well. Click on the \u0026ldquo;Auto Generate\u0026rdquo; button (generation tools) and wait for the operation to end. Click on the \u0026ldquo;Make Quads When Possible\u0026rdquo; button (generation tools) to quadify the triangles which form a convex shape. Click on the \u0026ldquo;Find Tight Faces\u0026rdquo; button (debugging tools) to find and select the tight faces on the borders. Press the \u0026ldquo;Delete\u0026rdquo; button on the keyboard to delete these selected faces. If there are still tight faces appearing on the borders, apply the same procedure until it all ends. Click on the \u0026ldquo;Remove Unused Vertices\u0026rdquo; button (debugging tools) to remove vertices which are no longer connected to any face. Manually correct the regions which are broken due to the removed tight faces. You can debug and polish further using the tools mentioned before.  "
},
{
	"uri": "http://localhost:4444/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/editor/scene-editor/alignment_and_snapping/",
	"title": "Alignment and Snapping Tools",
	"tags": [],
	"description": "",
	"content": "Pivot Alignment Tool The Pivot alignment toolapplies the chosen transform values of one entity to another entity. The tool makes it easier for users to create overlapping or precisely aligned entities. If an entitity is selected in the editor, the user can set up the alignment tool by pressing Alt + A.This will register the currently selected entity as the input entity. Selecting a second entity with the left mouse button, will then open the interface screen of the alignment tool.\n Translation checkboxeswill translate first entity on the given axis/axes. Rotation checkboxeswill rotate the first entity without breaking the local scale. Up, side and forward vectors will be aligned depending on the checkboxes. If the scale checkboxesare checked, first entity’s scale component of the selected axis or axes will be set as second entity’s scale value which is shown at the inspector. If checkboxes are unchecked, first entity will be transformed to its initial frame. Align by Pivotbutton will apply the alignment depending on the active checkboxes and close the interface. Revert and Closebutton will transform the entity to its initial frame and revert any transform operation applied to pivot.  Example Usage Surface Snapping Feature The Surface Snapping Featureallows a user to snap an entity\u0026rsquo;s pivot to the surface of another entity. Holding down the I hot-keycontinuously snaps the pivot of the currently selected entity to a surface that the mouse cursor intersects with. Control + Zreverts the transformation. This feature aligns the entity’s local y vector with the intersection point’s normal map, so it won’t require the user to make additional adjustments to align the entity with the surface.\nBeware that this will lead to clipping, if the pivot of the entity that you seek to snap to a surface is not located on its own surface.\nExample Usage Vertex Snapping Feature The Vertex snapping featureallows users to choose any vertex from a selected entity and place that vertex in the same position as any vertex from another entity of their choosing.\nAlt + Vactivates and deactivates the vertex snapping feature. It only becomes active if an entity has been selected in the editor. There is a button on the editor toolbar as well, which acts like the hot-key.\nAfter activating the tool and while the left mouse button is in a “down” state, the chosen entity’s selected vertex will continuously snap to the vertex of another, highlighted entity that is closest to the mouse ray’s intersection point. If the distance between the intersection point and the closest vertex is bigger than 2.0f or there is no second entity highlighted, nothing will happen.\nAlso, a yellow sphere will be rendered on the vertex to provide head-up display. Thus, user can choose any vertex by moving the mouse. This will be the first vertex. Also, sphere is scaled with respect to camera position’s distance.\nAfter deciding on the first vertex, the snap operation can be done by holding down the left mouse buttonand moving the mouse.\nExample Usage If user releases the left mouse button when the line’s color is green, the snap will be successful. If user releases the left mouse button when the line’s color is yellow, there won’t be any snap and entity will be translated to its initial frame.\nAxis Constraints When snap tool is active, you will see a gizmo on top of the nearest vertex. You can use axes of this gizmo to constraint axial movement or drag from middle to snap freely.\n"
},
{
	"uri": "http://localhost:4444/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/editor/resource-editors/cloth_simulation/",
	"title": "Cloth Simulation",
	"tags": [],
	"description": "",
	"content": "Preparing Mesh Cloth simulation system uses alpha channels of vertices of meshes. Values in the alpha channel represents how much a vertex can move away from its original position. 0.1 of alpha means vertex can be moved 0.1 units from its original position by cloth simulation. If you set zero to alpha value that means that vertex will be fixed to its position and will not be updated by simulation.\n   Shaded Vertex Alpha          Black parts are driven by skinning system while white parts are simulated. It is worth to mention that skinning calculations are done for all vertices whether they are fixed or not. Positions of skinned vertices are used as anchor points for simulated vertices. You can imagine that a simulated vertex can only move inside a sphere with radius R and center C. Here alpha channel of the vertex color is used as radius and skinned position is used as center.\n   Shaded Vertex Alpha          Simulation Types Direct simulation In direct simulation, vertices of rendered mesh are simulated directly by cloth simulation. This technique can be used for meshes with simple topology(like grid) and small amount of vertices. As the number of vertices increases performance hit of simulation will be greater.\nMapped simulation In some cases, your mesh may not be suitable for cloth simulation. Some examples are armors with double sided polygons, clothes with more than one layer or meshes with high numbers of polygons. For such cases a separate mesh can be used for simulation. If a separate simulation mesh is used vertices of this mesh are simulated by cloth simulation. Vertices of original mesh will be mapped to simulated mesh and move with them.\nIn the above images, meshes on the right side are used for simulation and the left ones are rendered according to simulated results. To achieve realistic results, your simulation mesh should tightly map to render mesh and it must never cover it. In other words, render mesh should never penetrate to simulation mesh. If it does, since collision calculations are done for simulation mesh you may see collision artifacts like penetrating leg to armor.\nCloth Editor To enable cloth simulation for a mesh some ingame settings must be adjusted. Cloth editor is used to setup a mesh for simulation. Cloth editor can be opened from toolbar menu in editor.\nPreview properties Preview mesh To start working with a mesh you should select it from Preview mesh menu and select the sub meshes which will be simulated from Render mesh cloth properties panel. If alpha channels of mesh painted properly it should start to be simulated on the preview window.\nSimulation mesh If you want to use a separate simulation mesh, select it from Simulation mesh menu. Alpha channel of this mesh must also be painted because it is the actual mesh being simulated. In this case alpha channel of preview mesh is used to determine if a vertex will be mapped to the simulation mesh or it will be rendered with original skinning data. Alpha values greater than zero means that vertex must be mapped to simulation mesh. Vertices with zero alpha values will use the original skinning data. Since simulation mesh has less polygon count than the original mesh, this can be used to increase skinning quality of original mesh for non-simulated parts.\nHelper mesh You can select a helper mesh to preview your actual simulation mesh with an arbitrary mesh. Selecting a horse mesh for a simulated mane mesh is a good example.\nPreview skeleton If you want to work on a skinned mesh and preview collision capsules and animations, you should select corresponding skeleton.\nPreview body You can assign an existing collision body to your Preview mesh with Preview body menu. Modification of collision bodies can be done from Cloth Bodies panel.\nPreview animation name You can test your cloth with an animation. You must write its name in asset folder, not the one in animations*.xml and its start and end frame numbers and duration. You can start and stop animation with Toggle Animation button.\nScene update coef Slow motion can be simulated by decreasing this value. Default value is 1 which means all simulations are done normally.\nRender mesh cloth properties You can select which submeshes will be simulated by checking checkbox next to each submesh. Different cloth materials can be assigned to each submesh by Cloth material column. Max distance multiplier is used to scale vertex color paintings of mesh which controls how much a vertex can move away from its original position. 0.5 value of vertex alpha with 3.0 max distance multiplier value means that, that vertex can move 1.5 units away from its original position. \\\nIf you are using a separate simulation mesh, max distance value and cloth material of simulation mesh overrides these settings. All submeshes will use same cloth material assigned to simulation mesh.\nSimulation mesh cloth properties If you use a separate simulation mesh, you can adjust its settings from here just like render mesh properties mentioned above. Cloth material and max distance value selected here will be used for all sub meshes of render mesh.\nCollision Bodies Collision presets can be created and modified from Collision bodieswindow. You can open Collision bodieswindow from Edit \u0026gt; Edit collision bodiesmenu. A capsule consists of two end points. These points can be skinned to a skeleton separately by assigning owner bones and weights. One capsule point can be skinned to at most two bones. Like mesh skinning, weights are used to determine influence of that bone on the selected capsule.\nCloth materials All simulation parameters to customize cloth behaviour is supplied with cloth materials. Cloth material presets can be created and modified from Material templateswindow. You can open this window from Edit \u0026gt; Edit merial templatesmenu. Materials shown in this windows are presets so changing these presets does not affect configurations of existing cloth meshes. To change parameters of an existing cloth mesh, you can click Change parametersbutton in Simulation/Render mesh properties panel and adjust each settings in Mesh specific parameterswindow. Current parameters are as follows:\nBending, Stretching, Shearing, Stiffness Determines how much a fabric constraint will resist to the corresponding case.\nAnchor Stiffness This constraint strictly limits the freedom of a vertex. It tries to keep distances constant between simulated and fixed vertices. You can try to increase this value if your mesh stretches too much.\nDamping Dampening values for vertices. Determines the fraction of current frame\u0026rsquo;s velocity to transfer to the next frame.\nLinear Inertia Since our cloth simulation is done in local space, global frame changes are transferred to cloth virtually. This value determines how much of acceleration of entity will be transferred to cloth. You can test this by adding a cloth mesh into a scene and shake its entity randomly.\nAir drag For a cloth mesh moving with a constant velocity this value determines how much air force will affect its vertices.\nWind You can control how much wind force the cloth will use. This value is a multiplier for actual wind force of scene. If there is no wind in the scene increasing this value has no effect.\nGravity Constant gravity force affecting each simulated vertex. You can decrease this value to achieve a silky cloth behaviour.\nIteration Frequency How many times a cloth mesh will be simulated in a second. You can leave this parameter with its default value unless your mesh has big triangles or it moves so fast that collision capsules can not catch simulated vertices. Increasing this value results in more stable collision behaviour but performance hit also increases linearly.\nPrecise Simulation We trade accuracy with performance by doing some compressions during simulation. As a result simulated mesh might move to a different state than its rest state slightly. If this accuracy is important for your mesh, you can enable this option to get more correct results.\nDummy Collision Particles If simulated mesh has big triangle sizes with respect to collision capsules, capsules may not collide with cloth mesh properly. To overcome this we place dummy vertices in every triangle of mesh. These vertices are not simulated but only used during collision stage. This option has big performance hit so you should avoid enabling this as much as possible.\nCloth Content Files Our simulation system generates two files with *.tccand *.tcmextensions. Tcc files contains preprocessed data used by cloth simulation like constraint indices, constraint lengths etc. Tcm files contains mapping data of a render mesh to a simulation mesh. You must commit both these files to Plastic SCM to ensure that nobody will wait for cooking process to complete during scene loading stage.\n"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/script-components/bannerlord_destructible_component/",
	"title": "Destructible Component",
	"tags": [],
	"description": "",
	"content": "The destruction system which gives artists a lot more freedom is explained below.\nCharacteristics It is a ScriptComponent which can be applied to any entity in a scene, as long as that entity has a collision body.\nWhen not given any information, the script will just make the entity disappear after being destroyed. It will also re-appear when the mission resets.\nThe script can be used to destroy entities in one or more states, with optional sound, particles and dynamic objects spawning in each state.\nAny existing prefab that has a DestructibleComponent script (Siege towers, gates, ballistas, ..) will continue to work even when you remove that script. It will only no longer be destructible.\nOne entity can have multiple DestructibleComponent scripts. E.g. the battering ram is destructible, but it also has individual rooftiles which can be destroyed too. Any damage that is applied to a child will also be applied to the parent(s).\nDestroyed prefabs can always be tweaked and improved later without breaking any scenes, because they are not part of the intact entity (They are spawned at runtime).\n   Example Script of Siege Tower        DestructionStates, can be one or more prefabs. Seperated by \u0026ldquo;,\u0026rdquo; (comma).   DestroyedByStoneOnly, True means that only projectiles from mangonels or trebuchets can damage this entity. False means anything can damage this entity.   CanBeDestroyedInititally, defines if this entity can be destroyed already when loading the scene. This is controlled from the campaign map based on a destruction percentage from bombardements. This is generally only true on wall merlons. But it can also be used on aesthetic entities to make the scene look more destroyed from the start. Entities to be destroyed are selected randomly.   MaxHitPoint are the starting hitpoints from this entity. Every time the mission resets, the entity will also have its current hitpoints set back to the MaxHitPoints.   ReferenceEntityTag is an optional tag for when a DestructionState prefab has a different frame than its parent or to copy animation states. You can add an extra entity (under the entity with the DestructibleComponent script) with a correct frame and supply it with a reference tag, so that the spawned DestructionState prefab will use that frame. If there is no ReferenceEntity, the frame of the entity with the DestructibleComponent script will be used. Reference entity can also be used in special scenarios like a castlegate (opening/closing animations), to get the animation state from the reference entity and apply it to the newly spawned damaged entity.   OriginalStateTag is only required when you have multiple DestructionStates. Usually, when an entity is destroyed, we hide the entity which has the script component applied, and spawn a new entity from the DestructionState (without a parent). But for some entities (like gates), we do not want to hide the entire entity because it has to keep functioning as a gate until it is fully destroyed. Using the OriginalStateTag, we will only hide the entity which has this tag applied, and the rest of the hierarchy (particles, standing points, ..) will still be visible. Any DestructibleComponent that has more than one destructionState will spawn the damaged prefabs as child entities.   HeavyHitParticlesTag is a tag which can be applied to any child-entities that have a particle-system. These particles will burst once, when a certain amount of damage is taken in a single blow. This particle system is generally shared between all destruction states (It\u0026rsquo;s not part of the entities that get hidden/spawned).   HeavyHitParticlesThreshold is the minimum damage that is required to be taken in a single blow, to trigger particles with HeavyHitParticlesTag tag.    Effects Generally, we try to keep the spawned prefabs as small as possible for performance reasons, and also to avoid entity duplication. You have access to the following functionality to add effects:\n On the damaged prefab, when spawned: All particle systems on every entity in the hierarchy, will automatically be bursted once. On the damaged prefab, when spawned: All dynamic bodies on every entity in the hierarchy, will automatically receive the impulse from the last hit that destroyed the previous state. On the damaged prefab, when spawned: All other meshes on every entity in the hierarchy, will remain in place if they have no dynamic body-flag. Part of the entity hierarchy: Heavy hit particles have to be shared between all destruction states, and are played whenever the DestructibleComponent takes HeavyHitParticlesThreshold damage. You can play custom animations on DestructibleComponents that have a skeleton (e.g. castlegate being hit by battering ram). The animation progress will transfer to the newly spawned damaged entities. You can add a script of type AmbientSoundEmitter on a damaged prefab and provide the sound event. It will automatically play when the entity is spawned. Apart from using multiple states, you can also add multiple child entities with DestructibleComponents (e.g. battering ram rooftiles which are individually destructible). Keep in mind that any damage that is applied to a child DestructibleComponent is also applied to every parent in the hierarchy. Currently, we don\u0026rsquo;t know the performance implications of having too many of these.  Examples Example 1: Wall with breakable merlons For walls, we can only destroy the merlons and nothing else. They can only be damaged by mangonels/trebuchets and they will only take one hit before being destroyed.\n   Hierarchy of WallSegment     This is what our scene hierarchy looks like for a single wall piece. European_castle_wall_a_l3 is an entity with script WallSegment. It does not care if it has destructible children or not. Every merlon is a different child-entity that has its own DestructibleComponent script. Once they are destroyed, they all spawn the same destroyed prefab. Every merlon has a debris_holder entity, which is an empty entity. It just hold a ReferenceEntityTag tag, and the correct frame to spawn the destroyed prefab from (Important because of mesh bending: Location and rotation may change compared to the parent).       Script example of a single merlon     Every merlon has the exact same script. They will all spawn the \u0026ldquo;debris\u0026rdquo; prefab when destroyed. We decided to make them destroy after a single hit from a mangonel, so they have very low hitpoints. DestroyedByStoneOnly makes them ignore damage from all other weapons (arrows, swords, axes, ..). Because of CanBeDestroyedInititally, these merlons have a chance to already be broken when entering the mission. The merlons need a ReferenceEntity entity to determine the spawn frame for the broken prefabs.    Origin of wall and merlon pieces\n          Each merlon is a unique mesh, which has its origin point at the bottom of the wall (same as the wall).    Every merlon shares the same destroyed prefab, which has a local origin. debris_holder has a ReferenceEntityTag.    Every child of the debris prefab is an entity with flag \u0026ldquo;dynamic\u0026rdquo; and has a collision body. When spawned, it will automatically receive the last impulse that the DestructibleComponent received when destroyed.    Example 2: Siege Barricade Siege barricades are very simple objects. They are static entities and their only function is to block incoming projectiles. However, they can be destroyed in multiple stages. Each stage looking more destroyed than the one before.\n   The different destruction states of a siege barricade     Currently, the different states do not have any special particles or dynamic entities, but they can easily be added later on. Entities with the \u0026ldquo;dynamic\u0026rdquo; body flag, and particle systems will automatically trigger when spawned.       Hierarchy of siege barricade in scene Siege Barricade script component          siege_barricade_a is an empty parent. It just holds the script. siege_barricade_a_state1 is the actual mesh + body and has the \u0026ldquo;original_state\u0026rdquo; tag. When the barricade takes enough damage, siege_barricade_a_state1 will be made invisible, the next damaged prefab will be spawned and added to siege_barricade_a as a child. This is important because the DestructibleComponent needs to be informed of hits, and it can only do that if it has a (visible) collision body on itself or on a child.\nthe last state (state_5 in this case) will be spawned when the entity has 0 health (fully destroyed). The other ones will be used in between MaxHitPoints and 0.\nWhen the mission is reset (Health is reset to MaxHitPoint), the original entity (entity with tag \u0026ldquo;original_state\u0026rdquo;) will be made visible again.\nEvery DestructionState prefab has the same origin and rotation, so we don\u0026rsquo;t have to use a ReferenceEntity.\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/distance_tool/",
	"title": "Distance Tool",
	"tags": [],
	"description": "",
	"content": "Distance Measure Tool The Distance Toolmeasures the distance between two points in the scene. Distance measure mode can be activated by either pressing Alt + Dshortcut or the respective button on the editor toolbar.\nWhile holding the left mouse button, drag the mouse between two points in the scene to measure distance. The tool snaps to vertices if close enough to a one by default, holding down Left Shiftoverrides this.\nThe tool can be de-activated by pressing Alt + Dor the respective button on the editor toolbar again. For further use, the gizmos stay visible even after the tool is de-activated. Pressing Alt + Shift + Dclears these gizmos from the screen.\n Green lineshows the actual distance between points. Blue linesshow the lateral and longtidunal distances. Yellow circledepicts the range.  "
},
{
	"uri": "http://localhost:4444/asset-management/asset-browser/filterqueries/",
	"title": "Filter Queries",
	"tags": [],
	"description": "",
	"content": " You can use sql syntax to search for assets with specific properties like textures whose resolutions are greater than 1024. To do this you need to enable query mode from extras menu : From the Texture Inspector (Right Panel), you can enable/disable MipMap blending by toggling Use Mipmap Blendingcheckbox. When you enable MipMap Blending, you will see all mip levels of the selected texture next to each other in Preview Window. Clicking on MipMap Blend Amountswill open a new window where you can adjust blend amounts for every mip level. Then you can select MipMap Blend Color (1)and click Recompile (2)button to apply blending. The result will be immediately visible in Preview Window and also in Game. "
},
{
	"uri": "http://localhost:4444/editor/scene-editor/mass_selection/",
	"title": "Mass Selection",
	"tags": [],
	"description": "",
	"content": "Mass Selection script allows you to select objects in a box and apply random rotations to selected objects. You can relocate and resize the selection box with translating, rotating and scaling entity which has \u0026ldquo;mass_selection\u0026rdquo; script. Bounding Box Constraint property allows you to select objects which has smaller bounding box than it\u0026rsquo;s value.\n   Locate Selection Box After Select Objects After Apply Random Rotations           "
},
{
	"uri": "http://localhost:4444/editor/resource-editors/meta_mesh_editor/",
	"title": "Meta Mesh Editor",
	"tags": [],
	"description": "",
	"content": "Import Settings  Divide Into Grid: Divides the meta mesh into grids, and adds all the generated section meshes to the submeshes. Remove Redundant Vertices: The name implies what it does. Recompute Normals: While importing the meta mesh, computes normal vectors for all sub-meshes instead of importing them as well. Normal Computation: Decides whether the normal vector computation will depend on the face area (weighted) or not (default). Recompute Tangents: While importing the meta mesh, computes the tangent vectors for all sub-meshes instead of importing them as well. Whiten: Linear interpolation amount between the vertex color and white per each color channel.  Lod Meshes  All the active sub-meshes of the meta mesh can be seen here. The material properties, mesh parameters and tags can be changed via the interface.  Unused Meshes  This shows the activity situation of the sub-meshes. If the ignore checkbox is checked, this means that the corresponding sub-mesh is inactive. After changing status of the lod meshes, please press \u0026ldquo;Apply Ignores\u0026rdquo; button for your changes to take place and be saved.  Save  Saves all the changes done to the meta mesh.  "
},
{
	"uri": "http://localhost:4444/editor/resource-editors/model_viewer/",
	"title": "Model Viewer",
	"tags": [],
	"description": "",
	"content": " The Model Viewer can be accesed from; Editor \u0026gt;Window \u0026gt;Show Model Viewer From the left panel, you can change Atmosphere, hide/show ground, or add as many entities as you want. The entities can either be Humanor simple Mesh.Pressing Add Entitywill open a modal window for you to select the entity type. Transform From this panel, you can set entities Tranform, Rotation, and Scale.\nAnimation From this panel, you can choose Skeleton type, and Animation. \\\nYou can also filter animations by their name. \\\nFiltering system is quite strong through all the engine, so you can fine tune your filtering. Some examples; \\\nidle = Will filter animations that contains \u0026ldquo;idle\u0026rdquo; \\\n.idle = Will filter animations that starts with \u0026ldquo;idle\u0026rdquo; \\\nidle. = Will filter animations that ends with \u0026ldquo;idle\u0026rdquo; \\\n-idle = Will filter animations that does not contain \u0026ldquo;idle\u0026rdquo; \\\n\u0026mdash; You can also use combinations of those filters by putting a space between them \\\n\u0026ldquo;idle -barmaid 2.\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, and does not contains \u0026ldquo;barmaid\u0026rdquo;, and ends with \u0026ldquo;2\u0026rdquo;. (like \u0026ldquo;guard_idle_2\u0026rdquo; which fits this condition) \\\n\u0026ldquo;idle hangout 7\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, \u0026ldquo;hangout\u0026rdquo;, and \u0026ldquo;7\u0026rdquo;. (like \u0026ldquo;anim_hangout_idle_7\u0026rdquo; which fits this condition)\n\u0026mdash; You can also blend an another animation using the blend panel.\nVisuals From this panel, you can put any mesh at any part of the human, and you can choose this humans gender.\nSave / Load scene You can also Save / Load the current working scene, by clicking; File \u0026gt;Save Scene \u0026gt;..Save Name.. \\\nThen you can load it with; File \u0026gt;Load Saved Scene \u0026gt;..Write Saved Name.. \\\nWhich will restore everyting to the state where you saved it.\n"
},
{
	"uri": "http://localhost:4444/editor/scene-editor/prt/",
	"title": "Precomputed Radiance Transfer - GI System",
	"tags": [],
	"description": "",
	"content": "We introduce a new global illumination system to the engine. It is based on a pre-baked system called \u0026ldquo;Precomputed Radiance Transfer\u0026rdquo;. This technique allow us to bake the local ambient in the scene and display it in an optimized manner at runtime. Baked data is independent from the atmospheres. Thus, we can light the scene with the same bake data for every atmosphere.\n   With Without          Baking Procedure Scene baking is divided into a couple of parts:\n First, the artist should place the border probes to identify the GI boundaries of the scene.  Side Note 1: If you minimize the GI boundaries as much as possible(not extending it to distant places from navigatable area) , you can decrease the grid dimensions and thus you will have more precision inside the town where it matters the most. For town scenes, we generally use grid dimensions of 1.5 meters width and 2.5 meters height.\nSide Note 2: For the pixels outside the GI borders, we use a fallback probe from the scene. The default is the highest active probe near to the left corner of the GI order. Artist can select any other probe from the scene by first selecting probe and checking the \u0026ldquo;Fallback Probe\u0026rdquo; checkbox in the UI.\n AT the next pass, the GI probes are created. The initial positions of the probes computed automatically by using the navigation mesh of the scene. With the navigation mesh, we place the probes where the agents can move and also to everywhere visible from those navigation points. The probes are generated within a 3d grid structure. A directional ambient data is computed for every probe position. Using these ambient light values, every pixel in the screen is illuminated by the nearest 8 probes. In some cases, when the lighting between neighbour probes have a very high difference, light or shadow leaking can occur. In order to fix these issues, we render shadowmaps from the probes just like point lights. Probes with shadowmaps are named as \u0026ldquo;Visibility Probes\u0026rdquo;. For memory usage issues, there is a limit for these Visibility Probes, which is 2048. At the automatic placement phase, the system also tries to find the most probable leak positions and assign those probes as Visibility Probes. It takes into account the ambient light difference. For additional leak fixes, the system leaves the last 5 percent Visibility Probe limit empty, so that the scene designer can fix the remaining leak issues.  PRT Files Just like the scene edit data system, prt data is divided into two parts. prt_data.bin is located inside the SceneObj folder and is the compressed version which is stripped of any editing data. This file should be sent to the source control. The other file is the edit data file. It is very big (at around 2 - 3 gb) and automaticaly sent to the edit data folder inside the network. Once you open a pre-baked scene in editor, only the compressed data is loaded. To be able to edit the bake data, you should Load the edit data with the \u0026lsquo;Load\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nImportant Node : After any changes to the prt data, do not forget to save the data with the \u0026lsquo;Save\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nPRT Operations  Load : Loads the edit data from the server. Save : Saves the current edit data to the server. Auto Height Boundary : Adjusts the PRT boundary probes\u0026rsquo;s height to the min/max of the scene. Bake Single Level : Bakes the scene with the current levels, should be used for the interior scenes Bake All Levels : Bakes the scene with the pre-defined multiple levels(namely level-1/level-2/level-3 and siege/civilian) combinations.  Probe Placement Parameters:  Grid Width : Determines the probe grid cell size in XY plane. For towns, you can use 1.5. For interiors scenes, you can use between 0.5 to 1.0. Grid Height : Determines the probe grid cell height. For towns, you should use a value near 2.5. For interiors scenes, you can use between 0.5 to 1.0.  Selection Tools: To ensure fast and smooth editing of probes, various selection tools are implemented.\n Select All : Selects all probes. Grow : Grows the selection to include neighbour probes in XY plane. Shrink : Shrink the selection to only include the inner neighbour probes in XY plane. Fill : Finds the inner probes of the current selected probe group and selectes them. Select Border : Finds and selects the border probes of the current selection. Select Inner Border : Finds and selects the inner border of the current selection. Select Outer Border : Finds and selects the outer border of the current selection. Lasso Tool : We implemented a screen space lasso tool for easy selection of a group of probes. It can be started by pressing \u0026lsquo;r\u0026rsquo; and finished by either double clik or pressing \u0026lsquo;r\u0026rsquo; again.  Visibility Tools  Show Active Probes : Shows all active probes Show Deactive Probes : Show deactived probes. Show Visibility Probes : Show the Visibility probes (the ones with the visibility calculation to prevent leaking). Level To Show : Selects the Z level to show. -1 means all levels. Show Probe Radius : Determines the probe radius for debug visualization. Box Tool : Enables a mode where you .  Side Not : This system only renders the nearest 100 probes with respect to the camera.\nUseful Shortcuts  Left Ctrl + x: Enable/Disable the selected probes Left Ctrl + c: Toggles the \u0026ldquo;Visibility Probe\u0026rdquo; status Left Alt + Left Mouse Click: Select the probes that influences a pixel (very neat tool for fixing the leak issue, select the pixel and use the toggle visibility status shortcut to fix the issue)  "
},
{
	"uri": "http://localhost:4444/editor/scene-editor/terrain_resize/",
	"title": "Resizing Terrain",
	"tags": [],
	"description": "",
	"content": "Resizing Terrain If required, terrain node count can be resized at Resize Terrainpanel in Terrain Inspector.\n There are 4 direction that you can add new nodes, or remove existing nodes. +X, +Y, -X, -Y (South, East, North, West, respectively) (Coloring is consistent with Gizmo). \\ Adding or removing nodes will automatically relocate existing entities and floras to their new locations. New nodes will have their height data unspecified, and may look unconnected to the rest of the terrain. Artist can (and should) easily fix this using in-editor height brushes, or can export the height map and modify using an external height map generation tool and then import back to the editor.\\ Using positive values to a side will append that much new nodes to that side. If you write +2 to each side, terrain will expand by 2 nodes on each side. If you write 3 only to +X, and 0 (zero) to rest, terrain will expand by 3 nodes only on +X direction.\\ If you write a negative value to a side, it will remove that much nodes from that side. \\ If you write 0 (zero) to a side, there will be no modifications on that side. (default value)     Adding Deleting          "
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/script-components/scene_barrier_builder/",
	"title": "Scene Barrier Builder",
	"tags": [],
	"description": "",
	"content": "Introduction Barrier Builder is a tool that helps artist to generate barriers over walls to prevent agents to fall down.\nUsage   Create a path, you can use the button on toolbar   Give a name to path   Build your path as you wish   Press \u0026ldquo;Enable Barrier Build\u0026rdquo; chekbox on path inspector, it will create your barrier entity for you.   You can go to that entity with \u0026ldquo;Go to Entity\u0026rdquo; Button and chnage its options like height, the entity named as \u0026ldquo;path_barrier_PATHNAME\u0026rdquo;\n  "
},
{
	"uri": "http://localhost:4444/editor/scene-editor/level_system/",
	"title": "Scene Level System",
	"tags": [],
	"description": "",
	"content": "Level System New level system replaces the old, hardcoded system with a much more extandable and unified system. \\\nAddinga new level (or deletingan existing one) to a scene can be done in Levelspanel under SceneOptionsinspector.\nLevels in Game - Bannerlord - Currently, Bannerlord recognizes a few levels that has a meaning in-game. \\\nWhich are: \\\n level_1 \\ level_2 \\ level_3 \\ siege \\ civilian  Setting Entity visibilities Making an entity only visible in a certain level combinations can be done with selecting an entity then going in Scene Level Visibilitiespanel under Entity Inspector. Select the levels you want this entity to be visible. Entity levels in missions are checked as a whole.Example If you select both level_1 and siege, and if you open a mission that has level_2 and siege, this entity will NOT be visible since it does not has \u0026ldquo;level_2\u0026rdquo;. \\\nIf you select both level_1 and siege, and if you open a mission that has level_1 and civilian, this entity will NOT be visible since it does not has \u0026ldquo;siege\u0026rdquo;. \\\nIt will only and only be visible if you open a mission that has level_1 and siege.\nSo if you want an entity to be visible in both level_1 and level_2 and only in civilian mission, select level_1, level_2, and civilian; \\\nso this entity will not be visible in ANY siege missions, and will not be visible in ANY mission as level_3.\nTesting visibility in editor There are two options to see entities with different level visibilities.\n1) Require all levels (Same as missions) \\\n2) Require at least one level (Editor only, to see all entities at once)\nRequire all levels In this mode, visibility system will work as same as the missions, you can use this mode to test what entities will be visible in what combinations. \\\nIf you select level_1 and siege, you will only see entities that has both level_1 and siege, not the others.\nRequire at least one level This is an editor only mode, if you select a level, it will be visible, no matter what combinations that entity has; if entity has that level, it will be visible. \\\nCan be useful if you want to see all civilian entities no matter what level they are, or you can see level_1 entites no matter if they are siege or civilian.\nTesting a scene For this purpose, Start mission as window modified in a way that allows you to select level combinations. If you want to test a castle scene with level_1 and siege mode, Select these leves and press OK. The mission will start in Level 1 Siege mode.\n"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/script-components/scene_spawn_points_guide/",
	"title": "Scene Spawn Point Guide",
	"tags": [],
	"description": "",
	"content": "How to design fully featured scenes in Bannerlord Each scene has own basic necessities to run without crashing and has extras to give better experience to player. Designers can check these necessities with \u0026ldquo;Spawn Point Debug Tool\u0026rdquo; to be sure that their scene will not crash.\n1. Town Center Scene Player will be spawned on the \u0026ldquo;sp_player_outside\u0026rdquo; prefab if he/she is entering the city for the first time, because of this feature \u0026ldquo;sp_player_outside\u0026rdquo; must be placed far from city\u0026rsquo;s entrance; otherwise player will be spawned on \u0026ldquo;sp_player\u0026rdquo; and this spawnpoint can be next to the entrance gate. Town center scene has some mandatory characters as follows:\n   Player Spawn Point     When player enters the town center from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than 1 in order increase variation. The scale of the conversation prefab must not change.       Traders     Traders such as armorers, blacksmiths and horse merchants are mandatory for town center scenes. If scene has more than one market place, it is ok to have more then one trader NPCs. Traders in market places may have their own sets. These sets can be considered as prefabs with some spawn points in it. For example, for weaponsmith there can be 3 points in weaponsmith set but there must be 1 spawned weaponsmith. This NPC will go to these points randomly, in a word NPC may go to his/her selling table and start trading or go to the backside of his/her shop and sit on a chair for some time. Designer may want to change these wait times between actions with \u0026ldquo;MinWaitInSeconds\u0026rdquo; and \u0026ldquo;MaxWaitInSeconds\u0026rdquo; parameters. (-1: forever).       Notables    Notable Parent Prefab Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city. Every notable have their own spawn point tag and every notable have their unique helper characters.\n   Notable Spawn Point Tag Helper Character Tag     Preacher sp_notable_preacher sp_preacher_notary   Gang Leader sp_notable_gangleader sp_gangleader_bodyguard   Rural Notable sp_notable_rural_notable sp_rural_notable_notary   Artisan sp_notable_artisan sp_artisan_notary   Merchant sp_notable_merchant sp_merchant_notary    Notables have one parent prefab named \u0026ldquo;sp_notables_parent\u0026rdquo;. Each notable has 1 set as child so, parent prefab has 5 child notable sets.\nArtists must place this parent prefab and put it in a prominent place of town center. Also prefab must be seen easily by player. After mission start, game logic will activate the notable set according to the notables in the town center.\nIn the notable sets, every notable will have unique helper character and their spawn point as well. (bodyguards for gangleader, notary for merchant\u0026hellip;).\nIn the picture below. There were 2 parent prefabs in the scene. After mission start, one prefab is activated for gangleader and her bodyguards. Other prefab is activated for merchant and his notary.\n   Guards     There are some idle guards and patrolling guards. Patrolling guards are programmed as moving one point to another while activating the next point and deactivating the current one.       Passages     Town center scene must include all passages to other scenes such as Tavern, Arena, Lords hall\u0026hellip;       Battle Sets     For town scenes, battle sets are only used for common area clearing. so they should not be too far apart, and should be placed to represent a fight between gangs rather than a battle between armies.       Townsfolk     NPCs are always moving around the city. In order to prettify the scene, designer may want to use some extra prefabs. If scene has \u0026ldquo;sp_npc_repair_set\u0026rdquo;, one NPC will go to that point and start hammering away while other NPC complains about the situation or scene may have some beggars begging for townsfolk help.    2. Tavern Scene    Player Spawn Point     Spawnpoint for player, \u0026ldquo;sp_player\u0026rdquo;, must be placed nearby to the town center passage. Scene must include at least one \u0026ldquo;sp_player_conversation\u0026rdquo; prefab or more. The scale of the conversation prefab must not change.       Game Hosts (Gambler NPCs)     Each tavern scene must have gambler (game host) NPC. The chair underneath NPC must have \u0026ldquo;gambler_npc\u0026rdquo; and \u0026ldquo;npc_wait\u0026rdquo; tags both. The chair which player will use to join game must have \u0026ldquo;gambler_player\u0026rdquo; and \u0026ldquo;reserved\u0026rdquo; tags both.    3. Lords Hall Scene    Player Spawn Point     Player spawn points for Lords Hall scene is as same as Tavern scene. Spawn point for player must be placed nearby to the town center passage.    4. Village Scene    Player Spawn Point     Village scene don\u0026rsquo;t have \u0026ldquo;sp_player_outside\u0026rdquo; prefab. \u0026ldquo;sp_player\u0026rdquo; prefab must not be placed far from village center nor very near. When spawned, player must see the walking villagers from afar. When player enters the village from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than one in order to increase variation. The scale of the conversation prefab must not change.       Notables     Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city.       Villagers     Villagers have lots of extra activities in village center such as collecting grapes, repairing something or grooming horse. The activities must be balanced between physical and social activities. Villager NPC may go and clean walls then sit and chat with others.       Common areas     Each village has 3 common areas which are not in the village center. Any type of spawn points can be used inside of the common area. \u0026ldquo;common_area_NUMBER\u0026rdquo; prefabs should be placed to specify the area. This prefabs has a script attached named \u0026ldquo;CommonAreaScript\u0026rdquo;. The script has some parameters as follows:   AreaRadius : Artist can change this parameter script to extend or reduce the area.   AreaIndex : Already set in prefabs for three common areas   Type : Type of the area should be set from the list below       Area Types Scene Explanation     Backstreet Town Center Back alley where thugs are spawned   Clearing Town Center Open area   Waterfront Town Center Near coast or port   Pasture Village Pasture, forage (usually a heath or moor)   Thicket Village Shrubbery   Bog Village Swampy area   Forest Village Lots of trees   Ravine Village Valley or canyon   Spring Village Puddle in desert   Cove Village Bay   Marsh Village Swampy area near river   Wadi Village Valley, does not have rocks on both sides       Battle Spawnpoints     If game is opening the scene with battle mode. Battle sets will be initiated and battle troops will be spawned on each. Battle sets must be placed far from each other, and with defender and attacker sides in mind.    "
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/script-components/callbacks/",
	"title": "Script Component Callbacks",
	"tags": [],
	"description": "",
	"content": "The callbacks of the script components are listed below.\nConstructor In constructor one needs to assign default values to its public variables(variables which can be changed by the scene maker). In constructor script component is not assigned to an entity or scene. Also, you should not write any logic that has any side effect because , even though it is created, the script component may be deleted once the scene is opened because of the upgrade level system.\nOn Pre Init This is called after the script component is assigned to its owner entity in the scene. Once you are in this callback , you can be sure that the user defined variables from that script instance are set. However, the other script components of the other entities may not be assigned yet. Thus, in pre init there should not be any logic code that relies on other script components. Example, in pre-init ManagedObject registers himself to the managed object array in the current mission instance.\nOn Init This is called once the mission is loaded and all of the script components of the entities are initialized. You can use any type of logic code inside this callback. Run time instantiated scripts also get this callback called.\nOn Editor Init Editor version of on init. It is called when the scene is loaded from the editor. Beware that there is no mission or game state in editor.\nOn Tick This is called for every script component every frame on mission from the same thread.\nOn Editor Tick Editor version of on tick.\nIs Only Visual If you have a script component which is only visual and does not have any logic code that should be running in the dedicated server , you should return true in this function. This ensures that this type of scripts does not run on dedicated server.\nOn Editor Variable Changed This is called in editor whenever a public variable in that script component is changed by the user. This callback can be used for any visual-logic state change if the artist needs instant feedback on the editor scene.\nOnRemoved Called when the entity or the script component is being removed. If you have any allocated objects which are stored in somewhere else (for example static containers), you can use this callback to ensure that they are not leaked.\n"
},
{
	"uri": "http://localhost:4444/authoring-mission-scenes/script-components/spawn_point_debug_tool/",
	"title": "Spawn Point Debug Tool",
	"tags": [],
	"description": "",
	"content": "Introduction The tool which has prefab named \u0026ldquo;SpawnPointDebugView\u0026rdquo; can be added to scene. Prefab has \u0026ldquo;SpawnPointDebugView\u0026rdquo; script attached and tool can be opened through inspector toggle. Tool has 3 tabs named \u0026ldquo;Scene basic information tab\u0026rdquo;, \u0026ldquo;Scene entity check tab\u0026rdquo; and \u0026ldquo;Navigation mesh check tab\u0026rdquo;.\n1. Scene Basic Information Tab This tab tries to determine the scene type in order to find necessities; if detected type is not correct, artist can override the type using toggle buttons below.\n2. Scene Entity Check Tab This tab calculates the spawn point count and warns artist if counts are not in the scene criteria. Clicking the \u0026ldquo;Count Entities\u0026rdquo; button and toggling the categories will fill the table of calculations. \u0026ldquo;DONT USE\u0026rdquo; toggle stands for outdated entities which scene must not include. Last column of table shows how many agent will be spawned on current spawn points.\nAt the end of each row there is a button which can list all game prefabs with clicked button\u0026rsquo;s tag. Clicking the button will open a new window that list all prefabs with particular tag.\n3. Navigation Mesh Check Tab This tool will mark the spawn points which are not on the navigation mesh or on the navigation mesh that will be deactivated by \u0026lsquo;Navigation Mesh Deactivator\u0026rsquo;. If scene does not have \u0026lsquo;Navigation Mesh Deactivator\u0026rsquo;, Deactivation face id will be 0 and scene entity check tab will warn artist to place it in scene. Clicking \u0026ldquo;CHECK\u0026rdquo; button and toggling the categories will show debug lines on the invalid spawn points with category color. Navigation Mesh Check tool shows the spawn points according to scene level. Each toggle will activate 2 buttons named \u0026ldquo;Previous\u0026rdquo; and \u0026ldquo;Next\u0026rdquo;. Clicking these buttons will make editor camera to focus on the misplaced spawn points one by one.\nThis tab can also checks points that are out of mission bound but this feature is only working in missions.\n"
},
{
	"uri": "http://localhost:4444/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/editor/scene-editor/terrain_mesh_blend/",
	"title": "Terrain Mesh Blend System",
	"tags": [],
	"description": "",
	"content": "We introduce a new terrain mesh blending system. Certain terrain layers can blend into chosen meshes. Blend height, smoothness and random height offsets can be changed. These values can be saved to prefabs and can also be changed in scene per mesh. Heightmap blending can also be used to change the blending behaviour with respect to the mesh\u0026rsquo;s heightmap.\n   With Blending Without Blending          Terrain Layer Restrictions Terrain layers should satisfy some restrictions before they are eligible to be a mesh blend layer.\n Diffuse texture should have (2048 , 2048) dimensions and have a DXT1 format(without alpha). Normal texture should have (2048 , 2048) dimensions and have a BC5 format. Specular texture should have (2048 , 2048) dimensions and have a DXT1 format. Layer should not have \u0026lsquo;diffuse alpha\u0026rsquo; or \u0026lsquo;ground slope\u0026rsquo; flags enabled.  Material Properties The mesh should have a material with shader \u0026ldquo;terrain_mesh_blend_shader\u0026rdquo;. To enable heightmap blending, one should assign an heightmap texture and enable the shader flag \u0026ldquo;\u0026rdquo;.\nMesh Properties One can change the mesh\u0026rsquo;s properties from the Components/Mesh/Vector Arguments windows in Entity Inspector.\n Blend Height Threshold : Maximum distance for terrain blend Blend Smoothness : Higher means more smooth transitions Random Amount : Blend height threshold can be incresed or decreased with this value with respect to the position of pixel Random Tile : Adjusts the tile of the random heightmap adjustment Heightmap Factor : Controls the heightmap factor of the mesh. More means less blending in the higher parts of the heightmap.  "
},
{
	"uri": "http://localhost:4444/editor/resource-editors/mipmap_editor/",
	"title": "Texture Editor",
	"tags": [],
	"description": "",
	"content": " The Texture Editor can be accesed from; Editor \u0026gt;Window \u0026gt;Show Resource Browser \u0026gt;..Search for Texture.. \u0026gt;..Double Click on Texture.. From the Texture Inspector (Right Panel), you can enable/disable MipMap blending by toggling Use Mipmap Blendingcheckbox. When you enable MipMap Blending, you will see all mip levels of the selected texture next to each other in Preview Window. Clicking on MipMap Blend Amountswill open open a new window where you can adjust blend amounts for every mip level. Then you can select MipMap Blend Color (1)and click Recompile (2)button to apply blending. The result will be immediately visible in Preview Window and also in Game. "
}]