[
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/animations/",
	"title": "Animations",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/creating_entity/",
	"title": "Creating Entity",
	"tags": [],
	"description": "",
	"content": "Game Entities are basic building blocks of Scenes. Every mesh, light, decal, script behaviour are components of entities. \\\nCreating an empty entity In the editor, you can begin by creating a new, empty entity by using the Add Empty Entitybutton from tool bar, then you can attach different components for different needs.\nAll entities can be composed of multiple components.\nAdding Component Component can be added from the toolbar after selecting an entity. There are 5 different components you can add. Mesh, Decal, Light, Particle, and Script.\nA - Mesh:##### Meshes are pretty straighforward and represent every visible geometry within the scene. After clicking add mesh button, select any mesh you want from mesh selection dialog. B - Decal:#####  C - Light:##### Lights can be used to illuminate the scene. Usually attached to other entities that supposed to emit light. (Like, torches, camp fires etc.)\nEvery light is fully customizable, you can enable/disable dynamic/static shadow, change light radius / shadow casting radius, intensity, and color from properties panel of light.\nYou can also specify custom effects like flickering for more natural lights. After clicking add light button, you can change properties of the light under Components panel in Entity Inspector.\nEngine uses a technique called Tiled Deferred Rendering, so using lots of lights are pretty cheap as long as they are not overlapping too much.\nThese parameters can be tweaked to further optimize scenes.\nIn the scene visualizer, Yellow sphere represent light radius, and blue sphere represents shadow casting radius. (D) Particle System:##### Particles simulates and renders many small images or Meshes, to produce a visual effect.\nParticles are useful when you want to create dynamic objects or volumetric effects like fire, smoke, or splash effects since they are quite hard, or even in most cases, not possible to create with regular meshes.\nAfter clicking add particle button, and selecting an exsiting particle from the Particle selection dialog, you can edit this particular instance from Component panel by clicking Edit Instance, (E) Script:##### Scripts are the basic building blocks of game related behaviours that can be attached to entities.\nScripts can be written in C# and has full access to attached entity, its Scene, and therefore all other entities in that Scene.\nAfter clicking add script button, you can select the script you want from the dropdown menu, then you can change the script parameters from Scrips panel under Entity Inspector.\nEntity Hierarchies Entities can have a parent child hierarcy to organize related entities together.\nChild entities automatically get their world position relative to their parents, moving a parent entity will move all of their children. More imformation about manipulating an entity can be found HereYou can use the Entity Outliner to create hierarcies by simply dragging an entity over another entity.\nYou can also detach a child entity from its parent by right clicking and selecting Detach from parent.\n                "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/prefabs/",
	"title": "Entities &amp; Prefabs",
	"tags": [],
	"description": "",
	"content": "In RGL, entities are containers for all of the meshes, particles, script components, occluders and physics objects. They can also contain other entities as children. They have their own transformation that determines their position, scale and rotation in the world.\nPrefabs Prefabs are template entities which do not sever the connection to the prefab even after it is saved in a scene. Complex entities can be constructed one time and saved as a prefab to be used at any time, in any scene. Later updates to the prefab will affect the already done scenes as well. In Bannerlord, nearly all of the mission objects and scene props are prefabs.\nConnection Rules Once a prefab is placed into a scene, all of the values under prefab(mesh colors, child entity transforms, script values) are connected to the original prefab and will be updated after every change to the original one. Any change in the scene for those values will sever the connection. Beware that any “Addition” operation to the prefab in the scene, will break the prefab connection all together. Examples: adding a new mesh, particle system, light, child entity or script component.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/",
	"title": "Live",
	"tags": [],
	"description": "",
	"content": "欢迎来到《骑马与砍杀2：霸主》 Mod 开发文档 获取更多“常见问题解答”，请访问 常见问题解答。\n想要快速创建并且注册一个游戏 Mod 请访问 快速入门指南。\n更多信息请参阅：\n [资产管理]创建/编辑一个包含资产 (Assets)、脚本、场景以及游戏逻辑数据的模组，这些可以是新建的数据，也可以用于覆盖游戏内已经存在的数据。 [霸主任务系统]详细介绍游戏脚本组件的工作原理，何时能触发回调，以及骑砍2：霸主中用来建立游戏流程（体验）的特定脚本模板。 [编辑器]关于编辑器的信息，引导玩家如何能最有效地使用编辑器编辑场景和内容。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/material_editor/",
	"title": "Material Editor",
	"tags": [],
	"description": "",
	"content": "Overview Inspector Shader pbr_shading This shader is heavily used and exists just because our engine did not use PBR shading pipeline in the early years of development, most content was not created for PBR pipeline, so this shader is created to support our already existing content and only used during the transition phase. New content should not use this shader, instead you should use pbr_metallic.\npbr_metallic This is what you should use most of the time. This shader uses standard metallic PBR pipeline and inputs are compatible with most texture authoring softwares.Inputs:Albedo and Normal: These are pretty standard, outputs of texture authoring softwares can directly be used. Specular: This texture uses its 4 channel for different purposes. Red channel contains Metallic information, Green channel contains Glossiness (inverse of Roughness), Blue channel contains Ambient Occlusion, and Alpha channel contains Translucency (for vegetation shaders only) grass This shader is a derivative of pbr_metallic, and should only be used on grass meshes. Contains special effects like wind animation, sway animation, smooth LOD transition, color multiplication from terrain, etc.\nflora_leaf This shader is a derivative of pbr_metallic, and should only be used on leaf parts of trees / bushes. Contains special effects like wind animation, sway animation, color multiplication from terrain, smooth LOD transition, translucency (Alpha channel of Specular texture), etc.\nflora_bark This shader is a derivative of pbr_metallic, and should only be used on bark parts of trees / bushes. Contains special effects like wind animation, smooth LOD transition, etc.\nTextures Diffuse2Map This input is used internally by engine to create special effects / blendings like Shield Banner Paintings, Banner texture in this slot will only appear where Diffuse 1 Texture contains alpha. Usage of this texture really depends on the shader used.\nDetailNormalMap This input is used to create micro imperfections and additional high frequency detail on top on regular normal mapping. Scale of this texture can be adjusted in Texture Settingspanel\nHeightMap This input is used in both Parallax Occlusion Shading, and Displacement.\nDecal(___)Map These inputs are used internally by engine to create skinned decals on entities (like blood and mud on agents).\nTexture Settings Areamap Scale Used internally for parameter passing.\nSpecular Coef Metallic channel (Red channel of Specular texture) is multiplied by this value in shader.\nGloss Coef Gloss channel (Green channel of Specular texture) is multiplied by this value in shader.\nAmbient Occlusion Coef AO channel (Blue channel of Specular texture) is multiplied by this value in shader.\nNormal Depth Normal textures X and Y channels are multiplied by this value. If you set a value close to Zero, surface will appear more flat since X and Y values will be close to zero and only Z direction is contributed to normal mapping.\nDetail Normal Scale This parameters sets how many times the detail textures should tile. Higher values increases frequency.\nParallax Mode You can select displacement method to use for this material. Options are, Parallax or Displacement. Both require a heightmap texture. Parallax uses Parallax Occlusion Mapping in shader, Displacement uses hardware tesselation.\nParallax Amount Intensity of displacement effect.\nParallax Offset Sets the middle value to a desired height. (Value of 0.5 in heightmap).\nMaterial Shader Flags use_detailnormalmap This flag should be enabled to utilize Detail Normal Map feature.\nalpha_test Diffuse 1 textures alpha values are used as a cut-out texture. Alpha threshold can be specified in Transparencypanel.\nuse_specular This flag should be enabled in all cases. It is only here for lagecy reasons.\nuse_procedural_wind_animation Can be enabled to create a very simple and cheap, sine wave wind effect. Mostly used for tents / flags. (Should not be mistaken with cloth physics feature).\nself_illumination Enables self illumination. Illumination texture should be specified in Diffuse 2. Brightness parameters can be adjusted in Vector Arguments panel.\nuse_specular_from_diffuse Never ever use this. It is only used in pbr pipeline transitioning phase and only here for legacy reasons. Simply grayscales the diffuse texture, and uses it as specular texture.\nuse_double_colormap_with_mask_texture Used internally to create team color effect in clothing. A special texture is created to specify which parts of clothing should be affected by team colors. A simple Red / green texture for primary and secondary colors is specified in Diffuse 2 texture. Primary and Secondary colors are set by gameplay code as Factor Colors.\nTransparency Others Vector Arguments Factor Colors Vertex Layout Bump Map Should be enabled in most cases (Standard PBR requires this).\nSkinning and Skinning Precise If your material is going to be used with a skinned mesh, enable Skinning, if your skinned mesh is quite large that has important small polygons (like eyes) enable Skinning Precise. (This disables some optimizations so only use if it is really necessary).\nDouble UV Enable if your custom shaders require double UV channels.\nPostFX Used internally by engine.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/meshes/",
	"title": "Meshes",
	"tags": [],
	"description": "",
	"content": "Meshes contain the polygon positions and attributes to be used at the rendering pass. Every mesh has one material that defines their rendering behaviour. They are grouped inside MetaMesh\u0026rsquo;s by their LOD level. Also, at the same LOD level, there can be multiple meshes with different materials. More information about importing meshes to the engine can be found at Material Editor.\nLOD System Modern engines use LOD(level of detail) systems to ensure that the amount of GPU share used by the closer parts of the screen is more than the far ones. This is done by reducing the mesh qualiy with respect to the distance to the camera. This system ensures that the polygon per pixel ratio is similar across the screen as much as possible. The default LOD distances are as follows: 15, 22.5, 30, 50, 70, 130, 210 meters. These distances are for the best graphics quality and they can be reduced via the Environment Quality and Character Quality options.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/tactical_positions/",
	"title": "Mission Tactical Positions",
	"tags": [],
	"description": "",
	"content": "TACTICAL POSITIONS AND TACTICAL REGIONS These are scripted entities that let the AI know of the terrain\u0026rsquo;s features. They do not work like siege, the AI will not always use the tactical positions or regions you may place. They may use them under conditions that favor the use of these.\nDepending on player movement and spawn path randomization, there are a very high number of scenarios that can occur during battles. Because of this, it is better to have as many meaningful positions and regions marked as possible but not having these or not marking some of the meaningful positions will not result in obvious errors like in siege but will result in less interesting battles because AI won\u0026rsquo;t be aware of their surroundings. Types and how to use different tactical positions and regions:\nTactical Positions High Ground, Slope facing direction These are for advantageous high ground positions facing one direction. The AI may hold these positions if the enemy is approaching from the direction the tactical position is facing. Direction is the most important part. The position to defend will face the forward direction(green arrow in editor) of the position. Paramaters are as follows:\nTop of Hill, Defendable against all directions This is for high ground positions at the top of hills, easy to defend against all directions. AI may hold these positions regardless of the enemy approach direction. AI will position themselves on top of the hill according to enemy position. Direction is not important.\nChoke Points These are for positions with impassable barriers on either side. AI with inferior numbers may try to hold these positions in order to mitigate their number disadvantage.\nCliff Positions These tactical positions are meaningless by themselves. They should be put in entity hierarchy under choke point tactical positions. If placed under a choke point and the AI employs that choke point, only then cliff positions will be used.\nTACTICAL REGIONS These are for marking regions in scenes. Only a radius is given and the region is circular in shape. Obviously scenes will have regions with completely custom/random shaped forests, difficult terrains and openings. Therefore multiple tactical regions with various circular areas should be defined, as many as needed can be added. The radius and the circular area of each region can be a rough estimate, doesn\u0026rsquo;t need to be precise.\nForest Areas AI may use positions inside forest areas if the enemy has a superior number of ranged and cavalry units because archers and cavalry are less effective in forests. Any other region that is disadvantageous for both missile units and cavalry can be given a forest region, it doesn’t necessarily need to be a forest and have trees etc., it can be a marketplace with lots of obstacles and cover or something like that.\nDifficult Terrain This includes rocky terrain as well as swamps, or may be even marketplaces or some location with many obstacles on the ground, any area that does not hinder ranged fire(like forests) but impede and slow down cavalry should be considered and marked difficult terrain. AI may use positions inside difficult terrain areas if the enemy has a superior number of cavalry units.\nOpen Areas Positions that allow fast cavalry movement and clear missile fire. This region type is for marking suitable battlegrounds. The AI may choose to make their defense in Opening areas if they have superior or equal number of ranged and cavalry units.\nTACTICAL REGIONS AND POSITIONS COMBINATIONS Tactical Positions described in section A can also be placed under Tactical Region entities. Their _tacticalRegionMembership should be correctly selected. In this situation, AI will realize the choke point is also in a forest region and under right conditions, can prefer that choke position or high ground accordingly.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/asset_naming_conventions/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": "To distinguish and organize assets and simplfy asset authoring process there are some predefined rules to consider.\nMeshes All meshes imported from a single geometry file(e.g. fbx) are grouped by their names. To add a LOD mesh simply append \u0026quot;.lod\u0026lt;n\u0026gt;\u0026quot; to the name of your mesh. Here n is the number of lod.\nConsider an fbx file as below :\nasset.fbx :\n wall_damaged wall_damaged_v2 wall_damaged_v2.lod1 wall_damaged.lod1 wall_damaged.lod2  Two meshes will be imported from asset.fbx file : wall_damaged, wall_damaged_v2. These meshes will have one and two lods respectively. If your modelling software does not support dots in names(e.g. Maya) you can also use \u0026ldquo;_\u0026rdquo; insted of \u0026ldquo;.\u0026rdquo; to specifiy lods(e.g. wall_damaged_v2_lod1).\nA mesh can not have more than one material so during import phase meshes wil be divided into submeshes according to material usages of polygons. Consecutive numbers will be appended to the names of these auto generated meshes. Consider a mesh wall_damaged using three different materials. Name of the imported mesh will be wall_damaged and it will have three submeshes with names wall_damaged.1, wall_damaged.2, wall_damaged.3.\nPhysics shapes You can export physics shapes just like regular meshes. The only difference between a mesh and a physics shape is that name of physics shapes begin with \u0026ldquo;bo_\u0026rdquo; prefix. You can also export analytical capsules and spheres as well.\nCapsules\nIf name of a node begins with \u0026ldquo;bo_capsule\u0026rdquo; it will be imported as an analytical capsule shape. Sizes of this capsule is determined by following rules :\n Local XY axes assumed as the radial plane of capsule Local Z axis assumed as the direction of capsule(height) Scale of object in XY directions should be equal  Only orientation and extents of capsule nodes are used. Any content attached to them(like mesh) is ignored.\nSpheres\nIf name of a node begins with \u0026ldquo;bo_sphere\u0026rdquo; it will be imported as an analytical sphere shape. Sizes of this sphere is determined by the extents of the node. Center of the node will also be the center of the sphere shape. Only orientation and extents of sphere nodes are used. Any content attached to them(like mesh) is ignored.\nComposite Shapes\nYou can combine different shape types to create more complex shapes. To export a composite shape you must create a node whose name begins with \u0026ldquo;bo_composite\u0026rdquo;. You can append child nodes with different shape types to this node.\n bo_composite_building1 bo_capsule1 bo_capsule2 bo_sphere bo_building_walls  This shape will be imported as a single asset with name bo_composite_building1.\nTextures You can provide basic hints for your texture by following by following these rules:\n Albedo textures ends with _d Normal textures ends with _n Specular textures ends with _s Heightmap textures ends with _h  Despite these rules are not obligatory, it will help engine to decide best compilation rules during first import and help some features of editor to work(e.g. auto completing normal texture slot of material). If your textures do not follow them you can change import settings later though.\nSkeletons Most of in-house assets are organized so that skeletons, meshes and animations using these skeletons are stored in separate files. So we follow some naming rules to correctly establish cross-references between these files. If you are also planning to import skeletons, meshes and animations from different files :\n Bone hierarchy of skeletons must match Every bone node should have its name ending with a hardcoded bone number(e.g. _0, _1) to make sure skeletons originating from different files have their bone numbers match regardless of export process of your modelling software or exporting tool. There are these rules that each bone name must follow : Appended bone indices must start from zero Appended bone indices must not be greater than or equal to number of bones Two bones can not have same bone index  Skeletons take their names from the root node of bone hierarchy in your geometry file. This is to let you name your skeletons something other than the name of root bone. If your root bone does not have a parent node, you can create a dummy node and make your root bone child of it. By renaming dummy node you will be able to rename your skeleton without affecting bone names.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/overriding_scenes_prefabs/",
	"title": "Overriding Scenes and Prefabs",
	"tags": [],
	"description": "",
	"content": "You can override existing scenes and prefabs by creating new one with the same name.\nPrefabs Prefab definitions are stored in xml files located in Prefabs folder in each module\u0026rsquo;s directory.\nScenes Scenes are stored in two separate folders SceneObj and SceneEditData in each module\u0026rsquo;s directory. SceneObj folder stores necessary files to open scene in client mode while SceneEditData stores files necessary for editing operations.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/path_editing/",
	"title": "Path Editing",
	"tags": [],
	"description": "",
	"content": "Level designer can easily add, edit or delete paths and path points by the scene editor.\nAdding a new path User can use the Add New Path button at the upper toolbar. User should enter a unique name for every path. After the path is added, the editor\u0026rsquo;s editing state will become \u0026ldquo;Path Select\u0026rdquo;. By spacing either space or the \u0026ldquo;Add a new path point\u0026rdquo; button from the upper toolbar, user can transition to the \u0026ldquo;Path Node Add\u0026rdquo; mode and start adding new path nodes. At every click one more path node will be added to the current selected path. By pressing space again, user can start selecting and editing the existing path nodes. Every path node has three transform points. These are the center(cube) and the two tangents(spheres). User can hover onto them and select them by pressing the left mouse button. Then, pressing \u0026ldquo;T\u0026rdquo; button will spawn the transformation triad which can be used to move these points. Every operation can be undone by the \u0026ldquo;Control z\u0026rdquo; key combination. Selected path nodes can be deleted via the \u0026ldquo;Del\u0026rdquo; key. A path can be deleted by selecting the path and hitting the \u0026ldquo;Del\u0026rdquo; button. Also, to select another path, one can just hover into one of its node poinmts and pressing the left mouse button.\n   Add a new path Add a new path point Select a path point           "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/path/",
	"title": "Paths",
	"tags": [],
	"description": "",
	"content": "In RGL, \u0026lsquo;Paths\u0026rsquo; are used to define continous points within a scene. They have unique names and can be used by the gameplay logic for different reasons. Paths define how the siege engines move in missions. Also, for field battle missions, initial spawn point candidates are defined via a path. The spawn logic selects two positions for the teams with respect to the size of the battle. Detailed information about path editing can be found at Path Editing.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/skeleton_editor/",
	"title": "Skeleton Editor",
	"tags": [],
	"description": "",
	"content": "Skeleton editor can be used to edit, bones, joints, and ragdoll parameters of skeletons after importing them using resource browser.\nEditing Bones and Joints To edit a bone or joint, you can select the item you want from the outliner panel. This will create an Inspector of bones/joints for you to edit. All parameters are visualized and all edits will immediately be visible in the preview. Joint Properties Axis lock Axis lock limits the movement the child bone in translation space. Can be adjusted independetly for every axis. None:means This joint is not allowed to move in this axis. Free:means This joint is allowed to move freely as far as it can go in this axis. Limited:means This joint is allowed to move to as far as specified distance in this axis. (Axis Limit parameter) Twist Lock Twist lock limits the rotation the child bone in Z axis (Twist axis). Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to rotate. Free:means This joint is allowed to rotate freely as much as it can. Limited:means This joint is allowed to rotate to a certain limit. (Twist Limit parameters) Swing Lock Swing lock limits the rotation the child bone in X and Y axis. Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to swing. Free:means This joint is allowed to swing freely as much as it can. Limited:means This joint is allowed to swing to a certain limit. (Swing Limit parameters) All of these parameters are visualized in the preview. Feel free to modify and see the effects for yourself.\nBone Properties Bone properties can be used to change ragdoll and collision capsules. Capsule visualization can be enabled in Display panel. You can change capsule radius, Position 1 (Top of capsule), Position 2 (Bottom of capsule) from Properties panel.               Ragdoll Simulation Best way to visualize your changes is to enable ragdoll simulation and see your changes in real time. Simple select a skeleton from outliner, and hit Red \u0026ldquo;Simulation Enabled/Disabled\u0026rdquo; button. This will enable ragdoll simulation. Pressing this button again will disable ragdoll simulation and reset the skeleton to T-Pose.\nTesting and Saving changes "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/skeletons/",
	"title": "Skeletons",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/textures/",
	"title": "Textures",
	"tags": [],
	"description": "",
	"content": "Textures can be imported through the Asset Browser. They can be assigned to materials via the Material Editor. The texture slots of the PBR materials can be found at Material Editor.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/villages/",
	"title": "What Makes a Village Scene",
	"tags": [],
	"description": "",
	"content": "Introduction This list of checkpoints should aid you in creation of village scenes and provide you with an insight into what we pay attention to when creating village scenes.\nNavigation Mesh  Navigation mesh consists of triangles and quads. It is used by the AI for pathfinding. The global illumination system also uses it to find the visible locations of the scene. Keep in mind that the navigation mesh faces should not be too far away from the physics below it. The distance should at 1.5m maximum. The faces can be labeled to give cues to the agent spawning and the navigation inside the scene. In order to make the agents follow roads, we label the faces on top of the roads with the ID 2. Note that all of the agent spawnpoints should be connected by navigation mesh faces with ID 2. For the animals, navigation mesh ID 3 can be used. Typically, these faces are kept within separate islands in structures like ditches. The animals will then roam inside those islands only. All other faces should have the ID 0. Remember that the agents should use the navigation mesh ID\u0026rsquo;s 1 in order to create realistic pathing (on roads), scene designer should put an entity with the Navigation Mesh Deactivator (prefab name is Navigation_Mesh_Deactivator). It can be placed anywhere in the scene. Its purpose is to disable the ID 0 faces in civilian modes. The DisableFaceWithID variable of the script should be 1. For the animals, the variable \u0026ldquo;DisableFaceWithIDForAnimals\u0026rdquo; within the same script should be 3. Make sure the faces are fairly equal in size outside of the village area / where troops will maneuver. Make sure there are no disconnected navmeshes. The better the navmesh, the better will AI perform on it. Always think about that there might be big field battle inside the village. So try to avoid having many enclosed areas like a pig farm with only 1 entrance (for example: throw over some fences to create more entries) Avoid having big areas accessible to the player but not AI. Player will be able to shoot AI from places without navmesh. Use “_barrier_ai_x” to prevent AI from falling off from cliffs or getting stuck in tight areas (like a market booth) off the navmesh.  Spawn Points As noted before, all spawn points need to be placed on top of navmesh (ID 2) and inside the soft borders. Remember that some prefabs (like chairs and benches) come with spawn points attached to them. If the spawn points aren\u0026rsquo;t compatible with the village mission, they will most likely crash the game or cause errors. One example is \u0026ldquo;sp_blacksmith_with_smithing_machine\u0026rdquo;. The most important thing about the entry points are their tags. They decide what type of NPC will spawn there. For your own sake, don\u0026rsquo;t play around with those tags too much and keep them as they are from the prefabs.\n![](/img/village_scenes/3. Entry Points.png)\nPlayer Spawnpoint  Prefab: sp_player. Make sure it\u0026rsquo;s placed in a location where it can be seen from or at least has a clear path leading towards it. Do not place it too far away. There should be a navigation mesh under the spawnpoint.  Battle Spawnpoints  Prefab: Sp_battle_set. Make sure the attacker and defender spawns aren\u0026rsquo;t too close to each other or at least don\u0026rsquo;t have direct line of sight to each other. Make sure to move the reinforcement point out of sight as best as possible while still not being too far from the front lines. Make sure all spawnpoints have some empty space around for troops to properly spawn in.  Conversation Spawnpoints (civilian)  Prefab: sp_player_conversation. Conversation points define where the agent and the conversation partner spawn when the player enters the village via the \u0026ldquo;Talk to Notable\u0026rdquo; button from the World Map. Make sure they have a nice vista but keep them relatively close to the village center.  Animation Points (civilian)  Prefab: sp_npc_x. These are used for normal villagers. You can use around 40 positions. They define the positions in scenes where the villagers will spawn and walk to. Make sure they are nicely spaced throughout the village and close surroundings. Villagers will wonder along paths to get to them. If the paths are too long you might find your villagers wondering around at all times with nobody actually doing anything. Try to avoid long distances and place points close to the main paths. Placing more or less spawnpoints doesn\u0026rsquo;t influence how many villagers will populate the scene.  Rural Noteable Spawnpoints  Prefab: sp_notable_x. The number of prefabs should be around 6. These are the spawnpoints for the notables of the village (quest givers) and lords. Make sure they are in a prominent location of the village or generally places where village elder / lords would hang around. You can check the Debug Window (documentation will cover that) to make sure you have placed the correct notable positions. Go to the “Scene Entity Check Tab” and tick the “NPCs” Box and count.  Bandit Camps  Prefab: common_area_x. Each village scene has 3 Bandit Camps outside the village (place 3 prefabs), used for scene quests. Use the same spawns as for normal villagers (~15 per camp). Try to not have them do chores like farming. You can also use patrol spawnpoints: sp_guard_patrol_simple, sp_guard_patrol”. All spawn points in the radius will spawn bandits instead of villagers. You can increase the radius by scaling the common area prefab. Use civilian animation points as spawn points for bandits, some suggestions: “sp_npc_wait_wall, lookout, sp_npc_argue_set, sp_npc_wait”. Make sure that there is some indication to where they could be so that the player has a chance of finding them (especially at night). Don\u0026rsquo;t place them too close to each other.  ![](/img/village_scenes/4. Bandit Camps.png)\nAnimal Spawnpoints  Prefab: sp_animalName. Use “DisableWandering” in the AnimalSpawnSettings script, to stop animals from walking around your scene. Overall its best to put it on all bigger animals like cows and pigs if they aren\u0026rsquo;t there to wonder around.  Tactical Region  Prefab: TacticalRegion. Used to tell the AI where there are relevant bigger regions (forests, hills etc.). AI will position themselves inside the radius or avoid it. Don\u0026rsquo;t overuse it, stick to ~5 (make sure there is some variety).  Tactical Positions  Prefab: TacticalPosition. Used to tell the AI where there are relevant smaller positions (like choke points between buildings, cliffs for archers and so on). AI will position themselves according to the rotation of the Prefab and in regards to the width given by the script. You can use them quite often. The higher the slope the “better” is the position.  ![](/img/village_scenes/5. Tactical Positions.png)\nFlee Positions  Positions to which fleeing troops and also horses will run away too. Make sure they are inside the Soft Border and that there is a navmesh below them.  ![](/img/village_scenes/7. Flee Positions.png)\nDebug Window  Prefab: SpawnPointDebugView. There is a built-in debug tool which can be enabled by adding the above prefab to the scene. Place the prefab anywhere in the scene and activate the window with the check box in its script. This prefab opens a little debug window in the editor that helps you make sure you meet the requirements for the mission (like spawn points, navmesh). In the “Scene Entity Check Tab” you can count your Entry Points and make sure you have placed enough of them (or too many). In the “Navigation Mesh Check Tab” you can make sure all your Entry Points are connected to the navmesh properly.  ![](/img/village_scenes/2. Debug Window.png)\nSoft Border  Prefab: border_soft. They define the red borders of the scene. When placed they form a polygon where the 2 edges connect between the closest two border entities (but never more than two). To check the current borders, go into the \u0026ldquo;Visibility Window\u0026rdquo; → \u0026ldquo;Visibility Masks\u0026rdquo; and enable \u0026ldquo;Borders\u0026rdquo;. After crossing them the player has a few seconds to return inside the map borders, make sure this can\u0026rsquo;t be abused somehow.  ![](/img/village_scenes/6. Borders.png)\nSounds Master Ambient Sound  Prefab: x_ambient_sound. Choose a mandatory master ambient sound. You can place the prefab for the mandatory ambient sound anywhere. Make sure it has the “Is Master Sound” enabled. Make sure it doesn\u0026rsquo;t have the “Is Triggered” enabled.  Additional Ambient sounds  Used for bigger areas (like forests). Needs to have the “Is Triggered” bool. To see how far it reaches, from the \u0026ldquo;Visibility Window\u0026rdquo; enable \u0026ldquo;Sound Entities\u0026rdquo; under the \u0026ldquo;\u0026ldquo;Visibility Masks\u0026rdquo; group. To change their reach, you can scale them like you would do with other editor entities (using the “b” key or the gizmo).  ![](/img/village_scenes/8. Sounds.png)\nReverb  There are different prefabs for each use case: reverb_x. Adds reverb effect to any sound spawned inside its boundary. They are generally used for tight or underground areas. You can place these in tight alleys between taller buildings, cliffs, in caves or in dense forests. Needs to have the “Is Triggered” enabled.  Detail  Used for small details. Make sure “Is Triggered” is disabled. Place them where ever you want them to play.  Moving sounds on paths (for rivers and such) Sometimes it\u0026rsquo;s useful to move sounds along a coast line or a river. The below technique is more performance-friendly and more precise than placing multiple sound entities along your river for example.\n Place a path on the river. For more information, see Path Editing. Add the sound to the scene. Place any additional Ambient sound as explained above. Add the “path_converger” script to your ambient sound\u0026rsquo;s entity. Enter the name of your path to the \u0026ldquo;path_converger\u0026rdquo;. The sound will now follow the path according to the camera position.  Sounds in the Engine You can check the \u0026ldquo;MODDING_TOOLS_DIRECTORY/Sounds/GUIDs.txt\u0026rdquo; file for the list of the sounds in the game. These names can be used inside the script of the sound entities.\nLights  Have at least one “envmap_prop” in your scene. For darker areas like caves use “local_envmap_prop”. It will affect the lighting in an area depending on the values of its “ReflectionCapturer” script. Make sure the village and bandit camps are nicely lit. Take extra care for the conversation points. Use torches and other entities. Make sure torches inside buildings and other dark areas have “alwaysBurn” enabled in the LightCycle script. Try to avoid placing “artificial lights” without an actual source. You can bake the ambient lighting in your scene with the GI system. This will make the ambient lighting much more realistic. For more information, see GI System.  ![](/img/village_scenes/9. Lights.png)\nAtmosphere  Make sure your scene works and looks fine with all of the “TOD_x” atmospheres and in all seasons! (since it will be tested with those). Choose a “Color Grade” that fits your scene (we suggest using the ones for the faction your scene is for, like: “color_grade_empire_soft”).  ![](/img/village_scenes/10. Atmosphere.png)\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/quickguide_create_a_mod/",
	"title": "创建一个Mod - 快速入门",
	"tags": [],
	"description": "",
	"content": "Mod 可以包含从网格到物理实体、场景、游戏实体（如派系、领主、部队、物品）以及可以运行任何游戏逻辑的脚本和行为等资产 (Assets)。在本指南中，将解释创建一个 Mod 的过程。\n新建一个Mod Mod 位于根目录下的 \u0026ldquo;Modules\u0026rdquo; 文件夹内，它必须包含名为 SubModule.xml 的 xml 文件。这个文件提供 \u0026ldquo;Name\u0026rdquo;、\u0026ldquo;ID\u0026rdquo; 和 \u0026ldquo;Version\u0026rdquo; 节点等基本信息。另外，还可以在 \u0026ldquo;DepenendedModules\u0026rdquo; 节点里面定义依赖模块。如果你想制作一个单人模式 Mod，它的 \u0026ldquo;DepenendedModules\u0026rdquo; 也应该包含一个 \u0026ldquo;SingleplayerModule\u0026rdquo; 节点。此后，该 Mod 将在游戏启动器中出现。\n子Mod 可以定义在运行时加载的 DLL。这些 DLL 应该包含继承自 \u0026ldquo;MBSubModuleBase\u0026rdquo; 的 Class，其名称应该与 xml 中的 \u0026ldquo;SubModuleClassType\u0026rdquo; 节点一致。该类将被构造，并被调用某些回调，这样 od 就可以将其行为注册到游戏中。\nMod 层次结构 Mod 可以具有多个文件夹，其中包含不同类型的内容：\n bin: 编译后的DLL应该放在 \u0026ldquo;bin/Win64_Shipping_Client\u0026quot;文件夹内，这样游戏才能找到并加载DLL。 Atmospheres: 此文件夹包含可在游戏中使用的不同环境 (Atmosphere) 模板。可以从编辑器将新的环境保存到任何 Mod。 AssetSources: 此文件夹包含资产的来源。编辑器将资产导入此文件夹。在发布 Mod 之前可以过滤掉这个文件夹。关于向模块添加新内容的更多信息，请参见 添加\u0026amp;覆盖资产。 Assets: 此文件夹包含从内容源派生的资产数据。它仅在 mod 开发阶段使用。在发布 mod 之前，该文件夹可能会被过滤掉。 AssetPackages: 当模块的内容工作完成后，内容创建者应该开始 \u0026ldquo;Publish\u0026rdquo; 操作，为内容的发布做好准备。此文件夹包含了被发布的资产。 GUI: 此文件夹包含任何新的可供游戏使用的GUI元素，预制件或笔刷。 ModuleData: 此文件夹有许多包含了重要游戏逻辑的 xml 文件。\u0026ldquo;project.mbproj\u0026rdquo; 文件管理着将被加载到该文件夹内的 xml 文件。这些 xml 涵盖了从动画和套装到阵营、部队、物品等内容。 NavMeshPrefabs: 导航网面组可以在编辑器中保存为模板，方便插入到多个场景中。此文件夹包含了这些内容。 Prefabs: 此文件夹包含了预制件的XML。更多信息，请看 实体\u0026amp;预制件。 SceneObj: 此文件夹保存着从任何编辑数据中剥离出来的场景数据。没有地形的场景只能存放在这个文件夹中。 SceneEditData: 包含每个场景的地形编辑数据。此文件夹可以在发布mod之前过滤掉。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_creation/",
	"title": "地形创建",
	"tags": [],
	"description": "",
	"content": " 创建新地形 生成，删除和修改地形节点可以通过 地形检查器 (Terrain Inspector) —\u0026gt; 属性 (Properties) 进行操作。\n地形节点Terrain node是二维计算，分辨率和大小可以通过 新地形属性 (New Terrain Properties) 界面查看。\n这些参数必须在创建之前就有指定数值，尽管可以在之后对各节点进行一一调整。\n              调整节点属性 节点分辨率可以在选择节点后（选择多个节点就要按住CTRL选择）即可在 节点属性（Node Properties） 界面中调整。\n这个功能可用于分辨率不太重要的地方来优化地形（如定居点之外，玩家无法进入的地方，或者水底）\n导入/导出材质地图或者高度地图 为了支持外部地形生成器，引擎可以导入导出地形材质地图或者高度地图。你可以通过导入各种图层（碎屑图，水流图，植被图，基岩图）和16 bit的高度地图来轻松生成想要的地形。要导入材质地图时，首先你必须创建一个新的地形图层，然后选择该图层，进入属性 (Properties)，选择一些节点（CTRL+A 选择所有）然后点击导入材质地图(Import Materialmap)按钮。这样就会打开一个文件对话框让你选择文件，你可以选择8 bit的材质当作材质地图。你也可以用同样方法导入高度地图(Heightmap)，高度地图可以是8、16位的（PNG或者源文件格式）。\n                    "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/",
	"title": "场景编辑器",
	"tags": [],
	"description": "",
	"content": "Creating EntityPath Editing地形创建编辑器快捷键Entity InspectorNavigation Mesh InspectorAlignment and Snapping ToolsDistance ToolPrecomputed Radiance Transfer - GI SystemScene Level SystemTerrain Mesh Blend System群体选择调整地形大小"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/faq/",
	"title": "常见问题解答",
	"tags": [],
	"description": "",
	"content": "如何安装工具？ 从 Steam 库的工具部分中找到并下载“Mount \u0026amp; Blade Bannerlord Modding Tools”。请注意，本工具会使用部分已经下载好的游戏本体的文件，因此，工具的版本应与游戏版本一致并且应与游戏本体安装在同一驱动器中。\n如何启动工具？ 选择启动器中的 Singleplayer 选项并启动，等你进入到游戏主菜单界面后，你既可以单击 Editor 启动编辑器，也可以按下组合键 Ctrl + E 来启动编辑器。\n如何创建你自己的模组？ 我们在编辑器里内置了一个功能，可以直接创建一个有 XML 模板文件的模组，方便你快速开始添加新内容。打开编辑器后，在顶端工具栏的“File”菜单下找到“Create New Module”选项，点击它。请注意，你需要重启游戏来让启动器识别该模组。\n如何编辑游戏本体(Native)资源？ 你无法直接编辑游戏本体资源，但你可以在你的模组中覆盖掉它们。详情请参阅： 添加\u0026amp;覆盖资产我无法添加新模型、材质等 你无法直接向游戏本体添加资源，你需要在你自己的模组里添加它们。\n首先，你需要新建一个模组：快速入门指南更多关于添加新的资产的信息请参阅： 添加\u0026amp;覆盖资产可供参考的示例场景？ empire_village_003\nkhuzait_castle_002\nsturgia_town_b\nbattle_terrain_v\nempire_castle_keep_a_l3_interior\nempire_house_c_tavern_a\nempire_dungeon_a\narena_empire_a\nMain_map\n在哪能找到示例资产？ 你可以从资源浏览器(Resource Browser)中查看这些游戏本体的资源，但没有源文件提供，因此你也无法导出它们。我们很快会提供一些示例的源文件。\n我有包含 DLL 文件的模组然后我的工具无法启动？ 如果你有任何包含 DLL 文件的模组，请确保它们同样被复制到了 Modules\\MOD_NAME\\bin\\Win64_Shipping_wEditor 目录下。\n我的模组工具无法启动 请确定你的机器安装了 Visual Studio 2013 Redist x64。此外，请检查你的游戏本体版本是否与模组开发工具版本相匹配。如果完成了以上检查仍旧无法启动，你可以在官方论坛的modding forums分区下的“Bug \u0026amp; Crashes”板块发帖反馈：https://forums.taleworlds.com/index.php?forums/bug-crash-reports.784/\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/materials/",
	"title": "材质",
	"tags": [],
	"description": "",
	"content": "材质（Materials）定义了网格模型的渲染特性。它们包含着色器和纹理信息，也包含渲染标志（由着色器和全局标志定义）。一个网格模型可以拥有一个材质。在第三方网格编辑程序中，网格材质的初始值将通过它的材质名称来分配。材质可以通过材质浏览器来创建和编辑，而材质浏览器则可以通过资源浏览器来访问。材质也可以在运行时通过脚本和行为进行编辑。更多关于材质编辑和引擎默认材质的信息可以可以参阅材质编辑器 (Material Editor) 章节。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/overriding_assets/",
	"title": "添加与覆盖资产",
	"tags": [],
	"description": "",
	"content": "在 RGL 中，您可以轻松地覆盖现有资产或在编辑器中为自定义模组创建新资产。覆盖机制的生效方式是将现有资产替换为你的模组资产目录中提供的对应资产。 它会尝试匹配您的自定义资产与其他模块先前通过其名称注册的资产。模块的加载顺序会影响这一过程。\n如果除了 Native 模块之外还分别加载了 模组 A 和 模组 B ，则最终资产及其来源列表如下：\n当前可在自定义模组中替换的资产类型为：\n 材质 (Material) 网格模型 (Mesh) 纹理 (Texture) 物理形状 (Physics Shape)  文件夹结构 资产系统会根据模块目录中的某些文件夹名称进行处理。这是这些文件夹及其用法的列表：\n Assets : 包括可编辑的 *.tpac 文件，该文件存储每个资产的元数据。 AssetSources : 包括导入资产（.psd，.fbx）的源文件。 AssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于客户端构建时，将生成该文件。 EmAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于编辑器构建时，将生成该文件。 DsAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于服务器构建时，将生成该文件。 RuntimeDataCache : 包括引擎所需的对每个资产自动生成的数据。可以删除，但在启动过程中从头开始生成可能会花费时间。  Modding Permissions 资产系统会根据游戏运行的可执行文件的版本寻找不同的文件夹。根据这些文件夹的存在与否，它判定一个模块是否可以被修改，或只能在只读模式下使用。如果您想发布您的模块，您可以打包您的资产并共享打包后的文件夹，而不需要发布成千上万的文件及其源文件。您有三个选项来打包您的资产。\n Client : 其他人可以激活您的模组并运行。您必须分发 AssetPackages 文件夹。 Editor : 其他人可以在编辑器中使用您的模组，但不能修改它。如果您希望其他人从您的模组派生模组，则使用它。您必须分发 EmAssetPackages 文件夹。 Server : 用于服务器构建。需要剥离与服务器无关的所有数据。您必须分发 DsAssetPackages 文件夹。  您也可以像使用您的模组一样共享您的模组，以允许其他人修改它。在这种情况下，你必须分发 Assets、AssetSources 和可选的 RuntimeDataCache 文件夹。\n材质覆盖 覆盖材料可以通过创建一个新的材质来完成，其名称与您要覆盖的材质相同。 导航到您的模块的assets目录，并在浏览器窗格中的空白处右击。创建一个新的材质，并将其重命名为与您要覆盖的材质相同的名称。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/material_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;被模组 A 覆盖的现有网格模型的材质\u0026lt;/div\u0026gt;  此时，系统中所有的材质引用将被重定向到您的自定义材质。 网格模型覆盖 模型可以从多种文件格式（如Trf、Fbx）导入。从单个文件导入的资源根据 \u0026lt;\u0026gt;资产命名规则\u0026lt;\u0026gt; 按其名称进行分组。想象如下一个fbx文件：\n Model.fbx  wall(Mesh) wall.lod1(Mesh) wall.lod3(Mesh) bo_wall(Physics Shape)    根据资产命名的惯例，前三个资源将被归入一个网格，其中有三个子网格属于不同的 LOD，最后从 Model.fbx 导入两个资产：wall (Mesh）和 bo_wall (Physics shape)。最后将从 Model.fbx 中导入两个资产：wall (Mesh) 和 bo_wall (Physics shape)。\n按照这些规则，您可以导出一个新的几何文件（例如 fbx)，其中包含一组名称以 wall 开头的网格。在这种情况下，一个新的 wall 网格将从这些子网格中创建，而现有的网格将被您提供的网格完全替换。几何图形文件的名称不在考虑之列。值得一提的是，网格覆盖是在网格层面进行的。不能通过模组覆盖来覆盖单个子网格。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/metamesh_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的带有名称 \u0026lt;strong\u0026gt;testbox\u0026lt;/strong\u0026gt; 的立方体网格被模组 A 用茶壶覆盖\u0026lt;/div\u0026gt;  纹理覆盖 纹理的覆盖与材质非常相似。你需要导入一个新的纹理，其名称与你要覆盖的纹理相同。你也可以将任何已经导入的纹理重命名为与要覆盖的纹理名称相匹配的字符。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/texture_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的名为 \u0026lt;strong\u0026gt;roman_ground_d\u0026lt;/strong\u0026gt; 的 albedo 纹理被模组 A 用白色纹理覆盖\u0026lt;/div\u0026gt;  物理形状覆盖 覆盖物理形状需要你导入一个与你要替换的资产名称相同的物理形状。检查 \u0026lt;\u0026gt;资产命名规则\u0026lt;\u0026gt; 以了解如何导入物理形状。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/physics_shape_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的圆环形状被模组 A 用一个自定义的水蓝色形状覆盖\u0026lt;/div\u0026gt;  "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/bodies/",
	"title": "物体",
	"tags": [],
	"description": "",
	"content": "物体定义了物体的物理边界，它们可以被分配给场景或者预制物件的实体。用户可以编辑“物体标识”（Body Flag) 来改变其行为。\n物体标识(Body Flags)  双面（Two Sided）：让物理引擎可以使用多边形的两面。 Ai限制器（AI Limiter）：用来标记只针对AI使用的物体，不包括玩家。 可破坏的门（Destructible Door）: 通过自动导航网格生成器来使用，而非将导航网格直接置于可破坏的门之下。 禁用（Disabled）:禁用预制物体，或者实体实例的物理特性。 边界（Barrier）：使对象可以顺利移出物体内部 排除路径对齐（Exclude Path Snap）：适用于路径点无法对齐物体的情况 避免镜头碰撞（Don’t Collide With Camera）：玩家的镜头不会和对应物品产生碰撞。 动态化（Dynamic）：可以让物理引擎会模拟实体的运动 可移动化（Moveable）：该标识标志该物品及其所有的实体可以移动 梯形化（Ladder）：赋予梯形网格，从而使其正常运行。 台阶化（Has Steps）：决定是否将实体物品楼梯化，使得对象能够正确地攀爬楼梯。(楼梯的物体应与实体的其他部分分开)。  自主体的物理引擎要求平滑和低多边形的物理对象来保证性能。投射物则要求更高的精度，以达到能更好的模拟投射物卡顿效果。以下的标识可以用于让每个物体拥有两个不同的机体，以适应两种不同的情况。若两者均未被标记，投射物和自主体都会对该物体做出反应。\n 仅限自主体（Agent Only）: 只有自主体会对该物体做出反应。 仅限投射物（Missile Only）: 只有投射物会对该物体做出反应。  遮蔽器（Occluders） 遮蔽器被用于网格模型表面，从而让渲染系统不会去渲染物体的另一面。通常来说，它们对物理模拟过程通常作用不大。但对于大城镇和村庄来说，精心布置的遮蔽器将会非常有用。用户可以直接在场景中放置遮蔽器，也可以将其附加到到实体物品和预制件上。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/playing-sounds/adding-custom-sounds/",
	"title": "给你的Mod添加音乐",
	"tags": [],
	"description": "",
	"content": "《霸主》的音频系统是基于 FMOD 音频引擎建立的。 为了保持音频引擎性能的同时让大家都能使用它，我们需要建立一个 中间层 (InterLayer)。\n关键要素  ...\\Modules\\*YOUR_MOD*\\ModuleData\\module_sounds.xml 文件， 你可以在此添加你自己音乐的定义。 ...\\Modules\\*YOUR_MOD*\\ModuleSounds 文件夹，你可以在此添加音频文件 （.ogg 或 .wav）。  你可以查看 Native Mod 中的例子。\n基础指南  复制样例的文件和文件夹到你的 Mod 目录下； 添加新的音频文件到 ModuleSounds 文件夹； 打开编辑你 Mod 下的 module_sounds.xml 文件； 你会在 module_sounds.xml 文件中看到音频的目录，播放音乐的代码样例，以及样例的 module_sound 实体 (Entries)； 在 module_sounds.xml 文件中为你的 Mod 添加新的音频实体； 根据代码播放新的音频实体。  下一步 使用 module_sounds.xml 文件 \u0026lt;module_sound name=\u0026#34;example/combat/hit\u0026#34; is_2d=\u0026#34;true\u0026#34; sound_category=\u0026#34;mission_combat\u0026#34; path=\u0026#34;example_sound_modders.ogg\u0026#34; /\u0026gt;  \u0026lsquo;name\u0026rsquo;: 任何你想要的唯一名字，这个是你音频的 ID。  通过代码播放音乐的时候使用。 想播放有声动画 (animation sound) 时，添加进动画 sound_code 特性 (attribute) 中。   \u0026lsquo;is_2d\u0026rsquo;: 是否使用音频的空间属性 (spatial properties)。 3D 音频会有例如 位置、速度等属性。 \u0026lsquo;sound_category\u0026rsquo;: 所有的音频必须被分配一个分类 (category) 来分配其在通信管道 (pipes) 中的路由 (route)。可用的分类有：  mission_ambient_bed (2D 环境声 (ambient loops) 比如基本风声 ) mission_ambient_3d_big (一般从远距离听到的音频，比如一个正在燃烧/战斗的城堡) mission_ambient_3d_medium (一般从中距离听到的音频，比如烽火) mission_ambient_3d_small (一般从附近近距离听到的音频，比如营火) mission_material_impact (物理材质效果比如 金属 剑击打 石 墙) mission_combat_trivial (造成不重要伤害时候的音频，比如低伤害或者无伤) mission_combat (普通造成伤害的音频) mission_foley (回转，移动以及动物移动的音频) mission_voice_shout (一般被远距离听到的人物/动物的声音，比如战斗的呐喊) mission_voice (人或者动物咕噜 (grunts) 或者击倒 (knockouts) 的音频。) mission_voice_trivial (比较安静的发声，比如攀爬和跳跃) mission_siege_loud (大型攻城战的声响，比如巨石击中墙壁、火焰投石车以及城门破坏的音频) mission_footstep (人类和小型动物的标准脚步) mission_footstep_run (更大的脚步声，指那种可在一定距离的人群中能听到的声音) mission_horse_gallop (马匹和骆驼疾驰的声音) mission_horse_walk (马匹和骆驼慢走的声音) ui (UI 和 提示的 2D 音频) alert (伪3D音频 (Psuedo-3d sounds)，用于从中距离警告玩家) campaign_node (位置性的声音节点，一般用于世界地图，农场，海和瀑布等) campaign_bed (2D 环境声，一般用于世界地图，沙漠阵风和牧场的风等)   \u0026lsquo;path\u0026rsquo;: 声音文件的路径。路径是基于你 Mod 的 ModuleSounds 文件夹的相对路径，你可以创建自己的子目录。  播放音频的代码样例 int soundIndex = SoundEvent.GetEventIdFromString(\u0026#34;example/voice/charge\u0026#34;); // 缓存 soundIndex 对象来避免运行中的 string 操作。  if (playOneshot) { MakeSound(soundIndex, MainAgent.Position, false, true, -1, -1); // 给定的位置等参数信息，播放单触发 (one shot sound) 音频。  } else { SoundEvent eventRef = SoundEvent.CreateEvent(soundIndex, Scene); // 给定音频的引用 (reference)，可以之后更新细节参数。  eventRef.SetPosition(MainAgent.Position); eventRef.Play(); } 你有两种方式可以播放音频：\n 单触发 (one shot) 性能更好，控制的更少，发后即忘 (Fire and forget)。适合战斗相关的音频。 创建并维持一个音频引用 (reference)\n性能稍差，可以控制声音的每一个参数，比如暂停和更新位置的时间。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/",
	"title": "编辑器",
	"tags": [],
	"description": "editor",
	"content": "场景编辑器资源编辑器"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/editor_shortcuts/",
	"title": "编辑器快捷键",
	"tags": [],
	"description": "",
	"content": "   常用按键 按键 编辑器模式     显示/隐藏帮助 H 任何模式   创建场景 Alt + 1 任何模式   保存场景 Alt + 2 任何模式   打开场景 Alt + 3 任何模式   开始任务 Alt + 4 任何模式   以…方式开始任务 Alt + 5 任何模式   场景选项 Alt + 6 任何模式   地形选项 Alt + 7 地形选项   地形海拔 Alt + 8 地形海拔   地形涂色 Alt + 9 地形涂色   切换相关编辑模式 (选择-增加，选择-海拔和涂色等) 空格 任何模式   返回/撤回 Ctrl+Z, Ctrl+Y 任何模式       视角控制 按键 编辑器模式     聚焦到选定模型 F 选择Entity   编辑器摄像头旋转模式 按住Alt +鼠标右键滑动 选择Entity   Pan 按住Alt +鼠标中键 选择Entity   拉近拉远摄像头 按住ALT + 滑动鼠标中键 选择Entity   加快减慢摄像头速度 Ctrl + 滑动鼠标中键 任何模式   摄像头速度设置为1 Ctrl + 鼠标中键 任何模式       PREFAB TRANSFORM 按键 编辑器模式     原地旋转 垂直旋转按Z, 左右旋转按X, 前后旋转按C, T, 返回默认按 R Entity Add   移动模型并放置在地面上 按住P 选择Entity   上下移动 按住N 选择Entity   水平移动 按住G 选择Entity   显示XYZ轴 T 选择Entity   显示旋转轴 R 选择Entity   显示大小比例轴 Y 选择Entity   复制粘贴模型 Shift+单击鼠标或者 Shift+拖拽 选择Entity   隐藏轴 V 选择Entity   切换为本地变换视图 Alt+L 选择Entity   切换为世界变换视图 Alt+W 选择Entity   打开模型材质视图 M+单击鼠标 选择Entity       地形 按键 编辑器模式     全选所有地形节点 Ctrl + A 选择地形   当选择提高时下降海拔 Alt + 点击 地形海拔   当选择下降时提高海拔 Alt + 点击 地形海拔   平整地形 Ctrl +鼠标左键 地形海拔   平滑地形 Shift + 点击 地形海拔   当选择平整地形时，以该高度为平整海拔 Alt + 单击 地形海拔   添加植被（不在图层上增加） 鼠标左键 涂色Entity   重新规划当前植被面积大小 按住B+鼠标左右拖拽 涂色Entity   放置单个植被 Ctrl + 左键单击 涂色Entity       NAVMESH HOTKEYS 按键 编辑器模式     填充最近的4个顶点（形成一个面） Shift +单击 添加导航网格   填充最末端的4个顶点（形成一个面） Ctrl + 空格 添加导航网格   不用选择也可以挪动顶点 Ctrl +拖拽 添加导航网格   删除面并留下顶点 Alt + 单击 添加导航网格   删除面及其顶点 Alt + X + 单击 添加导航网格   选择顶点模式 1 选择导航网格   选择边模式 2 选择导航网格   选择面模式 3 选择导航网格   选择连接的所有顶点，边和面、 Ctrl + A 选择导航网格   删除顶点/边/面 Delete 选择导航网格    "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/scripts/",
	"title": "脚本",
	"tags": [],
	"description": "",
	"content": "脚本组件是附加在实体上的可执行脚本，可以用来实现各种游戏功能。在《霸主》中，很多游戏逻辑都是通过脚本组件来编写的。例如椅子、掉落的武器、攻城器械。有很多不同的回调函数，可以被继承并填充在这些脚本组件中。\n回调函数  Constructor: 在构造函数中，我们需要给它的公有变量分配默认值（可以被场景制作者改变的变量）。在构造函数中，脚本组件不会被分配给实体或场景。另外，不要在这里写任何有副作用的逻辑，因为即使创建了脚本组件，由于升级等级系统的原因，一旦打开场景，脚本组件就可能会被删除。 OnPreInit: 当脚本组件被分配给场景中的所有者实体后，这个回调被调用。一旦你进入了这个回调，那么该脚本实例中的用户定义变量就被设置了。然而，其他实体的脚本组件可能还没有被分配。因此，在预初始化中，不应该有任何依赖于其他脚本组件的逻辑代码。例如，在预初始化中， ManagedObject 将自己注册到当前任务实例中的托管对象数组。 OnInit: 当任务被加载且所有实体的脚本组件被初始化，这个回调就会被立刻调用。你可以在这个回调里面使用任何类型的逻辑代码。运行时实例化的脚本也会得到这个回调的调用。 OnEditorInit: OnInit 的编辑器版本，在从编辑器加载场景时被调用。当场景从编辑器中加载时，它会被调用。确保编辑器中没有任务或游戏状态。 OnTick: 对于每个脚本组件，该任务在同一线程的任务的每个帧中都被调用。 OnEditorTick: OnTick 的编辑器版本。 IsOnlyVisual: 如果你有一个脚本组件，只是可视化的，没有任何应该在服务器版本上运行的逻辑代码，你应该在这个函数中返回 true 。这确保了这种类型的脚本不会在服务器版本上运行。 OnEditorVariableChanged: 在编辑器中，每当用户改变该脚本组件中的公有变量时，就会调用这个回调。如果艺术家需要在编辑器场景中得到即时反馈，这个回调可以用于任何视觉-逻辑状态的改变。 OnRemoved: 当实体或脚本组件被移除时调用。如果你有任何已分配内存的对象被存储在其他地方（例如静态容器），你可以使用这个回调来确保它们被回收，避免泄露内存。  "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-browser/",
	"title": "资产浏览器",
	"tags": [],
	"description": "",
	"content": "Asset browser shows assets 5256+2+56\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/",
	"title": "资产管理",
	"tags": [],
	"description": "",
	"content": "创建一个Mod - 快速入门常见问题解答资产浏览器资产类型"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/",
	"title": "资产类型",
	"tags": [],
	"description": "",
	"content": "AnimationsEntities \u0026amp; PrefabsMeshesNaming ConventionsOverriding Scenes and PrefabsPathsSkeletonsTextures材质添加与覆盖资产物体脚本"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/",
	"title": "资源编辑器",
	"tags": [],
	"description": "",
	"content": "Material EditorSkeleton EditorCloth SimulationMeta Mesh EditorModel ViewerTexture Editor"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/",
	"title": "霸主任务系统",
	"tags": [],
	"description": "",
	"content": "Mission Tactical PositionsWhat Makes a Village SceneDestructible ComponentScene Barrier BuilderScene Spawn Point GuideScript Component CallbacksSpawn Point Debug Tool"
},
{
	"uri": "http://localhost:4444/zh_cn/playing-sounds/",
	"title": "音乐",
	"tags": [],
	"description": "",
	"content": "给你的Mod添加音乐"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/entity_inspector/",
	"title": "Entity Inspector",
	"tags": [],
	"description": "",
	"content": "Transform Panel Transform panel allows you to change position, rotation and scale properties of the selected entities. All of these values are relative to the parent of the selected entity. If Entity has no parent, then they are the Global values. (in Worldspace).\nScale Locked If the lock icon is in locked state, changing any component of scale parameter will set all scale components to the same value, entity will be in uniform scaling mode.\nUnlocked If the lock icon is in unlocked state, every scale component can be changed independently, and will allow non-uniform scaling.\nTransform with Gizmo Transform modes All of the transformation can also be done using Gizmo. Gizmo can be activated by selecting an entity (or multiple entities) and pressing one of the hotkeys below.\n   Rotate Translate Scale     Hotkey: R Hotkey: T Hotkey: Y         Transform spaces Gizmo can work in three different spaces; Worldspace, Localspace and Screenspace.\nWorld space World coordinates is just a fixed, parent coordinate system. This is the global coordinate system that everything is defined relative to. World Coordinate has a fixed [1, 0, 0] in the Xdirection, [0, 1, 0] in the Ydirection, and [0, 0, 1] in the Zdirection.\nLocal space Local coordinates are relative to the entity itself, every transform is defined such as that the center of the entity is center of the universe.\nScreen space Screen space coordinates are relative to the camera. Right of your viewport is always the Xaxis, Top is always the Yaxis, and forward is always the -Z(minus Z) axis.\nEntity Tag System An entity on editor can be identified by a tag defined by the user.\nAdding Tags In the Entity Inspector, under the \u0026ldquo;Tags\u0026rdquo; title, there is a button with label \u0026ldquo;Add New Tag\u0026rdquo;. This button opens a window asking for the name of the tag.\nUsing an Existing Tag After clicking on the \u0026ldquo;Add New Tag\u0026rdquo; button, from the dropdown menu in the window, you can select tags, which were added to the current scene entities before.\nA Special Case: Prefabs If you are modifying a prefab entity, adding tags to the prefab does not break it. In other words, if you change the prefab after tagging the prefab entity in the scene, the scene entity will have all the changes as well. The tags are stored in the xml files with \u0026ldquo;\u0026lt; tags \u0026gt;\u0026hellip; \u0026lt; / tags \u0026gt;\u0026rdquo; syntax. (without the white spaces between characters)\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/nav_mesh_inspector/",
	"title": "Navigation Mesh Inspector",
	"tags": [],
	"description": "",
	"content": "Tools These tools help you to generate and manipulate the navigation mesh:\nGeneration Tools  Auto Generate: As the name implies, automatically generates the navigation mesh with resppect to the parameters above. Generate Grids: Generates grid navigation mesh for the terrain only. It ignores the entities on the scene. Create New Face: Creates a new navigation mesh quad face on the coordinates where the camera is. Extrude: Remove: Removes the selected navigation mesh edge. Fill: Fills between the selected navigation mesh vertices and forms a face. Grow Selection: Grows the selection by selecting the adjacent elements to the selected elements (Works for all vertex, edge and face structures) Connect: Connects the selected two navigation mesh vertices by drawing an edge between them. Subdivide: Divides the navigation mesh edge by putting a vertex on the middle of it. This vertex is connected to the adjacent vertices and divides the face of interest. Weld: Removes vertices forming the edge and makes the edge one single vertex. It connects the old adjacent vertices to the newly generated vertex. Import Faces From Prefabs: Imports faces which were exported for later use. Import Body: \u0026lt;not_known\u0026gt; Make Quads When Possible: Selects adjacent triangle faces, which can construct quads (which do not form a concave polygon). This is not going to construct the most optimal nav mesh, having faces with the greatest surface areas, but it will locally select the triangles forming the greatest surface area. It will still reduce the total number of faces strongly.  Debugging Tools  X-Z Keys: Puts two different spheres per key, and when both are put, gives statistics about the path defined between these two spheres. Select Vertices Below Entities: The name implies the purpose. Select Unwalkable Edges: \u0026lt;not_known\u0026gt; Fix Concave Faces: Makes the concave faces convex. Select Unconnected Faces: \u0026lt;not_known\u0026gt; Calculate Auto Weld Points: \u0026lt;not_known\u0026gt; Select Inverted Faces: Finds and selects the inverse faces, facing towards the terrain. Find Path: \u0026lt;not_known\u0026gt; Paste Copied Faces: The name implies the purpose. Copy Selected Faces: The name implies the purpose. Export Faces as Prefab: Exports the selected faces for later use. Ensure Faces Are Not Below Ground: The name implies the puspose. Remove Unreachable Faces: Removes the faces which are not connected to any island, in which there is a spawn point. (Spawn points are decided according to the entities in Prefabs/editor_spawnpoints.xml, also entities containing AnimationPoint script.) Find Tight Faces: Finds faces whose surface area is below the desired value, and selects them. You can press the \u0026ldquo;delete\u0026rdquo; button to remove these faces. After doing this, do not forget to \u0026ldquo;Remove Unused Vertices\u0026rdquo;, which I\u0026rsquo;ll be mentioning a few lines below. Remove Unused Vertices: This will remove the vertices which are not connected to any face. Select Vertices At The Edges: Selects the vertices connected to only 2 edges, hence, not being a part of a continuous face component. Select Vertices Without Edges: This will just select the faces which are not connected to any edge or face. Mark Elevation Problem Faces: Faces having distance greater than 1.2 meters to the bottom (a mesh or the terrain) will be selected for debug purposes.  Auto Generation Parameters These parameters arrange the precision, extend and operation details of the navigation mesh generation. Explanation of the parameters are as following:\n Build Detailed Nav Mesh: Checking this box makes use of the following parameters and builds a detailed nav mesh according to them. If not checked, the following parameters won\u0026rsquo;t make any difference. Cell Size: Defines the horizontal edge length of the sample voxel examined by the Recast Library. Cell Height: Defines the vertical edge length of the sample voxel examined by the Recast Library. Agent Max Slope: Maximum angle in which the agent can climb (in degrees). Agent Height: The name defines itself. Agent Max Climb: Maximum meters the agent can step on. Agent Radius: The name defines itself. Edge Max Length: Maximum possible edge length of the polygons generated by Recast. Edge Max Error: The maximum distance a simplfied contour\u0026rsquo;s border edges should deviate the original raw contour. (Definition from the Recast document) Region Min Size: The minimum number of cells [voxels] allowed to form isolated island areas. (Definition from the Recast document) Region Merge Size: Any regions with a span count smaller than this value will, if possible, be merged with larger regions. (Definition from the Recast document) Detail Sample Distance: Sets the sampling distance to use when generating the detail mesh. (For height detail only.) (Definition from the Recast document) Detail Sample Max Error: The maximum distance the detail mesh surface should deviate from heightfield data. (For height detail only.) (Definition from the Recast document)  Auto Generation Steps  First, fill in the blank fields in the parameters tab. You may prefer to stick to the default parameters as well. Click on the \u0026ldquo;Auto Generate\u0026rdquo; button (generation tools) and wait for the operation to end. Click on the \u0026ldquo;Make Quads When Possible\u0026rdquo; button (generation tools) to quadify the triangles which form a convex shape. Click on the \u0026ldquo;Find Tight Faces\u0026rdquo; button (debugging tools) to find and select the tight faces on the borders. Press the \u0026ldquo;Delete\u0026rdquo; button on the keyboard to delete these selected faces. If there are still tight faces appearing on the borders, apply the same procedure until it all ends. Click on the \u0026ldquo;Remove Unused Vertices\u0026rdquo; button (debugging tools) to remove vertices which are no longer connected to any face. Manually correct the regions which are broken due to the removed tight faces. You can debug and polish further using the tools mentioned before.  "
},
{
	"uri": "http://localhost:4444/zh_cn/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/alignment_and_snapping/",
	"title": "Alignment and Snapping Tools",
	"tags": [],
	"description": "",
	"content": "Pivot Alignment Tool The Pivot alignment toolapplies the chosen transform values of one entity to another entity. The tool makes it easier for users to create overlapping or precisely aligned entities. If an entitity is selected in the editor, the user can set up the alignment tool by pressing Alt + A.This will register the currently selected entity as the input entity. Selecting a second entity with the left mouse button, will then open the interface screen of the alignment tool.\n Translation checkboxeswill translate first entity on the given axis/axes. Rotation checkboxeswill rotate the first entity without breaking the local scale. Up, side and forward vectors will be aligned depending on the checkboxes. If the scale checkboxesare checked, first entity’s scale component of the selected axis or axes will be set as second entity’s scale value which is shown at the inspector. If checkboxes are unchecked, first entity will be transformed to its initial frame. Align by Pivotbutton will apply the alignment depending on the active checkboxes and close the interface. Revert and Closebutton will transform the entity to its initial frame and revert any transform operation applied to pivot.  Example Usage Surface Snapping Feature The Surface Snapping Featureallows a user to snap an entity\u0026rsquo;s pivot to the surface of another entity. Holding down the I hot-keycontinuously snaps the pivot of the currently selected entity to a surface that the mouse cursor intersects with. Control + Zreverts the transformation. This feature aligns the entity’s local y vector with the intersection point’s normal map, so it won’t require the user to make additional adjustments to align the entity with the surface.\nBeware that this will lead to clipping, if the pivot of the entity that you seek to snap to a surface is not located on its own surface.\nExample Usage Vertex Snapping Feature The Vertex snapping featureallows users to choose any vertex from a selected entity and place that vertex in the same position as any vertex from another entity of their choosing.\nAlt + Vactivates and deactivates the vertex snapping feature. It only becomes active if an entity has been selected in the editor. There is a button on the editor toolbar as well, which acts like the hot-key.\nAfter activating the tool and while the left mouse button is in a “down” state, the chosen entity’s selected vertex will continuously snap to the vertex of another, highlighted entity that is closest to the mouse ray’s intersection point. If the distance between the intersection point and the closest vertex is bigger than 2.0f or there is no second entity highlighted, nothing will happen.\nAlso, a yellow sphere will be rendered on the vertex to provide head-up display. Thus, user can choose any vertex by moving the mouse. This will be the first vertex. Also, sphere is scaled with respect to camera position’s distance.\nAfter deciding on the first vertex, the snap operation can be done by holding down the left mouse buttonand moving the mouse.\nExample Usage If user releases the left mouse button when the line’s color is green, the snap will be successful. If user releases the left mouse button when the line’s color is yellow, there won’t be any snap and entity will be translated to its initial frame.\nAxis Constraints When snap tool is active, you will see a gizmo on top of the nearest vertex. You can use axes of this gizmo to constraint axial movement or drag from middle to snap freely.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/cloth_simulation/",
	"title": "Cloth Simulation",
	"tags": [],
	"description": "",
	"content": "Preparing Mesh Cloth simulation system uses alpha channels of vertices of meshes. Values in the alpha channel represents how much a vertex can move away from its original position. 0.1 of alpha means vertex can be moved 0.1 units from its original position by cloth simulation. If you set zero to alpha value that means that vertex will be fixed to its position and will not be updated by simulation.\n   Shaded Vertex Alpha          Black parts are driven by skinning system while white parts are simulated. It is worth to mention that skinning calculations are done for all vertices whether they are fixed or not. Positions of skinned vertices are used as anchor points for simulated vertices. You can imagine that a simulated vertex can only move inside a sphere with radius R and center C. Here alpha channel of the vertex color is used as radius and skinned position is used as center.\n   Shaded Vertex Alpha          Simulation Types Direct simulation In direct simulation, vertices of rendered mesh are simulated directly by cloth simulation. This technique can be used for meshes with simple topology(like grid) and small amount of vertices. As the number of vertices increases performance hit of simulation will be greater.\nMapped simulation In some cases, your mesh may not be suitable for cloth simulation. Some examples are armors with double sided polygons, clothes with more than one layer or meshes with high numbers of polygons. For such cases a separate mesh can be used for simulation. If a separate simulation mesh is used vertices of this mesh are simulated by cloth simulation. Vertices of original mesh will be mapped to simulated mesh and move with them.\nIn the above images, meshes on the right side are used for simulation and the left ones are rendered according to simulated results. To achieve realistic results, your simulation mesh should tightly map to render mesh and it must never cover it. In other words, render mesh should never penetrate to simulation mesh. If it does, since collision calculations are done for simulation mesh you may see collision artifacts like penetrating leg to armor.\nCloth Editor To enable cloth simulation for a mesh some ingame settings must be adjusted. Cloth editor is used to setup a mesh for simulation. Cloth editor can be opened from toolbar menu in editor.\nPreview properties Preview mesh To start working with a mesh you should select it from Preview mesh menu and select the sub meshes which will be simulated from Render mesh cloth properties panel. If alpha channels of mesh painted properly it should start to be simulated on the preview window.\nSimulation mesh If you want to use a separate simulation mesh, select it from Simulation mesh menu. Alpha channel of this mesh must also be painted because it is the actual mesh being simulated. In this case alpha channel of preview mesh is used to determine if a vertex will be mapped to the simulation mesh or it will be rendered with original skinning data. Alpha values greater than zero means that vertex must be mapped to simulation mesh. Vertices with zero alpha values will use the original skinning data. Since simulation mesh has less polygon count than the original mesh, this can be used to increase skinning quality of original mesh for non-simulated parts.\nHelper mesh You can select a helper mesh to preview your actual simulation mesh with an arbitrary mesh. Selecting a horse mesh for a simulated mane mesh is a good example.\nPreview skeleton If you want to work on a skinned mesh and preview collision capsules and animations, you should select corresponding skeleton.\nPreview body You can assign an existing collision body to your Preview mesh with Preview body menu. Modification of collision bodies can be done from Cloth Bodies panel.\nPreview animation name You can test your cloth with an animation. You must write its name in asset folder, not the one in animations*.xml and its start and end frame numbers and duration. You can start and stop animation with Toggle Animation button.\nScene update coef Slow motion can be simulated by decreasing this value. Default value is 1 which means all simulations are done normally.\nRender mesh cloth properties You can select which submeshes will be simulated by checking checkbox next to each submesh. Different cloth materials can be assigned to each submesh by Cloth material column. Max distance multiplier is used to scale vertex color paintings of mesh which controls how much a vertex can move away from its original position. 0.5 value of vertex alpha with 3.0 max distance multiplier value means that, that vertex can move 1.5 units away from its original position. \\\nIf you are using a separate simulation mesh, max distance value and cloth material of simulation mesh overrides these settings. All submeshes will use same cloth material assigned to simulation mesh.\nSimulation mesh cloth properties If you use a separate simulation mesh, you can adjust its settings from here just like render mesh properties mentioned above. Cloth material and max distance value selected here will be used for all sub meshes of render mesh.\nCollision Bodies Collision presets can be created and modified from Collision bodieswindow. You can open Collision bodieswindow from Edit \u0026gt; Edit collision bodiesmenu. A capsule consists of two end points. These points can be skinned to a skeleton separately by assigning owner bones and weights. One capsule point can be skinned to at most two bones. Like mesh skinning, weights are used to determine influence of that bone on the selected capsule.\nCloth materials All simulation parameters to customize cloth behaviour is supplied with cloth materials. Cloth material presets can be created and modified from Material templateswindow. You can open this window from Edit \u0026gt; Edit merial templatesmenu. Materials shown in this windows are presets so changing these presets does not affect configurations of existing cloth meshes. To change parameters of an existing cloth mesh, you can click Change parametersbutton in Simulation/Render mesh properties panel and adjust each settings in Mesh specific parameterswindow. Current parameters are as follows:\nBending, Stretching, Shearing, Stiffness Determines how much a fabric constraint will resist to the corresponding case.\nAnchor Stiffness This constraint strictly limits the freedom of a vertex. It tries to keep distances constant between simulated and fixed vertices. You can try to increase this value if your mesh stretches too much.\nDamping Dampening values for vertices. Determines the fraction of current frame\u0026rsquo;s velocity to transfer to the next frame.\nLinear Inertia Since our cloth simulation is done in local space, global frame changes are transferred to cloth virtually. This value determines how much of acceleration of entity will be transferred to cloth. You can test this by adding a cloth mesh into a scene and shake its entity randomly.\nAir drag For a cloth mesh moving with a constant velocity this value determines how much air force will affect its vertices.\nWind You can control how much wind force the cloth will use. This value is a multiplier for actual wind force of scene. If there is no wind in the scene increasing this value has no effect.\nGravity Constant gravity force affecting each simulated vertex. You can decrease this value to achieve a silky cloth behaviour.\nIteration Frequency How many times a cloth mesh will be simulated in a second. You can leave this parameter with its default value unless your mesh has big triangles or it moves so fast that collision capsules can not catch simulated vertices. Increasing this value results in more stable collision behaviour but performance hit also increases linearly.\nPrecise Simulation We trade accuracy with performance by doing some compressions during simulation. As a result simulated mesh might move to a different state than its rest state slightly. If this accuracy is important for your mesh, you can enable this option to get more correct results.\nDummy Collision Particles If simulated mesh has big triangle sizes with respect to collision capsules, capsules may not collide with cloth mesh properly. To overcome this we place dummy vertices in every triangle of mesh. These vertices are not simulated but only used during collision stage. This option has big performance hit so you should avoid enabling this as much as possible.\nCloth Content Files Our simulation system generates two files with *.tccand *.tcmextensions. Tcc files contains preprocessed data used by cloth simulation like constraint indices, constraint lengths etc. Tcm files contains mapping data of a render mesh to a simulation mesh. You must commit both these files to Plastic SCM to ensure that nobody will wait for cooking process to complete during scene loading stage.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/bannerlord_destructible_component/",
	"title": "Destructible Component",
	"tags": [],
	"description": "",
	"content": "The destruction system which gives artists a lot more freedom is explained below.\nCharacteristics It is a ScriptComponent which can be applied to any entity in a scene, as long as that entity has a collision body.\nWhen not given any information, the script will just make the entity disappear after being destroyed. It will also re-appear when the mission resets.\nThe script can be used to destroy entities in one or more states, with optional sound, particles and dynamic objects spawning in each state.\nAny existing prefab that has a DestructibleComponent script (Siege towers, gates, ballistas, ..) will continue to work even when you remove that script. It will only no longer be destructible.\nOne entity can have multiple DestructibleComponent scripts. E.g. the battering ram is destructible, but it also has individual rooftiles which can be destroyed too. Any damage that is applied to a child will also be applied to the parent(s).\nDestroyed prefabs can always be tweaked and improved later without breaking any scenes, because they are not part of the intact entity (They are spawned at runtime).\n   Example Script of Siege Tower        DestructionStates, can be one or more prefabs. Seperated by \u0026ldquo;,\u0026rdquo; (comma).   DestroyedByStoneOnly, True means that only projectiles from mangonels or trebuchets can damage this entity. False means anything can damage this entity.   CanBeDestroyedInititally, defines if this entity can be destroyed already when loading the scene. This is controlled from the campaign map based on a destruction percentage from bombardements. This is generally only true on wall merlons. But it can also be used on aesthetic entities to make the scene look more destroyed from the start. Entities to be destroyed are selected randomly.   MaxHitPoint are the starting hitpoints from this entity. Every time the mission resets, the entity will also have its current hitpoints set back to the MaxHitPoints.   ReferenceEntityTag is an optional tag for when a DestructionState prefab has a different frame than its parent or to copy animation states. You can add an extra entity (under the entity with the DestructibleComponent script) with a correct frame and supply it with a reference tag, so that the spawned DestructionState prefab will use that frame. If there is no ReferenceEntity, the frame of the entity with the DestructibleComponent script will be used. Reference entity can also be used in special scenarios like a castlegate (opening/closing animations), to get the animation state from the reference entity and apply it to the newly spawned damaged entity.   OriginalStateTag is only required when you have multiple DestructionStates. Usually, when an entity is destroyed, we hide the entity which has the script component applied, and spawn a new entity from the DestructionState (without a parent). But for some entities (like gates), we do not want to hide the entire entity because it has to keep functioning as a gate until it is fully destroyed. Using the OriginalStateTag, we will only hide the entity which has this tag applied, and the rest of the hierarchy (particles, standing points, ..) will still be visible. Any DestructibleComponent that has more than one destructionState will spawn the damaged prefabs as child entities.   HeavyHitParticlesTag is a tag which can be applied to any child-entities that have a particle-system. These particles will burst once, when a certain amount of damage is taken in a single blow. This particle system is generally shared between all destruction states (It\u0026rsquo;s not part of the entities that get hidden/spawned).   HeavyHitParticlesThreshold is the minimum damage that is required to be taken in a single blow, to trigger particles with HeavyHitParticlesTag tag.    Effects Generally, we try to keep the spawned prefabs as small as possible for performance reasons, and also to avoid entity duplication. You have access to the following functionality to add effects:\n On the damaged prefab, when spawned: All particle systems on every entity in the hierarchy, will automatically be bursted once. On the damaged prefab, when spawned: All dynamic bodies on every entity in the hierarchy, will automatically receive the impulse from the last hit that destroyed the previous state. On the damaged prefab, when spawned: All other meshes on every entity in the hierarchy, will remain in place if they have no dynamic body-flag. Part of the entity hierarchy: Heavy hit particles have to be shared between all destruction states, and are played whenever the DestructibleComponent takes HeavyHitParticlesThreshold damage. You can play custom animations on DestructibleComponents that have a skeleton (e.g. castlegate being hit by battering ram). The animation progress will transfer to the newly spawned damaged entities. You can add a script of type AmbientSoundEmitter on a damaged prefab and provide the sound event. It will automatically play when the entity is spawned. Apart from using multiple states, you can also add multiple child entities with DestructibleComponents (e.g. battering ram rooftiles which are individually destructible). Keep in mind that any damage that is applied to a child DestructibleComponent is also applied to every parent in the hierarchy. Currently, we don\u0026rsquo;t know the performance implications of having too many of these.  Examples Example 1: Wall with breakable merlons For walls, we can only destroy the merlons and nothing else. They can only be damaged by mangonels/trebuchets and they will only take one hit before being destroyed.\n   Hierarchy of WallSegment     This is what our scene hierarchy looks like for a single wall piece. European_castle_wall_a_l3 is an entity with script WallSegment. It does not care if it has destructible children or not. Every merlon is a different child-entity that has its own DestructibleComponent script. Once they are destroyed, they all spawn the same destroyed prefab. Every merlon has a debris_holder entity, which is an empty entity. It just hold a ReferenceEntityTag tag, and the correct frame to spawn the destroyed prefab from (Important because of mesh bending: Location and rotation may change compared to the parent).       Script example of a single merlon     Every merlon has the exact same script. They will all spawn the \u0026ldquo;debris\u0026rdquo; prefab when destroyed. We decided to make them destroy after a single hit from a mangonel, so they have very low hitpoints. DestroyedByStoneOnly makes them ignore damage from all other weapons (arrows, swords, axes, ..). Because of CanBeDestroyedInititally, these merlons have a chance to already be broken when entering the mission. The merlons need a ReferenceEntity entity to determine the spawn frame for the broken prefabs.    Origin of wall and merlon pieces\n          Each merlon is a unique mesh, which has its origin point at the bottom of the wall (same as the wall).    Every merlon shares the same destroyed prefab, which has a local origin. debris_holder has a ReferenceEntityTag.    Every child of the debris prefab is an entity with flag \u0026ldquo;dynamic\u0026rdquo; and has a collision body. When spawned, it will automatically receive the last impulse that the DestructibleComponent received when destroyed.    Example 2: Siege Barricade Siege barricades are very simple objects. They are static entities and their only function is to block incoming projectiles. However, they can be destroyed in multiple stages. Each stage looking more destroyed than the one before.\n   The different destruction states of a siege barricade     Currently, the different states do not have any special particles or dynamic entities, but they can easily be added later on. Entities with the \u0026ldquo;dynamic\u0026rdquo; body flag, and particle systems will automatically trigger when spawned.       Hierarchy of siege barricade in scene Siege Barricade script component          siege_barricade_a is an empty parent. It just holds the script. siege_barricade_a_state1 is the actual mesh + body and has the \u0026ldquo;original_state\u0026rdquo; tag. When the barricade takes enough damage, siege_barricade_a_state1 will be made invisible, the next damaged prefab will be spawned and added to siege_barricade_a as a child. This is important because the DestructibleComponent needs to be informed of hits, and it can only do that if it has a (visible) collision body on itself or on a child.\nthe last state (state_5 in this case) will be spawned when the entity has 0 health (fully destroyed). The other ones will be used in between MaxHitPoints and 0.\nWhen the mission is reset (Health is reset to MaxHitPoint), the original entity (entity with tag \u0026ldquo;original_state\u0026rdquo;) will be made visible again.\nEvery DestructionState prefab has the same origin and rotation, so we don\u0026rsquo;t have to use a ReferenceEntity.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/distance_tool/",
	"title": "Distance Tool",
	"tags": [],
	"description": "",
	"content": "Distance Measure Tool The Distance Toolmeasures the distance between two points in the scene. Distance measure mode can be activated by either pressing Alt + Dshortcut or the respective button on the editor toolbar.\nWhile holding the left mouse button, drag the mouse between two points in the scene to measure distance. The tool snaps to vertices if close enough to a one by default, holding down Left Shiftoverrides this.\nThe tool can be de-activated by pressing Alt + Dor the respective button on the editor toolbar again. For further use, the gizmos stay visible even after the tool is de-activated. Pressing Alt + Shift + Dclears these gizmos from the screen.\n Green lineshows the actual distance between points. Blue linesshow the lateral and longtidunal distances. Yellow circledepicts the range.  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/meta_mesh_editor/",
	"title": "Meta Mesh Editor",
	"tags": [],
	"description": "",
	"content": "Import Settings  Divide Into Grid: Divides the meta mesh into grids, and adds all the generated section meshes to the submeshes. Remove Redundant Vertices: The name implies what it does. Recompute Normals: While importing the meta mesh, computes normal vectors for all sub-meshes instead of importing them as well. Normal Computation: Decides whether the normal vector computation will depend on the face area (weighted) or not (default). Recompute Tangents: While importing the meta mesh, computes the tangent vectors for all sub-meshes instead of importing them as well. Whiten: Linear interpolation amount between the vertex color and white per each color channel.  Lod Meshes  All the active sub-meshes of the meta mesh can be seen here. The material properties, mesh parameters and tags can be changed via the interface.  Unused Meshes  This shows the activity situation of the sub-meshes. If the ignore checkbox is checked, this means that the corresponding sub-mesh is inactive. After changing status of the lod meshes, please press \u0026ldquo;Apply Ignores\u0026rdquo; button for your changes to take place and be saved.  Save  Saves all the changes done to the meta mesh.  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/model_viewer/",
	"title": "Model Viewer",
	"tags": [],
	"description": "",
	"content": " The Model Viewer can be accesed from; Editor \u0026gt;Window \u0026gt;Show Model Viewer From the left panel, you can change Atmosphere, hide/show ground, or add as many entities as you want. The entities can either be Humanor simple Mesh.Pressing Add Entitywill open a modal window for you to select the entity type. Transform From this panel, you can set entities Tranform, Rotation, and Scale.\nAnimation From this panel, you can choose Skeleton type, and Animation. \\\nYou can also filter animations by their name. \\\nFiltering system is quite strong through all the engine, so you can fine tune your filtering. Some examples; \\\nidle = Will filter animations that contains \u0026ldquo;idle\u0026rdquo; \\\n.idle = Will filter animations that starts with \u0026ldquo;idle\u0026rdquo; \\\nidle. = Will filter animations that ends with \u0026ldquo;idle\u0026rdquo; \\\n-idle = Will filter animations that does not contain \u0026ldquo;idle\u0026rdquo; \\\n\u0026mdash; You can also use combinations of those filters by putting a space between them \\\n\u0026ldquo;idle -barmaid 2.\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, and does not contains \u0026ldquo;barmaid\u0026rdquo;, and ends with \u0026ldquo;2\u0026rdquo;. (like \u0026ldquo;guard_idle_2\u0026rdquo; which fits this condition) \\\n\u0026ldquo;idle hangout 7\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, \u0026ldquo;hangout\u0026rdquo;, and \u0026ldquo;7\u0026rdquo;. (like \u0026ldquo;anim_hangout_idle_7\u0026rdquo; which fits this condition)\n\u0026mdash; You can also blend an another animation using the blend panel.\nVisuals From this panel, you can put any mesh at any part of the human, and you can choose this humans gender.\nSave / Load scene You can also Save / Load the current working scene, by clicking; File \u0026gt;Save Scene \u0026gt;..Save Name.. \\\nThen you can load it with; File \u0026gt;Load Saved Scene \u0026gt;..Write Saved Name.. \\\nWhich will restore everyting to the state where you saved it.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/prt/",
	"title": "Precomputed Radiance Transfer - GI System",
	"tags": [],
	"description": "",
	"content": "We introduce a new global illumination system to the engine. It is based on a pre-baked system called \u0026ldquo;Precomputed Radiance Transfer\u0026rdquo;. This technique allow us to bake the local ambient in the scene and display it in an optimized manner at runtime. Baked data is independent from the atmospheres. Thus, we can light the scene with the same bake data for every atmosphere.\n   With Without          Baking Procedure Scene baking is divided into a couple of parts:\n First, the artist should place the border probes to identify the GI boundaries of the scene.  Side Note 1: If you minimize the GI boundaries as much as possible(not extending it to distant places from navigatable area) , you can decrease the grid dimensions and thus you will have more precision inside the town where it matters the most. For town scenes, we generally use grid dimensions of 1.5 meters width and 2.5 meters height.\nSide Note 2: For the pixels outside the GI borders, we use a fallback probe from the scene. The default is the highest active probe near to the left corner of the GI order. Artist can select any other probe from the scene by first selecting probe and checking the \u0026ldquo;Fallback Probe\u0026rdquo; checkbox in the UI.\n AT the next pass, the GI probes are created. The initial positions of the probes computed automatically by using the navigation mesh of the scene. With the navigation mesh, we place the probes where the agents can move and also to everywhere visible from those navigation points. The probes are generated within a 3d grid structure. A directional ambient data is computed for every probe position. Using these ambient light values, every pixel in the screen is illuminated by the nearest 8 probes. In some cases, when the lighting between neighbour probes have a very high difference, light or shadow leaking can occur. In order to fix these issues, we render shadowmaps from the probes just like point lights. Probes with shadowmaps are named as \u0026ldquo;Visibility Probes\u0026rdquo;. For memory usage issues, there is a limit for these Visibility Probes, which is 2048. At the automatic placement phase, the system also tries to find the most probable leak positions and assign those probes as Visibility Probes. It takes into account the ambient light difference. For additional leak fixes, the system leaves the last 5 percent Visibility Probe limit empty, so that the scene designer can fix the remaining leak issues.  PRT Files Just like the scene edit data system, prt data is divided into two parts. prt_data.bin is located inside the SceneObj folder and is the compressed version which is stripped of any editing data. This file should be sent to the source control. The other file is the edit data file. It is very big (at around 2 - 3 gb) and automaticaly sent to the edit data folder inside the network. Once you open a pre-baked scene in editor, only the compressed data is loaded. To be able to edit the bake data, you should Load the edit data with the \u0026lsquo;Load\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nImportant Node : After any changes to the prt data, do not forget to save the data with the \u0026lsquo;Save\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nPRT Operations  Load : Loads the edit data from the server. Save : Saves the current edit data to the server. Auto Height Boundary : Adjusts the PRT boundary probes\u0026rsquo;s height to the min/max of the scene. Bake Single Level : Bakes the scene with the current levels, should be used for the interior scenes Bake All Levels : Bakes the scene with the pre-defined multiple levels(namely level-1/level-2/level-3 and siege/civilian) combinations.  Probe Placement Parameters:  Grid Width : Determines the probe grid cell size in XY plane. For towns, you can use 1.5. For interiors scenes, you can use between 0.5 to 1.0. Grid Height : Determines the probe grid cell height. For towns, you should use a value near 2.5. For interiors scenes, you can use between 0.5 to 1.0.  Selection Tools: To ensure fast and smooth editing of probes, various selection tools are implemented.\n Select All : Selects all probes. Grow : Grows the selection to include neighbour probes in XY plane. Shrink : Shrink the selection to only include the inner neighbour probes in XY plane. Fill : Finds the inner probes of the current selected probe group and selectes them. Select Border : Finds and selects the border probes of the current selection. Select Inner Border : Finds and selects the inner border of the current selection. Select Outer Border : Finds and selects the outer border of the current selection. Lasso Tool : We implemented a screen space lasso tool for easy selection of a group of probes. It can be started by pressing \u0026lsquo;r\u0026rsquo; and finished by either double clik or pressing \u0026lsquo;r\u0026rsquo; again.  Visibility Tools  Show Active Probes : Shows all active probes Show Deactive Probes : Show deactived probes. Show Visibility Probes : Show the Visibility probes (the ones with the visibility calculation to prevent leaking). Level To Show : Selects the Z level to show. -1 means all levels. Show Probe Radius : Determines the probe radius for debug visualization. Box Tool : Enables a mode where you .  Side Not : This system only renders the nearest 100 probes with respect to the camera.\nUseful Shortcuts  Left Ctrl + x: Enable/Disable the selected probes Left Ctrl + c: Toggles the \u0026ldquo;Visibility Probe\u0026rdquo; status Left Alt + Left Mouse Click: Select the probes that influences a pixel (very neat tool for fixing the leak issue, select the pixel and use the toggle visibility status shortcut to fix the issue)  "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/scene_barrier_builder/",
	"title": "Scene Barrier Builder",
	"tags": [],
	"description": "",
	"content": "Introduction Barrier Builder is a tool that helps artist to generate barriers over walls to prevent agents to fall down.\nUsage   Create a path, you can use the button on toolbar   Give a name to path   Build your path as you wish   Press \u0026ldquo;Enable Barrier Build\u0026rdquo; chekbox on path inspector, it will create your barrier entity for you.   You can go to that entity with \u0026ldquo;Go to Entity\u0026rdquo; Button and chnage its options like height, the entity named as \u0026ldquo;path_barrier_PATHNAME\u0026rdquo;\n  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/level_system/",
	"title": "Scene Level System",
	"tags": [],
	"description": "",
	"content": "Level System New level system replaces the old, hardcoded system with a much more extandable and unified system. \\\nAddinga new level (or deletingan existing one) to a scene can be done in Levelspanel under SceneOptionsinspector.\nLevels in Game - Bannerlord - Currently, Bannerlord recognizes a few levels that has a meaning in-game. \\\nWhich are: \\\n level_1 \\ level_2 \\ level_3 \\ siege \\ civilian  Setting Entity visibilities Making an entity only visible in a certain level combinations can be done with selecting an entity then going in Scene Level Visibilitiespanel under Entity Inspector. Select the levels you want this entity to be visible. Entity levels in missions are checked as a whole.Example If you select both level_1 and siege, and if you open a mission that has level_2 and siege, this entity will NOT be visible since it does not has \u0026ldquo;level_2\u0026rdquo;. \\\nIf you select both level_1 and siege, and if you open a mission that has level_1 and civilian, this entity will NOT be visible since it does not has \u0026ldquo;siege\u0026rdquo;. \\\nIt will only and only be visible if you open a mission that has level_1 and siege.\nSo if you want an entity to be visible in both level_1 and level_2 and only in civilian mission, select level_1, level_2, and civilian; \\\nso this entity will not be visible in ANY siege missions, and will not be visible in ANY mission as level_3.\nTesting visibility in editor There are two options to see entities with different level visibilities.\n1) Require all levels (Same as missions) \\\n2) Require at least one level (Editor only, to see all entities at once)\nRequire all levels In this mode, visibility system will work as same as the missions, you can use this mode to test what entities will be visible in what combinations. \\\nIf you select level_1 and siege, you will only see entities that has both level_1 and siege, not the others.\nRequire at least one level This is an editor only mode, if you select a level, it will be visible, no matter what combinations that entity has; if entity has that level, it will be visible. \\\nCan be useful if you want to see all civilian entities no matter what level they are, or you can see level_1 entites no matter if they are siege or civilian.\nTesting a scene For this purpose, Start mission as window modified in a way that allows you to select level combinations. If you want to test a castle scene with level_1 and siege mode, Select these leves and press OK. The mission will start in Level 1 Siege mode.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/scene_spawn_points_guide/",
	"title": "Scene Spawn Point Guide",
	"tags": [],
	"description": "",
	"content": "How to design fully featured scenes in Bannerlord Each scene has own basic necessities to run without crashing and has extras to give better experience to player. Designers can check these necessities with \u0026ldquo;Spawn Point Debug Tool\u0026rdquo; to be sure that their scene will not crash.\n1. Town Center Scene Player will be spawned on the \u0026ldquo;sp_player_outside\u0026rdquo; prefab if he/she is entering the city for the first time, because of this feature \u0026ldquo;sp_player_outside\u0026rdquo; must be placed far from city\u0026rsquo;s entrance; otherwise player will be spawned on \u0026ldquo;sp_player\u0026rdquo; and this spawnpoint can be next to the entrance gate. Town center scene has some mandatory characters as follows:\n   Player Spawn Point     When player enters the town center from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than 1 in order increase variation. The scale of the conversation prefab must not change.       Traders     Traders such as armorers, blacksmiths and horse merchants are mandatory for town center scenes. If scene has more than one market place, it is ok to have more then one trader NPCs. Traders in market places may have their own sets. These sets can be considered as prefabs with some spawn points in it. For example, for weaponsmith there can be 3 points in weaponsmith set but there must be 1 spawned weaponsmith. This NPC will go to these points randomly, in a word NPC may go to his/her selling table and start trading or go to the backside of his/her shop and sit on a chair for some time. Designer may want to change these wait times between actions with \u0026ldquo;MinWaitInSeconds\u0026rdquo; and \u0026ldquo;MaxWaitInSeconds\u0026rdquo; parameters. (-1: forever).       Notables    Notable Parent Prefab Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city. Every notable have their own spawn point tag and every notable have their unique helper characters.\n   Notable Spawn Point Tag Helper Character Tag     Preacher sp_notable_preacher sp_preacher_notary   Gang Leader sp_notable_gangleader sp_gangleader_bodyguard   Rural Notable sp_notable_rural_notable sp_rural_notable_notary   Artisan sp_notable_artisan sp_artisan_notary   Merchant sp_notable_merchant sp_merchant_notary    Notables have one parent prefab named \u0026ldquo;sp_notables_parent\u0026rdquo;. Each notable has 1 set as child so, parent prefab has 5 child notable sets.\nArtists must place this parent prefab and put it in a prominent place of town center. Also prefab must be seen easily by player. After mission start, game logic will activate the notable set according to the notables in the town center.\nIn the notable sets, every notable will have unique helper character and their spawn point as well. (bodyguards for gangleader, notary for merchant\u0026hellip;).\nIn the picture below. There were 2 parent prefabs in the scene. After mission start, one prefab is activated for gangleader and her bodyguards. Other prefab is activated for merchant and his notary.\n   Guards     There are some idle guards and patrolling guards. Patrolling guards are programmed as moving one point to another while activating the next point and deactivating the current one.       Passages     Town center scene must include all passages to other scenes such as Tavern, Arena, Lords hall\u0026hellip;       Battle Sets     For town scenes, battle sets are only used for common area clearing. so they should not be too far apart, and should be placed to represent a fight between gangs rather than a battle between armies.       Townsfolk     NPCs are always moving around the city. In order to prettify the scene, designer may want to use some extra prefabs. If scene has \u0026ldquo;sp_npc_repair_set\u0026rdquo;, one NPC will go to that point and start hammering away while other NPC complains about the situation or scene may have some beggars begging for townsfolk help.    2. Tavern Scene    Player Spawn Point     Spawnpoint for player, \u0026ldquo;sp_player\u0026rdquo;, must be placed nearby to the town center passage. Scene must include at least one \u0026ldquo;sp_player_conversation\u0026rdquo; prefab or more. The scale of the conversation prefab must not change.       Game Hosts (Gambler NPCs)     Each tavern scene must have gambler (game host) NPC. The chair underneath NPC must have \u0026ldquo;gambler_npc\u0026rdquo; and \u0026ldquo;npc_wait\u0026rdquo; tags both. The chair which player will use to join game must have \u0026ldquo;gambler_player\u0026rdquo; and \u0026ldquo;reserved\u0026rdquo; tags both.    3. Lords Hall Scene    Player Spawn Point     Player spawn points for Lords Hall scene is as same as Tavern scene. Spawn point for player must be placed nearby to the town center passage.    4. Village Scene    Player Spawn Point     Village scene don\u0026rsquo;t have \u0026ldquo;sp_player_outside\u0026rdquo; prefab. \u0026ldquo;sp_player\u0026rdquo; prefab must not be placed far from village center nor very near. When spawned, player must see the walking villagers from afar. When player enters the village from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than one in order to increase variation. The scale of the conversation prefab must not change.       Notables     Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city.       Villagers     Villagers have lots of extra activities in village center such as collecting grapes, repairing something or grooming horse. The activities must be balanced between physical and social activities. Villager NPC may go and clean walls then sit and chat with others.       Common areas     Each village has 3 common areas which are not in the village center. Any type of spawn points can be used inside of the common area. \u0026ldquo;common_area_NUMBER\u0026rdquo; prefabs should be placed to specify the area. This prefabs has a script attached named \u0026ldquo;CommonAreaScript\u0026rdquo;. The script has some parameters as follows:   AreaRadius : Artist can change this parameter script to extend or reduce the area.   AreaIndex : Already set in prefabs for three common areas   Type : Type of the area should be set from the list below       Area Types Scene Explanation     Backstreet Town Center Back alley where thugs are spawned   Clearing Town Center Open area   Waterfront Town Center Near coast or port   Pasture Village Pasture, forage (usually a heath or moor)   Thicket Village Shrubbery   Bog Village Swampy area   Forest Village Lots of trees   Ravine Village Valley or canyon   Spring Village Puddle in desert   Cove Village Bay   Marsh Village Swampy area near river   Wadi Village Valley, does not have rocks on both sides       Battle Spawnpoints     If game is opening the scene with battle mode. Battle sets will be initiated and battle troops will be spawned on each. Battle sets must be placed far from each other, and with defender and attacker sides in mind.    "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/callbacks/",
	"title": "Script Component Callbacks",
	"tags": [],
	"description": "",
	"content": "The callbacks of the script components are listed below.\nConstructor In constructor one needs to assign default values to its public variables(variables which can be changed by the scene maker). In constructor script component is not assigned to an entity or scene. Also, you should not write any logic that has any side effect because , even though it is created, the script component may be deleted once the scene is opened because of the upgrade level system.\nOn Pre Init This is called after the script component is assigned to its owner entity in the scene. Once you are in this callback , you can be sure that the user defined variables from that script instance are set. However, the other script components of the other entities may not be assigned yet. Thus, in pre init there should not be any logic code that relies on other script components. Example, in pre-init ManagedObject registers himself to the managed object array in the current mission instance.\nOn Init This is called once the mission is loaded and all of the script components of the entities are initialized. You can use any type of logic code inside this callback. Run time instantiated scripts also get this callback called.\nOn Editor Init Editor version of on init. It is called when the scene is loaded from the editor. Beware that there is no mission or game state in editor.\nOn Tick This is called for every script component every frame on mission from the same thread.\nOn Editor Tick Editor version of on tick.\nIs Only Visual If you have a script component which is only visual and does not have any logic code that should be running in the dedicated server , you should return true in this function. This ensures that this type of scripts does not run on dedicated server.\nOn Editor Variable Changed This is called in editor whenever a public variable in that script component is changed by the user. This callback can be used for any visual-logic state change if the artist needs instant feedback on the editor scene.\nOnRemoved Called when the entity or the script component is being removed. If you have any allocated objects which are stored in somewhere else (for example static containers), you can use this callback to ensure that they are not leaked.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/spawn_point_debug_tool/",
	"title": "Spawn Point Debug Tool",
	"tags": [],
	"description": "",
	"content": "Introduction The tool which has prefab named \u0026ldquo;SpawnPointDebugView\u0026rdquo; can be added to scene. Prefab has \u0026ldquo;SpawnPointDebugView\u0026rdquo; script attached and tool can be opened through inspector toggle. Tool has 3 tabs named \u0026ldquo;Scene basic information tab\u0026rdquo;, \u0026ldquo;Scene entity check tab\u0026rdquo; and \u0026ldquo;Navigation mesh check tab\u0026rdquo;.\n1. Scene Basic Information Tab This tab tries to determine the scene type in order to find necessities; if detected type is not correct, artist can override the type using toggle buttons below.\n2. Scene Entity Check Tab This tab calculates the spawn point count and warns artist if counts are not in the scene criteria. Clicking the \u0026ldquo;Count Entities\u0026rdquo; button and toggling the categories will fill the table of calculations. \u0026ldquo;DONT USE\u0026rdquo; toggle stands for outdated entities which scene must not include. Last column of table shows how many agent will be spawned on current spawn points.\nAt the end of each row there is a button which can list all game prefabs with clicked button\u0026rsquo;s tag. Clicking the button will open a new window that list all prefabs with particular tag.\n3. Navigation Mesh Check Tab This tool will mark the spawn points which are not on the navigation mesh or on the navigation mesh that will be deactivated by \u0026lsquo;Navigation Mesh Deactivator\u0026rsquo;. If scene does not have \u0026lsquo;Navigation Mesh Deactivator\u0026rsquo;, Deactivation face id will be 0 and scene entity check tab will warn artist to place it in scene. Clicking \u0026ldquo;CHECK\u0026rdquo; button and toggling the categories will show debug lines on the invalid spawn points with category color. Navigation Mesh Check tool shows the spawn points according to scene level. Each toggle will activate 2 buttons named \u0026ldquo;Previous\u0026rdquo; and \u0026ldquo;Next\u0026rdquo;. Clicking these buttons will make editor camera to focus on the misplaced spawn points one by one.\nThis tab can also checks points that are out of mission bound but this feature is only working in missions.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_mesh_blend/",
	"title": "Terrain Mesh Blend System",
	"tags": [],
	"description": "",
	"content": "We introduce a new terrain mesh blending system. Certain terrain layers can blend into chosen meshes. Blend height, smoothness and random height offsets can be changed. These values can be saved to prefabs and can also be changed in scene per mesh. Heightmap blending can also be used to change the blending behaviour with respect to the mesh\u0026rsquo;s heightmap.\n   With Blending Without Blending          Terrain Layer Restrictions Terrain layers should satisfy some restrictions before they are eligible to be a mesh blend layer.\n Diffuse texture should have (2048 , 2048) dimensions and have a DXT1 format(without alpha). Normal texture should have (2048 , 2048) dimensions and have a BC5 format. Specular texture should have (2048 , 2048) dimensions and have a DXT1 format. Layer should not have \u0026lsquo;diffuse alpha\u0026rsquo; or \u0026lsquo;ground slope\u0026rsquo; flags enabled.  Material Properties The mesh should have a material with shader \u0026ldquo;terrain_mesh_blend_shader\u0026rdquo;. To enable heightmap blending, one should assign an heightmap texture and enable the shader flag \u0026ldquo;\u0026rdquo;.\nMesh Properties One can change the mesh\u0026rsquo;s properties from the Components/Mesh/Vector Arguments windows in Entity Inspector.\n Blend Height Threshold : Maximum distance for terrain blend Blend Smoothness : Higher means more smooth transitions Random Amount : Blend height threshold can be incresed or decreased with this value with respect to the position of pixel Random Tile : Adjusts the tile of the random heightmap adjustment Heightmap Factor : Controls the heightmap factor of the mesh. More means less blending in the higher parts of the heightmap.  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/mipmap_editor/",
	"title": "Texture Editor",
	"tags": [],
	"description": "",
	"content": " The Texture Editor can be accesed from; Editor \u0026gt;Window \u0026gt;Show Resource Browser \u0026gt;..Search for Texture.. \u0026gt;..Double Click on Texture.. From the Texture Inspector (Right Panel), you can enable/disable MipMap blending by toggling Use Mipmap Blendingcheckbox. When you enable MipMap Blending, you will see all mip levels of the selected texture next to each other in Preview Window. Clicking on MipMap Blend Amountswill open open a new window where you can adjust blend amounts for every mip level. Then you can select MipMap Blend Color (1)and click Recompile (2)button to apply blending. The result will be immediately visible in Preview Window and also in Game. "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/mass_selection/",
	"title": "群体选择",
	"tags": [],
	"description": "",
	"content": "群体选择 (Mass Selection) 允许你选中多个游戏中的物品 (Objects)，并且进行旋转等操作。你可以重新放置，或者是平移、旋转和缩放有 mass_selection 属性的实体。\n包围盒限制 (Bounding Box Constraint) 属性允许你选中有比这个属性更小值的物品。\n   定位选中框 选中之后 随机旋转之后           "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_resize/",
	"title": "调整地形大小",
	"tags": [],
	"description": "",
	"content": "调整地形大小 如果需要，地形节点数量可以在 Terrain Inspector的 Resize Terrain面板调整。\n 你可以从 4 个方向添加新的节点或移除已有的节点。+X, +Y, -X, -Y（分别是南，东，北，西）（上色和 Gizmo 一致） 添加和移除节点会自动重新在新的位置分配现存的实体 (entities) 和植物 (floras)。新的节点由于他们的高度信息还未定义，可能会显得无法和其他地形连接。设计者应该可以用编辑器内置的高度笔刷 (Height Brushes) 来修改，或者导出高度图在其他高度图生成软件中修改，之后在导入回编辑器中。 如果在地形的一边输入正数，那么地形像那一边扩展那么多的节点。如果你往每一边写了 +2，那么地形就会像每一边扩展 2 格。如果你写了 +3 在 +X 方向，其他方向为 0 那么地形只会往 +X 方向扩展 3 格。 如果你输入一个负数，那么将会减少相应的节点数。 如果你输入 0（默认值），那么将不会有改变。     添加 删除          "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-browser/filterqueries/",
	"title": "过滤器查询",
	"tags": [],
	"description": "",
	"content": " 你可以使用 SQL 语法 查询资产 (assets) 中特定的属性 (properties)，比如查找分辨率大于 1024 的纹理 (Textures)。你可以在额外菜单 (extras menu) 中使用查询模式：\n从右边栏的纹理检查器 (Texture Inspector)中，你可以通过勾选 Use Mipmap Blending来启用/禁用 混合纹理映射。 当你启用 混合纹理映射 (MipMap Blending) 的时候，你可以在预览界面 (Preview Window) 看到所有的选中纹理的映射层级。\n点击 MipMap Blend Amounts将会打开一个新的窗口，在这个窗口中你可以调整每一层映射的混合量 (amounts)。\n之后你可以选中 MipMap Blend Color (1)然后点击 Recompile (2)来应用混合。结果会立即在预览界面和游戏中显示。\n"
}]