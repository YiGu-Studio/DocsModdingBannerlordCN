[
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/animations/",
	"title": "Animations",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/bestpractices/",
	"title": "Best Practices",
	"tags": [],
	"description": "",
	"content": "Scene Performance Guide"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/creating_entity/",
	"title": "Creating Entity",
	"tags": [],
	"description": "",
	"content": "Game Entities are basic building blocks of Scenes. Every mesh, light, decal, script behaviour are components of entities. \\\nCreating an empty entity In the editor, you can begin by creating a new, empty entity by using the Add Empty Entitybutton from tool bar, then you can attach different components for different needs.\nAll entities can be composed of multiple components.\nAdding Component Component can be added from the toolbar after selecting an entity. There are 5 different components you can add. Mesh, Decal, Light, Particle, and Script.\nA - Mesh:##### Meshes are pretty straighforward and represent every visible geometry within the scene. After clicking add mesh button, select any mesh you want from mesh selection dialog. B - Decal:#####  C - Light:##### Lights can be used to illuminate the scene. Usually attached to other entities that supposed to emit light. (Like, torches, camp fires etc.)\nEvery light is fully customizable, you can enable/disable dynamic/static shadow, change light radius / shadow casting radius, intensity, and color from properties panel of light.\nYou can also specify custom effects like flickering for more natural lights. After clicking add light button, you can change properties of the light under Components panel in Entity Inspector.\nEngine uses a technique called Tiled Deferred Rendering, so using lots of lights are pretty cheap as long as they are not overlapping too much.\nThese parameters can be tweaked to further optimize scenes.\nIn the scene visualizer, Yellow sphere represent light radius, and blue sphere represents shadow casting radius. (D) Particle System:##### Particles simulates and renders many small images or Meshes, to produce a visual effect.\nParticles are useful when you want to create dynamic objects or volumetric effects like fire, smoke, or splash effects since they are quite hard, or even in most cases, not possible to create with regular meshes.\nAfter clicking add particle button, and selecting an exsiting particle from the Particle selection dialog, you can edit this particular instance from Component panel by clicking Edit Instance, (E) Script:##### Scripts are the basic building blocks of game related behaviours that can be attached to entities.\nScripts can be written in C# and has full access to attached entity, its Scene, and therefore all other entities in that Scene.\nAfter clicking add script button, you can select the script you want from the dropdown menu, then you can change the script parameters from Scrips panel under Entity Inspector.\nEntity Hierarchies Entities can have a parent child hierarcy to organize related entities together.\nChild entities automatically get their world position relative to their parents, moving a parent entity will move all of their children. More imformation about manipulating an entity can be found HereYou can use the Entity Outliner to create hierarcies by simply dragging an entity over another entity.\nYou can also detach a child entity from its parent by right clicking and selecting Detach from parent.\n                "
},
{
	"uri": "http://localhost:4444/zh_cn/",
	"title": "Live",
	"tags": [],
	"description": "",
	"content": "欢迎来到《骑马与砍杀2：霸主》 Mod 开发文档 获取更多“常见问题解答”，请访问 常见问题解答。\n想要快速创建并且注册一个游戏 Mod 请访问 快速入门指南。\n更多信息请参阅：\n [资产管理]创建/编辑一个包含资产 (Assets)、脚本、场景以及游戏逻辑数据的模组，这些可以是新建的数据，也可以用于覆盖游戏内已经存在的数据。 [霸主任务系统]详细介绍游戏脚本组件的工作原理，何时能触发回调，以及骑砍2：霸主中用来建立游戏流程（体验）的特定脚本模板。 [编辑器]关于编辑器的信息，引导玩家如何能最有效地使用编辑器编辑场景和内容。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/material_editor/",
	"title": "Material Editor",
	"tags": [],
	"description": "",
	"content": "Overview Inspector Shader pbr_shading This shader is heavily used and exists just because our engine did not use PBR shading pipeline in the early years of development, most content was not created for PBR pipeline, so this shader is created to support our already existing content and only used during the transition phase. New content should not use this shader, instead you should use pbr_metallic.\npbr_metallic This is what you should use most of the time. This shader uses standard metallic PBR pipeline and inputs are compatible with most texture authoring softwares.Inputs:Albedo and Normal: These are pretty standard, outputs of texture authoring softwares can directly be used. Specular: This texture uses its 4 channel for different purposes. Red channel contains Metallic information, Green channel contains Glossiness (inverse of Roughness), Blue channel contains Ambient Occlusion, and Alpha channel contains Translucency (for vegetation shaders only) grass This shader is a derivative of pbr_metallic, and should only be used on grass meshes. Contains special effects like wind animation, sway animation, smooth LOD transition, color multiplication from terrain, etc.\nflora_leaf This shader is a derivative of pbr_metallic, and should only be used on leaf parts of trees / bushes. Contains special effects like wind animation, sway animation, color multiplication from terrain, smooth LOD transition, translucency (Alpha channel of Specular texture), etc.\nflora_bark This shader is a derivative of pbr_metallic, and should only be used on bark parts of trees / bushes. Contains special effects like wind animation, smooth LOD transition, etc.\nTextures Diffuse2Map This input is used internally by engine to create special effects / blendings like Shield Banner Paintings, Banner texture in this slot will only appear where Diffuse 1 Texture contains alpha. Usage of this texture really depends on the shader used.\nDetailNormalMap This input is used to create micro imperfections and additional high frequency detail on top on regular normal mapping. Scale of this texture can be adjusted in Texture Settingspanel\nHeightMap This input is used in both Parallax Occlusion Shading, and Displacement.\nDecal(___)Map These inputs are used internally by engine to create skinned decals on entities (like blood and mud on agents).\nTexture Settings Areamap Scale Used internally for parameter passing.\nSpecular Coef Metallic channel (Red channel of Specular texture) is multiplied by this value in shader.\nGloss Coef Gloss channel (Green channel of Specular texture) is multiplied by this value in shader.\nAmbient Occlusion Coef AO channel (Blue channel of Specular texture) is multiplied by this value in shader.\nNormal Depth Normal textures X and Y channels are multiplied by this value. If you set a value close to Zero, surface will appear more flat since X and Y values will be close to zero and only Z direction is contributed to normal mapping.\nDetail Normal Scale This parameters sets how many times the detail textures should tile. Higher values increases frequency.\nParallax Mode You can select displacement method to use for this material. Options are, Parallax or Displacement. Both require a heightmap texture. Parallax uses Parallax Occlusion Mapping in shader, Displacement uses hardware tesselation.\nParallax Amount Intensity of displacement effect.\nParallax Offset Sets the middle value to a desired height. (Value of 0.5 in heightmap).\nMaterial Shader Flags use_detailnormalmap This flag should be enabled to utilize Detail Normal Map feature.\nalpha_test Diffuse 1 textures alpha values are used as a cut-out texture. Alpha threshold can be specified in Transparencypanel.\nuse_specular This flag should be enabled in all cases. It is only here for lagecy reasons.\nuse_procedural_wind_animation Can be enabled to create a very simple and cheap, sine wave wind effect. Mostly used for tents / flags. (Should not be mistaken with cloth physics feature).\nself_illumination Enables self illumination. Illumination texture should be specified in Diffuse 2. Brightness parameters can be adjusted in Vector Arguments panel.\nuse_specular_from_diffuse Never ever use this. It is only used in pbr pipeline transitioning phase and only here for legacy reasons. Simply grayscales the diffuse texture, and uses it as specular texture.\nuse_double_colormap_with_mask_texture Used internally to create team color effect in clothing. A special texture is created to specify which parts of clothing should be affected by team colors. A simple Red / green texture for primary and secondary colors is specified in Diffuse 2 texture. Primary and Secondary colors are set by gameplay code as Factor Colors.\nTransparency Others Vector Arguments Factor Colors Vertex Layout Bump Map Should be enabled in most cases (Standard PBR requires this).\nSkinning and Skinning Precise If your material is going to be used with a skinned mesh, enable Skinning, if your skinned mesh is quite large that has important small polygons (like eyes) enable Skinning Precise. (This disables some optimizations so only use if it is really necessary).\nDouble UV Enable if your custom shaders require double UV channels.\nPostFX Used internally by engine.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/asset_naming_conventions/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": "To distinguish and organize assets and simplfy asset authoring process there are some predefined rules to consider.\nMeshes All meshes imported from a single geometry file(e.g. fbx) are grouped by their names. To add a LOD mesh simply append \u0026quot;.lod\u0026lt;n\u0026gt;\u0026quot; to the name of your mesh. Here n is the number of lod.\nConsider an fbx file as below :\nasset.fbx :\n wall_damaged wall_damaged_v2 wall_damaged_v2.lod1 wall_damaged.lod1 wall_damaged.lod2  Two meshes will be imported from asset.fbx file : wall_damaged, wall_damaged_v2. These meshes will have one and two lods respectively. If your modelling software does not support dots in names(e.g. Maya) you can also use \u0026ldquo;_\u0026rdquo; insted of \u0026ldquo;.\u0026rdquo; to specifiy lods(e.g. wall_damaged_v2_lod1).\nA mesh can not have more than one material so during import phase meshes wil be divided into submeshes according to material usages of polygons. Consecutive numbers will be appended to the names of these auto generated meshes. Consider a mesh wall_damaged using three different materials. Name of the imported mesh will be wall_damaged and it will have three submeshes with names wall_damaged.1, wall_damaged.2, wall_damaged.3.\nPhysics shapes You can export physics shapes just like regular meshes. The only difference between a mesh and a physics shape is that name of physics shapes begin with \u0026ldquo;bo_\u0026rdquo; prefix. You can also export analytical capsules and spheres as well.\nCapsules\nIf name of a node begins with \u0026ldquo;bo_capsule\u0026rdquo; it will be imported as an analytical capsule shape. Sizes of this capsule is determined by following rules :\n Local XY axes assumed as the radial plane of capsule Local Z axis assumed as the direction of capsule(height) Scale of object in XY directions should be equal  Only orientation and extents of capsule nodes are used. Any content attached to them(like mesh) is ignored.\nSpheres\nIf name of a node begins with \u0026ldquo;bo_sphere\u0026rdquo; it will be imported as an analytical sphere shape. Sizes of this sphere is determined by the extents of the node. Center of the node will also be the center of the sphere shape. Only orientation and extents of sphere nodes are used. Any content attached to them(like mesh) is ignored.\nComposite Shapes\nYou can combine different shape types to create more complex shapes. To export a composite shape you must create a node whose name begins with \u0026ldquo;bo_composite\u0026rdquo;. You can append child nodes with different shape types to this node.\n bo_composite_building1 bo_capsule1 bo_capsule2 bo_sphere bo_building_walls  This shape will be imported as a single asset with name bo_composite_building1.\nTextures You can provide basic hints for your texture by following by following these rules:\n Albedo textures ends with _d Normal textures ends with _n Specular textures ends with _s Heightmap textures ends with _h  Despite these rules are not obligatory, it will help engine to decide best compilation rules during first import and help some features of editor to work(e.g. auto completing normal texture slot of material). If your textures do not follow them you can change import settings later though.\nSkeletons Most of in-house assets are organized so that skeletons, meshes and animations using these skeletons are stored in separate files. So we follow some naming rules to correctly establish cross-references between these files. If you are also planning to import skeletons, meshes and animations from different files :\n Bone hierarchy of skeletons must match Every bone node should have its name ending with a hardcoded bone number(e.g. _0, _1) to make sure skeletons originating from different files have their bone numbers match regardless of export process of your modelling software or exporting tool. There are these rules that each bone name must follow : Appended bone indices must start from zero Appended bone indices must not be greater than or equal to number of bones Two bones can not have same bone index  Skeletons take their names from the root node of bone hierarchy in your geometry file. This is to let you name your skeletons something other than the name of root bone. If your root bone does not have a parent node, you can create a dummy node and make your root bone child of it. By renaming dummy node you will be able to rename your skeleton without affecting bone names.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/nav_mesh/",
	"title": "Navmesh",
	"tags": [],
	"description": "Navigation Mesh Modeling Creation Guides and Examples",
	"content": " What is the Navigation Mesh? Navigation Mesh is a compilation of models created by the scene designer for the use of AI to make sure they can move around without colliding with the physic objects in the scene. What are the important rules for Navigation Mesh? a. 1,5 Meter Rule: Designers needs to arrange the navigation mesh in a 1.5-meter diameter when creating on terrain or other objects that can be walked on or can stand on (Rooftops, castle walls etc.) This diameter needs to be in 1.5 meters on a vertical axis. If this 1.5 rule is not applied, AI won’t be able to find the way when walking.\nb. Spawn Point Pivot Points:Each spawn point in a scene has pivot points. Navmesh polygon faces have to include these spawn point pivot points. Otherwise, spawn points will not work.\nc. Existing Trees:Each tree in a scene has a physical object which we call ‘capsules’. AI will see these capsules automatically when in a battle. Because of this, AI won’t walk into trees. Navmesh can be applied under trees.\nd. Terrain Angle:There are some areas that won’t be traversable because of their steep angle. These areas can be enabled with: Shaded \u0026gt; Debug - Terrain Angle. On the opened Angel Limit window, designers can input \u0026ldquo;50\u0026rdquo; to enable these. You can see two areas which are green and red. Green areas are traversable and red areas aren\u0026rsquo;t.\ne. Where to apply Navemesh:Navigation Mesh should be applied to every surface upon which players can walk. Navigation mesh should not be applied under the physical objects. Since the AI can’t jump, areas which can be accessible with jumping should not contain the navigation mesh.There is no \u0026ldquo;Undo\u0026rdquo; operation in the Navigation Mesh. If you press CTRL + Z, the last scene change will be reverted. Do not try to undo when applying Navigation Mesh\n How many types of Navigation Mesh need to be applied? There are three types of Navigation Mesh:\n1.Basic navigation mesh areas(without an ID, ID:0), for example, battle_terrain, hideout or lords hall. 2.Village Scenes. Scenes like villages have multiple navigation mesh ID’s. 3.Siege-Town scenes. In these kind of scenes, there are two main visibility modes for Civilian and Siege. The town scene in civilian mode can be seen as a big village scene. But on Siege mode, there are some places and cases that demand Navigation Mesh faces to have special ID’s. Navigation Mesh Modeling Foreknowledge When opening the editor you will see a toolbar as shown in the photo below.\nThe icon in the red square is for the Navigation Mesh. When you click on it, you will see that the “NavigationMeshInspector” is opened in the inspector.\nAfter the Navigation Mesh Inspector is opened you will see ‘Editor Mode: Navigation Mesh Select’ in the UI.\nAll the dropdown menu functions in the Navigation Mesh Inspector can be used in the Navigation Mesh Select mode. Hitting 1,2 or 3 on the keyboard will select these faces: 1: Vertices 2: Edges 3: Faces.\n Navigation Mesh Modeling **Until now we spoke about the Navigation Mesh Select Tool mode. Another editor mode for Navigation Mesh is Navigtation Mesh Add mode.\nTo open this mode you can press the ‘Spacebar’ key. You will see a vertex preview in the mouse pointer.\nAfter pointing out 4 different points in the map, press CTRL+Space to create the Navigation Mesh polygon.\n              The shortcut table below can be helpful after the polygon creation phase. Below that, you also have the explanation of the tools available under the Generation Tools tab in the Navigation Mesh Inspector.\n   Navmesh hotkeys Shortcut Editor State     Fill in closest 4 vertices (creates a quad) Shift + Click Navigation Mesh Add   Fill in the last 4 vertices (creates a quad) Ctrl + Space Navigation Mesh Add   Move vertex without selecting Ctrl + Drag Navigation Mesh Add   Delete face with mouse over (leaves vertices) Alt + Click Navigation Mesh Add   Delete face and remove all vertices Alt + X + Click Navigation Mesh Add   Selection mode - vertex 1 Navigation Mesh Select   Selection mode - edge 2 Navigation Mesh Select   Selection mode - face 3 Navigation Mesh Select   Select all vertices, edges or face (depends on the current selection) Ctrl + A Navigation Mesh Select   Delete selected vertices, edges or face Delete Navigation Mesh Select    Generation Tools The most useful and used tools are:\n Extrude: Extrusion along the selected edge\u0026rsquo;s (or edges') axis. Fill: Fills between the selected navigation mesh vertices (or edges) and forms a face. Grow Selection: Grows the selection by selecting the adjacent elements to the selected elements (works for all vertex, edge and face structures). Connect: Connects the selected two navigation mesh vertices by drawing an edge between them. Weld: Removes vertices forming the edge and makes the edge one single vertex. It connects the old adjacent vertices to the newly generated vertex.   Navigation Mesh Modeling on Scene Types We discussed briefly how to create and apply the Navigation Mesh. Let’s consolidate this information by creating a Navigation Mesh for a village scene with the help of some screenshots along the way.\n1.Village Scene  After opening a village scene, let’s navigate to the Visibility tab and change it as seen in the screenshot below to work more comfortably. Visibility Masks \u0026gt; Game Entities (Uchecked), Particle Systems (Unchecked), Layer Flora (Unchecked), Show Paths (Unchecked) Physics Options \u0026gt; Show Entity Physics (Checked).\n              Click on the Navigation Mesh Icon on the toolbar and open the Navigation Mesh Inspector tab on the right side. After that, press 3 on your keyboard to open the Face mode. Change the ID part from 0 to 2.\nLet’s create our first face. As seen in the screenshot below, place the vertices on top of the road and click CTRL+Space. You will see a Navigation Mesh Polygon created. We can place 2 more vertices near the existing polygon and press Shift+Left Mouse Button to create additional Polygons.\n                                By holding CTRL while navigating the mouse to the vertices we can see the yellow previews. Holding these vertices with Left Mouse Button will allow us to move the vertex freely.\nIn the Navigation Mesh Select mode, select what mode you want to use (1 (Vertex) 2 (Edge) 3 (Face)) and use Alt+Delete to remove. This will leave the vertices in the scene (If Edge 2 ((Edge)) and 3 ((Face)) are selected). If you want the vertices to be inactive you can press Alt+X+Delete keys. The other remove method is in the Navigation Mesh Add mode. If we hover over the vertex, edge or faces with ALT button pressed we can see a red preview. We can remove them by clicking the Left Mouse Button.\n   Navigation Mesh Select Mode-NavDelete Navigation Mesh Add Mode-NavDelete           EASY AND FASTER NAVMESH CREATION TIP  Navigation Mesh needs to contain the spawn point pivot points. Let’s apply the navigation mesh as they are connected with all the roads and navigation mesh face on spawn points.\n               Let’s press the Spacebar after creating a navigation mesh face to check that the ID is set to 2 and change the Editor mode to Navigation Mesh Select mode and press the \u0026ldquo;3\u0026rdquo; key on the keyboard. This process will ensure that we chose the navigation mesh face. After this, let’s select the face and make sure that the ID is 2 on the Navigation Mesh Inspector. We already saw it was 2 when we started but we are now sure it is 2. We can deselect what we chose by clicking on an empty space on Viewport. Now, we can press the Spacebar to change the Editor mode to the Navigation Mesh add and continue.\n Please make sure your navigation mesh areas don\u0026rsquo;t contain any physical objects.\n              The animal spawn points can be seen in the screenshot below. To make sure the scene has animal spawn points you can click on the entity in the scene and check the text located on the bottom left of the screen.\nTo prevent animals from escaping let\u0026rsquo;s apply navigation mesh like an island and use the mesh ID 2. After that, let’s change the ID of the surrounding mesh faces to 3. That way, the animals won\u0026rsquo;t be connected with the rode and won\u0026rsquo;t be able to escape.\n              There are special fields in the scenes that we call ‘common areas’. You can see these areas in the scene with a sphere. Let’s fill in this sphere with the navigation mesh faces that has the ID 2, while making sure there are no physical objects inside of them.\n              After making sure all the roads and spawn points are applied and connected to each other we have finished the phase one.\nIf there are any unwalkable terrain fields, you can click on the “Shaded” option in the dropdown menu located in the top bar. Choose the Terrain Angle in the “Debug” field and change the Angle Limit to 50. Now, we can see the red areas and apply navigation mesh according to this information.\nLet’s change the ID to 1 in the Navigation Mesh Inspector while making sure there are no selected navigation mesh faces. Let’s continue to apply navigation mesh while making sure there are no physical objects inside of them.\nLet’s complete the navigation mesh of the scene after we make sure every surface on the scene is inside of the borders (you can toggle the Border view with Visibility \u0026gt; Visibility Masks).\nThe navigation mesh of this village scene is complete.\nNow, let’s take a look at the scripting of the Navigation Mesh IDs. Navigate to the Prefabs tab and search for “navigation_mesh_deactivator” in the filter field. Let’s put that into the scene. Select the Navigation_Mesh_Deactivator entity in the scene tab. Let’s open the dropdown menus in the Entity Inspector \u0026gt; Scripts \u0026gt; NavigationMeshDeactivator. Set the DisableFaceWithId to 1 and DisableFaceWithIdForAnimals to 3.\n              Save the scene. The navigation mesh process for our village scene is completed.\n The Logic of Navigation Mesh IDs The navigation mesh faces with the ID of 2, are the navigation mesh faces that the AI sees while we take a walk in a scene. These faces needs to be connected to each other. The faces which include the animal spawn points need to have the ID of 2, as well. The reason why these faces are not connected is because we don’t want the animals to walk on the roads as the human NPCs. To make sure that the animal spawn points are active their navigation mesh face ID has to be 2. To disconnect their connection with the road, we apply navigation mesh that surrounds the animal spawn point faces with the ID of 2 and give the new navigation mesh faces the ID of 3. After this we also include this to the navigation_mesh_deactivator script. The faces with the ID of 1 are the faces that are not active in the walk mode, but they have to be applied. When a village is raided all the navigation meshes are active, without looking out for the IDs. Those are activated when we take a walk in the scene.\n   Navigation Meshes with the ID of 2 are active All the navigation meshes are active          "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/path/",
	"title": "Paths",
	"tags": [],
	"description": "",
	"content": "在 RGL 中，“路径”是由场景中连续的点 (Point) 组成的。他们一般都有独特的命名并且被游戏逻辑 (Gameplay Logic) 调用。路径在任务中定义了攻城器械的移动路线。同时。在遭遇战中，起始的出生点也是通过路径定义的。出生点逻辑可以根据双方军队的人数编制设定两个初始位置。关于路径修改的细节信息可以在 路径编辑 (Path Editing)中查看。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/skeleton_editor/",
	"title": "Skeleton Editor",
	"tags": [],
	"description": "",
	"content": "Skeleton editor can be used to edit, bones, joints, and ragdoll parameters of skeletons after importing them using resource browser.\nEditing Bones and Joints To edit a bone or joint, you can select the item you want from the outliner panel. This will create an Inspector of bones/joints for you to edit. All parameters are visualized and all edits will immediately be visible in the preview. Joint Properties Axis lock Axis lock limits the movement the child bone in translation space. Can be adjusted independetly for every axis. None:means This joint is not allowed to move in this axis. Free:means This joint is allowed to move freely as far as it can go in this axis. Limited:means This joint is allowed to move to as far as specified distance in this axis. (Axis Limit parameter) Twist Lock Twist lock limits the rotation the child bone in Z axis (Twist axis). Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to rotate. Free:means This joint is allowed to rotate freely as much as it can. Limited:means This joint is allowed to rotate to a certain limit. (Twist Limit parameters) Swing Lock Swing lock limits the rotation the child bone in X and Y axis. Can be adjusted independetly for both sides of twist. None:means This joint is not allowed to swing. Free:means This joint is allowed to swing freely as much as it can. Limited:means This joint is allowed to swing to a certain limit. (Swing Limit parameters) All of these parameters are visualized in the preview. Feel free to modify and see the effects for yourself.\nBone Properties Bone properties can be used to change ragdoll and collision capsules. Capsule visualization can be enabled in Display panel. You can change capsule radius, Position 1 (Top of capsule), Position 2 (Bottom of capsule) from Properties panel.               Ragdoll Simulation Best way to visualize your changes is to enable ragdoll simulation and see your changes in real time. Simple select a skeleton from outliner, and hit Red \u0026ldquo;Simulation Enabled/Disabled\u0026rdquo; button. This will enable ragdoll simulation. Pressing this button again will disable ragdoll simulation and reset the skeleton to T-Pose.\nTesting and Saving changes "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/skeletons/",
	"title": "Skeletons",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/villages/",
	"title": "What Makes a Village Scene",
	"tags": [],
	"description": "",
	"content": "Introduction This list of checkpoints should aid you in creation of village scenes and provide you with an insight into what we pay attention to when creating village scenes.\nNavigation Mesh  Navigation mesh consists of triangles and quads. It is used by the AI for pathfinding. The global illumination system also uses it to find the visible locations of the scene. Keep in mind that the navigation mesh faces should not be too far away from the physics below it. The distance should at 1.5m maximum. The faces can be labeled to give cues to the agent spawning and the navigation inside the scene. In order to make the agents follow roads, we label the faces on top of the roads with the ID 2. Note that all of the agent spawnpoints should be connected by navigation mesh faces with ID 2. For the animals, navigation mesh ID 3 can be used. Typically, these faces are kept within separate islands in structures like ditches. The animals will then roam inside those islands only. Change the ID\u0026rsquo;s of all other faces to 1 (from 0). Remember that the agents will use the navigation mesh ID\u0026rsquo;s 2. In order to create realistic pathing (on roads), scene designers should place a Navigation Mesh Deactivator (prefab name is Navigation_Mesh_Deactivator). It can be placed anywhere in the scene. Its purpose is to disable the ID 1 faces in civilian modes. The DisableFaceWithID variable of the script should be 1. For the animals, the variable \u0026ldquo;DisableFaceWithIDForAnimals\u0026rdquo; within the same script should be 3. Make sure the faces are fairly equal in size outside of the village area / where troops will maneuver. Make sure there are no disconnected navmeshes. The better the navmesh, the better will AI perform on it. Always think about that there might be big field battle inside the village. So try to avoid having many enclosed areas like a pig farm with only 1 entrance (for example: throw over some fences to create more entries) Avoid having big areas accessible to the player but not AI. Player will be able to shoot AI from places without navmesh. Use “_barrier_ai_x” to prevent AI from falling off from cliffs or getting stuck in tight areas (like a market booth) off the navmesh.  Spawn Points As noted before, all spawn points need to be placed on top of navmesh (ID 2) and inside the soft borders. Remember that some prefabs (like chairs and benches) come with spawn points attached to them. If the spawn points aren\u0026rsquo;t compatible with the village mission, they will most likely crash the game or cause errors. One example is \u0026ldquo;sp_blacksmith_with_smithing_machine\u0026rdquo;. The most important thing about the entry points are their tags. They decide what type of NPC will spawn there. For your own sake, don\u0026rsquo;t play around with those tags too much and keep them as they are from the prefabs.\n![](/img/village_scenes/3. Entry Points.png)\nPlayer Spawnpoint  Prefab: sp_player. Make sure it\u0026rsquo;s placed in a location where it can be seen from or at least has a clear path leading towards it. Do not place it too far away. There should be a navigation mesh under the spawnpoint.  Battle Spawnpoints  Prefab: Sp_battle_set. Make sure the attacker and defender spawns aren\u0026rsquo;t too close to each other or at least don\u0026rsquo;t have direct line of sight to each other. Make sure to move the reinforcement point out of sight as best as possible while still not being too far from the front lines. Make sure all spawnpoints have some empty space around for troops to properly spawn in.  Conversation Spawnpoints (civilian)  Prefab: sp_player_conversation. Conversation points define where the agent and the conversation partner spawn when the player enters the village via the \u0026ldquo;Talk to Notable\u0026rdquo; button from the World Map. Make sure they have a nice vista but keep them relatively close to the village center.  Animation Points (civilian)  Prefab: sp_npc_x. These are used for normal villagers. You can use around 40 positions. They define the positions in scenes where the villagers will spawn and walk to. Make sure they are nicely spaced throughout the village and close surroundings. Villagers will wonder along paths to get to them. If the paths are too long you might find your villagers wondering around at all times with nobody actually doing anything. Try to avoid long distances and place points close to the main paths. Placing more or less spawnpoints doesn\u0026rsquo;t influence how many villagers will populate the scene.  Rural Noteable Spawnpoints  Prefab: sp_notable_x. The number of prefabs should be around 6. These are the spawnpoints for the notables of the village (quest givers) and lords. Make sure they are in a prominent location of the village or generally places where village elder / lords would hang around. You can check the Debug Window (documentation will cover that) to make sure you have placed the correct notable positions. Go to the “Scene Entity Check Tab” and tick the “NPCs” Box and count.  Bandit Camps  Prefab: common_area_x. Each village scene has 3 Bandit Camps outside the village (place 3 prefabs), used for scene quests. Use the same spawns as for normal villagers (~15 per camp). Try to not have them do chores like farming. You can also use patrol spawnpoints: sp_guard_patrol_simple, sp_guard_patrol”. All spawn points in the radius will spawn bandits instead of villagers. You can increase the radius by scaling the common area prefab. Use civilian animation points as spawn points for bandits, some suggestions: “sp_npc_wait_wall, lookout, sp_npc_argue_set, sp_npc_wait”. Make sure that there is some indication to where they could be so that the player has a chance of finding them (especially at night). Don\u0026rsquo;t place them too close to each other.  ![](/img/village_scenes/4. Bandit Camps.png)\nAnimal Spawnpoints  Prefab: sp_animalName. Use “DisableWandering” in the AnimalSpawnSettings script, to stop animals from walking around your scene. Overall its best to put it on all bigger animals like cows and pigs if they aren\u0026rsquo;t there to wonder around.  Tactical Region  Prefab: TacticalRegion. Used to tell the AI where there are relevant bigger regions (forests, hills etc.). AI will position themselves inside the radius or avoid it. Don\u0026rsquo;t overuse it, stick to ~5 (make sure there is some variety).  Tactical Positions  Prefab: TacticalPosition. Used to tell the AI where there are relevant smaller positions (like choke points between buildings, cliffs for archers and so on). AI will position themselves according to the rotation of the Prefab and in regards to the width given by the script. You can use them quite often. The higher the slope the “better” is the position.  ![](/img/village_scenes/5. Tactical Positions.png)\nFlee Positions  Positions to which fleeing troops and also horses will run away too. Make sure they are inside the Soft Border and that there is a navmesh below them.  ![](/img/village_scenes/7. Flee Positions.png)\nDebug Window  Prefab: SpawnPointDebugView. There is a built-in debug tool which can be enabled by adding the above prefab to the scene. Place the prefab anywhere in the scene and activate the window with the check box in its script. This prefab opens a little debug window in the editor that helps you make sure you meet the requirements for the mission (like spawn points, navmesh). In the “Scene Entity Check Tab” you can count your Entry Points and make sure you have placed enough of them (or too many). In the “Navigation Mesh Check Tab” you can make sure all your Entry Points are connected to the navmesh properly.  ![](/img/village_scenes/2. Debug Window.png)\nSoft Border  Prefab: border_soft. They define the red borders of the scene. When placed they form a polygon where the 2 edges connect between the closest two border entities (but never more than two). To check the current borders, go into the \u0026ldquo;Visibility Window\u0026rdquo; → \u0026ldquo;Visibility Masks\u0026rdquo; and enable \u0026ldquo;Borders\u0026rdquo;. After crossing them the player has a few seconds to return inside the map borders, make sure this can\u0026rsquo;t be abused somehow.  ![](/img/village_scenes/6. Borders.png)\nSounds Master Ambient Sound  Prefab: x_ambient_sound. Choose a mandatory master ambient sound. You can place the prefab for the mandatory ambient sound anywhere. Make sure it has the “Is Master Sound” enabled. Make sure it doesn\u0026rsquo;t have the “Is Triggered” enabled.  Additional Ambient sounds  Used for bigger areas (like forests). Needs to have the “Is Triggered” bool. To see how far it reaches, from the \u0026ldquo;Visibility Window\u0026rdquo; enable \u0026ldquo;Sound Entities\u0026rdquo; under the \u0026ldquo;\u0026ldquo;Visibility Masks\u0026rdquo; group. To change their reach, you can scale them like you would do with other editor entities (using the “b” key or the gizmo).  ![](/img/village_scenes/8. Sounds.png)\nReverb  There are different prefabs for each use case: reverb_x. Adds reverb effect to any sound spawned inside its boundary. They are generally used for tight or underground areas. You can place these in tight alleys between taller buildings, cliffs, in caves or in dense forests. Needs to have the “Is Triggered” enabled.  Detail  Used for small details. Make sure “Is Triggered” is disabled. Place them where ever you want them to play.  Moving sounds on paths (for rivers and such) Sometimes it\u0026rsquo;s useful to move sounds along a coast line or a river. The below technique is more performance-friendly and more precise than placing multiple sound entities along your river for example.\n Place a path on the river. For more information, see Path Editing. Add the sound to the scene. Place any additional Ambient sound as explained above. Add the “path_converger” script to your ambient sound\u0026rsquo;s entity. Enter the name of your path to the \u0026ldquo;path_converger\u0026rdquo;. The sound will now follow the path according to the camera position.  Sounds in the Engine You can check the \u0026ldquo;MODDING_TOOLS_DIRECTORY/Sounds/GUIDs.txt\u0026rdquo; file for the list of the sounds in the game. These names can be used inside the script of the sound entities.\nLights  Have at least one “envmap_prop” in your scene. For darker areas like caves use “local_envmap_prop”. It will affect the lighting in an area depending on the values of its “ReflectionCapturer” script. Make sure the village and bandit camps are nicely lit. Take extra care for the conversation points. Use torches and other entities. Make sure torches inside buildings and other dark areas have “alwaysBurn” enabled in the LightCycle script. Try to avoid placing “artificial lights” without an actual source. You can bake the ambient lighting in your scene with the GI system. This will make the ambient lighting much more realistic. For more information, see GI System.  ![](/img/village_scenes/9. Lights.png)\nAtmosphere  Make sure your scene works and looks fine with all of the “TOD_x” atmospheres and in all seasons! (since it will be tested with those). Choose a “Color Grade” that fits your scene (we suggest using the ones for the faction your scene is for, like: “color_grade_empire_soft”).  ![](/img/village_scenes/10. Atmosphere.png)\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/quickguide_create_a_mod/",
	"title": "创建一个Mod - 快速入门",
	"tags": [],
	"description": "",
	"content": "Mod 可以包含从网格到物理实体、场景、游戏实体（如派系、领主、部队、物品）以及可以运行任何游戏逻辑的脚本和行为等资产 (Assets)。在本指南中，将解释创建一个 Mod 的过程。\n新建一个Mod Mod 位于根目录下的 \u0026ldquo;Modules\u0026rdquo; 文件夹内，它必须包含名为 SubModule.xml 的 xml 文件。这个文件提供 \u0026ldquo;Name\u0026rdquo;、\u0026ldquo;ID\u0026rdquo; 和 \u0026ldquo;Version\u0026rdquo; 节点等基本信息。另外，还可以在 \u0026ldquo;DepenendedModules\u0026rdquo; 节点里面定义依赖模块。如果你想制作一个单人模式 Mod，它的 \u0026ldquo;DepenendedModules\u0026rdquo; 也应该包含一个 \u0026ldquo;SingleplayerModule\u0026rdquo; 节点。此后，该 Mod 将在游戏启动器中出现。\n子Mod 可以定义在运行时加载的 DLL。这些 DLL 应该包含继承自 \u0026ldquo;MBSubModuleBase\u0026rdquo; 的 Class，其名称应该与 xml 中的 \u0026ldquo;SubModuleClassType\u0026rdquo; 节点一致。该类将被构造，并被调用某些回调，这样 od 就可以将其行为注册到游戏中。\nMod 层次结构 Mod 可以具有多个文件夹，其中包含不同类型的内容：\n bin: 编译后的DLL应该放在 \u0026ldquo;bin/Win64_Shipping_Client\u0026quot;文件夹内，这样游戏才能找到并加载DLL。 Atmospheres: 此文件夹包含可在游戏中使用的不同环境 (Atmosphere) 模板。可以从编辑器将新的环境保存到任何 Mod。 AssetSources: 此文件夹包含资产的来源。编辑器将资产导入此文件夹。在发布 Mod 之前可以过滤掉这个文件夹。关于向模块添加新内容的更多信息，请参见 添加\u0026amp;覆盖资产。 Assets: 此文件夹包含从内容源派生的资产数据。它仅在 mod 开发阶段使用。在发布 mod 之前，该文件夹可能会被过滤掉。 AssetPackages: 当模块的内容工作完成后，内容创建者应该开始 \u0026ldquo;Publish\u0026rdquo; 操作，为内容的发布做好准备。此文件夹包含了被发布的资产。 GUI: 此文件夹包含任何新的可供游戏使用的GUI元素，预制件或笔刷。 ModuleData: 此文件夹有许多包含了重要游戏逻辑的 xml 文件。\u0026ldquo;project.mbproj\u0026rdquo; 文件管理着将被加载到该文件夹内的 xml 文件。这些 xml 涵盖了从动画和套装到阵营、部队、物品等内容。 NavMeshPrefabs: 导航网面组可以在编辑器中保存为模板，方便插入到多个场景中。此文件夹包含了这些内容。 Prefabs: 此文件夹包含了预制件的XML。更多信息，请看 实体\u0026amp;预制件。 SceneObj: 此文件夹保存着从任何编辑数据中剥离出来的场景数据。没有地形的场景只能存放在这个文件夹中。 SceneEditData: 包含每个场景的地形编辑数据。此文件夹可以在发布mod之前过滤掉。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_creation/",
	"title": "地形创建",
	"tags": [],
	"description": "",
	"content": " 创建新地形 生成，删除和修改地形节点可以通过 地形检查器 (Terrain Inspector) —\u0026gt; 属性 (Properties) 进行操作。\n地形节点Terrain node是二维计算，分辨率和大小可以通过 新地形属性 (New Terrain Properties) 界面查看。\n这些参数必须在创建之前就有指定数值，尽管可以在之后对各节点进行一一调整。\n              调整节点属性 节点分辨率可以在选择节点后（选择多个节点就要按住CTRL选择）即可在 节点属性（Node Properties） 界面中调整。\n这个功能可用于分辨率不太重要的地方来优化地形（如定居点之外，玩家无法进入的地方，或者水底）\n导入/导出材质地图或者高度地图 为了支持外部地形生成器，引擎可以导入导出地形材质地图或者高度地图。你可以通过导入各种图层（碎屑图，水流图，植被图，基岩图）和16 bit的高度地图来轻松生成想要的地形。要导入材质地图时，首先你必须创建一个新的地形图层，然后选择该图层，进入属性 (Properties)，选择一些节点（CTRL+A 选择所有）然后点击导入材质地图(Import Materialmap)按钮。这样就会打开一个文件对话框让你选择文件，你可以选择8 bit的材质当作材质地图。你也可以用同样方法导入高度地图(Heightmap)，高度地图可以是8、16位的（PNG或者源文件格式）。\n                    "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/",
	"title": "场景编辑器",
	"tags": [],
	"description": "",
	"content": "Creating EntityNavmesh地形创建编辑器快捷键编辑路径Entity Inspector导航网格查看器Alignment and Snapping ToolsPrecomputed Radiance Transfer - GI SystemScene Level System地形网格混合系统群体选择调整地形大小距离工具"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/prefabs/",
	"title": "实体及预制件",
	"tags": [],
	"description": "",
	"content": "在RGL中，实体是包含所有网格，粒子，脚本组件，遮挡物和物理对象的容器。它们可以容纳其他实体来作为其子实体。这些子实体有自己的变体存在，决定了它们在整个世界中的位置，比例和旋转角度。\n预制件(Prefabs) 预制件(Prefabs)属于模板实体，即便是复杂的实体可以直接一次构造，并在之后保存为预制物件，以便在任何场景中随时使用。后期对预制件的更新也会对已经完成的场景造成影响。在《霸主》中，几乎所有的任务对象和场景道具都是预制件。\n连接规则(Connection Rules) 一旦一个预制件被放置到场景中，预制件下的所有值（网格颜色、子实体变换、脚本数值）都与原预制件相连，并且在每次改变原预制件后都会更新。在场景中，任何对这些值的改变都会切断连接。需要注意的是，在场景中对预制件进行的任何 \u0026ldquo;增加 \u0026ldquo;操作，都会将预制件的连接全部断开。例如：添加一个新的网格、粒子系统、光线、子实体或脚本组件\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/faq/",
	"title": "常见问题解答",
	"tags": [],
	"description": "",
	"content": "如何安装工具？ 从 Steam 库的工具部分中找到并下载“Mount \u0026amp; Blade Bannerlord Modding Tools”。请注意，本工具会使用部分已经下载好的游戏本体的文件，因此，工具的版本应与游戏版本一致并且应与游戏本体安装在同一驱动器中。\n如何启动工具？ 选择启动器中的 Singleplayer 选项并启动，等你进入到游戏主菜单界面后，你既可以单击 Editor 启动编辑器，也可以按下组合键 Ctrl + E 来启动编辑器。\n如何创建你自己的模组？ 我们在编辑器里内置了一个功能，可以直接创建一个有 XML 模板文件的模组，方便你快速开始添加新内容。打开编辑器后，在顶端工具栏的“File”菜单下找到“Create New Module”选项，点击它。请注意，你需要重启游戏来让启动器识别该模组。\n如何编辑游戏本体(Native)资源？ 你无法直接编辑游戏本体资源，但你可以在你的模组中覆盖掉它们。详情请参阅： 添加\u0026amp;覆盖资产我无法添加新模型、材质等 你无法直接向游戏本体添加资源，你需要在你自己的模组里添加它们。\n首先，你需要新建一个模组：快速入门指南更多关于添加新的资产的信息请参阅： 添加\u0026amp;覆盖资产可供参考的示例场景？ empire_village_003\nkhuzait_castle_002\nsturgia_town_b\nbattle_terrain_v\nempire_castle_keep_a_l3_interior\nempire_house_c_tavern_a\nempire_dungeon_a\narena_empire_a\nMain_map\n在哪能找到示例资产？ 你可以从资源浏览器(Resource Browser)中查看这些游戏本体的资源，但没有源文件提供，因此你也无法导出它们。我们很快会提供一些示例的源文件。\n我有包含 DLL 文件的模组然后我的工具无法启动？ 如果你有任何包含 DLL 文件的模组，请确保它们同样被复制到了 Modules\\MOD_NAME\\bin\\Win64_Shipping_wEditor 目录下。\n我的模组工具无法启动 请确定你的机器安装了 Visual Studio 2013 Redist x64。此外，请检查你的游戏本体版本是否与模组开发工具版本相匹配。如果完成了以上检查仍旧无法启动，你可以在官方论坛的modding forums分区下的“Bug \u0026amp; Crashes”板块发帖反馈：https://forums.taleworlds.com/index.php?forums/bug-crash-reports.784/\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/materials/",
	"title": "材质",
	"tags": [],
	"description": "",
	"content": "材质（Materials）定义了网格模型的渲染特性。它们包含着色器和纹理信息，也包含渲染标志（由着色器和全局标志定义）。一个网格模型可以拥有一个材质。在第三方网格编辑程序中，网格材质的初始值将通过它的材质名称来分配。材质可以通过材质浏览器来创建和编辑，而材质浏览器则可以通过资源浏览器来访问。材质也可以在运行时通过脚本和行为进行编辑。更多关于材质编辑和引擎默认材质的信息可以可以参阅 材质编辑器 (Material Editor) 章节。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/overriding_assets/",
	"title": "添加与覆盖资产",
	"tags": [],
	"description": "",
	"content": "在 RGL 中，您可以轻松地覆盖现有资产或在编辑器中为自定义模组创建新资产。覆盖机制的生效方式是将现有资产替换为你的模组资产目录中提供的对应资产。 它会尝试匹配您的自定义资产与其他模块先前通过其名称注册的资产。模块的加载顺序会影响这一过程。\n如果除了 Native 模块之外还分别加载了 模组 A 和 模组 B ，则最终资产及其来源列表如下：\n当前可在自定义模组中替换的资产类型为：\n 材质 (Material) 网格模型 (Mesh) 纹理 (Texture) 物理形状 (Physics Shape)  文件夹结构 资产系统会根据模块目录中的某些文件夹名称进行处理。这是这些文件夹及其用法的列表：\n Assets : 包括可编辑的 *.tpac 文件，该文件存储每个资产的元数据。 AssetSources : 包括导入资产（.psd，.fbx）的源文件。 AssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于客户端构建时，将生成该文件。 EmAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于编辑器构建时，将生成该文件。 DsAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于服务器构建时，将生成该文件。 RuntimeDataCache : 包括引擎所需的对每个资产自动生成的数据。可以删除，但在启动过程中从头开始生成可能会花费时间。  Modding Permissions 资产系统会根据游戏运行的可执行文件的版本寻找不同的文件夹。根据这些文件夹的存在与否，它判定一个模块是否可以被修改，或只能在只读模式下使用。如果您想发布您的模块，您可以打包您的资产并共享打包后的文件夹，而不需要发布成千上万的文件及其源文件。您有三个选项来打包您的资产。\n Client : 其他人可以激活您的模组并运行。您必须分发 AssetPackages 文件夹。 Editor : 其他人可以在编辑器中使用您的模组，但不能修改它。如果您希望其他人从您的模组派生模组，则使用它。您必须分发 EmAssetPackages 文件夹。 Server : 用于服务器构建。需要剥离与服务器无关的所有数据。您必须分发 DsAssetPackages 文件夹。  您也可以像使用您的模组一样共享您的模组，以允许其他人修改它。在这种情况下，你必须分发 Assets、AssetSources 和可选的 RuntimeDataCache 文件夹。\n材质覆盖 覆盖材料可以通过创建一个新的材质来完成，其名称与您要覆盖的材质相同。 导航到您的模块的assets目录，并在浏览器窗格中的空白处右击。创建一个新的材质，并将其重命名为与您要覆盖的材质相同的名称。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/material_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;被模组 A 覆盖的现有网格模型的材质\u0026lt;/div\u0026gt;  此时，系统中所有的材质引用将被重定向到您的自定义材质。 网格模型覆盖 模型可以从多种文件格式（如Trf、Fbx）导入。从单个文件导入的资源根据 \u0026lt;\u0026gt;资产命名规则\u0026lt;\u0026gt; 按其名称进行分组。想象如下一个fbx文件：\n Model.fbx  wall(Mesh) wall.lod1(Mesh) wall.lod3(Mesh) bo_wall(Physics Shape)    根据资产命名的惯例，前三个资源将被归入一个网格，其中有三个子网格属于不同的 LOD，最后从 Model.fbx 导入两个资产：wall (Mesh）和 bo_wall (Physics shape)。最后将从 Model.fbx 中导入两个资产：wall (Mesh) 和 bo_wall (Physics shape)。\n按照这些规则，您可以导出一个新的几何文件（例如 fbx)，其中包含一组名称以 wall 开头的网格。在这种情况下，一个新的 wall 网格将从这些子网格中创建，而现有的网格将被您提供的网格完全替换。几何图形文件的名称不在考虑之列。值得一提的是，网格覆盖是在网格层面进行的。不能通过模组覆盖来覆盖单个子网格。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/metamesh_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的带有名称 \u0026lt;strong\u0026gt;testbox\u0026lt;/strong\u0026gt; 的立方体网格被模组 A 用茶壶覆盖\u0026lt;/div\u0026gt;  纹理覆盖 纹理的覆盖与材质非常相似。你需要导入一个新的纹理，其名称与你要覆盖的纹理相同。你也可以将任何已经导入的纹理重命名为与要覆盖的纹理名称相匹配的字符。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/texture_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的名为 \u0026lt;strong\u0026gt;roman_ground_d\u0026lt;/strong\u0026gt; 的 albedo 纹理被模组 A 用白色纹理覆盖\u0026lt;/div\u0026gt;  物理形状覆盖 覆盖物理形状需要你导入一个与你要替换的资产名称相同的物理形状。检查 \u0026lt;\u0026gt;资产命名规则\u0026lt;\u0026gt; 以了解如何导入物理形状。\n\u0026lt;div class=\u0026quot;panel-body\u0026quot;\u0026gt;![](/img/modding/assets/physics_shape_override.png)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;panel-footer\u0026quot;\u0026gt;现有的圆环形状被模组 A 用一个自定义的水蓝色形状覆盖\u0026lt;/div\u0026gt;  "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/bodies/",
	"title": "物体",
	"tags": [],
	"description": "",
	"content": "物体定义了物体的物理边界，它们可以被分配给场景或者预制物件的实体。用户可以编辑“物体标识”（Body Flag) 来改变其行为。\n物体标识(Body Flags)  双面（Two Sided）：让物理引擎可以使用多边形的两面。 Ai限制器（AI Limiter）：用来标记只针对AI使用的物体，不包括玩家。 可破坏的门（Destructible Door）: 通过自动导航网格生成器来使用，而非将导航网格直接置于可破坏的门之下。 禁用（Disabled）:禁用预制物体，或者实体实例的物理特性。 边界（Barrier）：使对象可以顺利移出物体内部 排除路径对齐（Exclude Path Snap）：适用于路径点无法对齐物体的情况 避免镜头碰撞（Don’t Collide With Camera）：玩家的镜头不会和对应物品产生碰撞。 动态化（Dynamic）：可以让物理引擎会模拟实体的运动 可移动化（Moveable）：该标识标志该物品及其所有的实体可以移动 梯形化（Ladder）：赋予梯形网格，从而使其正常运行。 台阶化（Has Steps）：决定是否将实体物品楼梯化，使得对象能够正确地攀爬楼梯。(楼梯的物体应与实体的其他部分分开)。  自主体的物理引擎要求平滑和低多边形的物理对象来保证性能。投射物则要求更高的精度，以达到能更好的模拟投射物卡顿效果。以下的标识可以用于让每个物体拥有两个不同的机体，以适应两种不同的情况。若两者均未被标记，投射物和自主体都会对该物体做出反应。\n 仅限自主体（Agent Only）: 只有自主体会对该物体做出反应。 仅限投射物（Missile Only）: 只有投射物会对该物体做出反应。  遮蔽器（Occluders） 遮蔽器被用于网格模型表面，从而让渲染系统不会去渲染物体的另一面。通常来说，它们对物理模拟过程通常作用不大。但对于大城镇和村庄来说，精心布置的遮蔽器将会非常有用。用户可以直接在场景中放置遮蔽器，也可以将其附加到到实体物品和预制件上。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/textures/",
	"title": "纹理",
	"tags": [],
	"description": "",
	"content": "纹理 (Textures) 可以通过资产浏览器 (Asset Browser) 导入。可以通过材质编辑器 (Material Editor) 给纹理指定一些材质。PBR ( 基于物理的渲染 Physically Based Rendering) 材质的纹理槽 (Texture Slot) 可以在 材质编辑器 (Material Editor)中找到。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/playing-sounds/adding-custom-sounds/",
	"title": "给你的Mod添加音乐",
	"tags": [],
	"description": "",
	"content": "《霸主》的音频系统是基于 FMOD 音频引擎建立的。 为了保持音频引擎性能的同时让大家都能使用它，我们需要建立一个 中间层 (InterLayer)。\n关键要素  ...\\Modules\\*YOUR_MOD*\\ModuleData\\module_sounds.xml 文件， 你可以在此添加你自己音乐的定义。 ...\\Modules\\*YOUR_MOD*\\ModuleSounds 文件夹，你可以在此添加音频文件 （.ogg 或 .wav）。  你可以查看 Native Mod 中的例子。\n基础指南  复制样例的文件和文件夹到你的 Mod 目录下； 添加新的音频文件到 ModuleSounds 文件夹； 打开编辑你 Mod 下的 module_sounds.xml 文件； 你会在 module_sounds.xml 文件中看到音频的目录，播放音乐的代码样例，以及样例的 module_sound 实体 (Entries)； 在 module_sounds.xml 文件中为你的 Mod 添加新的音频实体； 根据代码播放新的音频实体。  下一步 使用 module_sounds.xml 文件 \u0026lt;module_sound name=\u0026#34;example/combat/hit\u0026#34; is_2d=\u0026#34;true\u0026#34; sound_category=\u0026#34;mission_combat\u0026#34; path=\u0026#34;example_sound_modders.ogg\u0026#34; /\u0026gt;  \u0026lsquo;name\u0026rsquo;: 任何你想要的唯一名字，这个是你音频的 ID。  通过代码播放音乐的时候使用。 想播放有声动画 (animation sound) 时，添加进动画 sound_code 特性 (attribute) 中。   \u0026lsquo;is_2d\u0026rsquo;: 是否使用音频的空间属性 (spatial properties)。 3D 音频会有例如 位置、速度等属性。 \u0026lsquo;sound_category\u0026rsquo;: 所有的音频必须被分配一个分类 (category) 来分配其在通信管道 (pipes) 中的路由 (route)。可用的分类有：  mission_ambient_bed (2D 环境声 (ambient loops) 比如基本风声 ) mission_ambient_3d_big (一般从远距离听到的音频，比如一个正在燃烧/战斗的城堡) mission_ambient_3d_medium (一般从中距离听到的音频，比如烽火) mission_ambient_3d_small (一般从附近近距离听到的音频，比如营火) mission_material_impact (物理材质效果比如 金属 剑击打 石 墙) mission_combat_trivial (造成不重要伤害时候的音频，比如低伤害或者无伤) mission_combat (普通造成伤害的音频) mission_foley (回转，移动以及动物移动的音频) mission_voice_shout (一般被远距离听到的人物/动物的声音，比如战斗的呐喊) mission_voice (人或者动物咕噜 (grunts) 或者击倒 (knockouts) 的音频。) mission_voice_trivial (比较安静的发声，比如攀爬和跳跃) mission_siege_loud (大型攻城战的声响，比如巨石击中墙壁、火焰投石车以及城门破坏的音频) mission_footstep (人类和小型动物的标准脚步) mission_footstep_run (更大的脚步声，指那种可在一定距离的人群中能听到的声音) mission_horse_gallop (马匹和骆驼疾驰的声音) mission_horse_walk (马匹和骆驼慢走的声音) ui (UI 和 提示的 2D 音频) alert (伪3D音频 (Psuedo-3d sounds)，用于从中距离警告玩家) campaign_node (位置性的声音节点，一般用于世界地图，农场，海和瀑布等) campaign_bed (2D 环境声，一般用于世界地图，沙漠阵风和牧场的风等)   \u0026lsquo;path\u0026rsquo;: 声音文件的路径。路径是基于你 Mod 的 ModuleSounds 文件夹的相对路径，你可以创建自己的子目录。  播放音频的代码样例 int soundIndex = SoundEvent.GetEventIdFromString(\u0026#34;example/voice/charge\u0026#34;); // 缓存 soundIndex 对象来避免运行中的 string 操作。  if (playOneshot) { MakeSound(soundIndex, MainAgent.Position, false, true, -1, -1); // 给定的位置等参数信息，播放单触发 (one shot sound) 音频。  } else { SoundEvent eventRef = SoundEvent.CreateEvent(soundIndex, Scene); // 给定音频的引用 (reference)，可以之后更新细节参数。  eventRef.SetPosition(MainAgent.Position); eventRef.Play(); } 你有两种方式可以播放音频：\n 单触发 (one shot) 性能更好，控制的更少，发后即忘 (Fire and forget)。适合战斗相关的音频。 创建并维持一个音频引用 (reference)\n性能稍差，可以控制声音的每一个参数，比如暂停和更新位置的时间。  "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/",
	"title": "编辑任务场景",
	"tags": [],
	"description": "",
	"content": "What Makes a Village Scene行动的战术位置Destructible ComponentScene Barrier BuilderScene Spawn Point Guide出生点 Debug 工具脚本组件回调函数"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/",
	"title": "编辑器",
	"tags": [],
	"description": "editor",
	"content": "场景编辑器资源编辑器"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/editor_shortcuts/",
	"title": "编辑器快捷键",
	"tags": [],
	"description": "",
	"content": "   常用按键 按键 编辑器模式     显示/隐藏帮助 H 任何模式   创建场景 Alt + 1 任何模式   保存场景 Alt + 2 任何模式   打开场景 Alt + 3 任何模式   开始任务 Alt + 4 任何模式   以…方式开始任务 Alt + 5 任何模式   场景选项 Alt + 6 任何模式   地形选项 Alt + 7 地形选项   地形海拔 Alt + 8 地形海拔   地形涂色 Alt + 9 地形涂色   切换相关编辑模式 (选择-增加，选择-海拔和涂色等) 空格 任何模式   返回/撤回 Ctrl+Z, Ctrl+Y 任何模式       视角控制 按键 编辑器模式     聚焦到选定模型 F 选择Entity   编辑器摄像头旋转模式 按住Alt +鼠标右键滑动 选择Entity   Pan 按住Alt +鼠标中键 选择Entity   拉近拉远摄像头 按住ALT + 滑动鼠标中键 选择Entity   加快减慢摄像头速度 Ctrl + 滑动鼠标中键 任何模式   摄像头速度设置为1 Ctrl + 鼠标中键 任何模式       PREFAB TRANSFORM 按键 编辑器模式     原地旋转 垂直旋转按Z, 左右旋转按X, 前后旋转按C, T, 返回默认按 R Entity Add   移动模型并放置在地面上 按住P 选择Entity   上下移动 按住N 选择Entity   水平移动 按住G 选择Entity   显示XYZ轴 T 选择Entity   显示旋转轴 R 选择Entity   显示大小比例轴 Y 选择Entity   复制粘贴模型 Shift+单击鼠标或者 Shift+拖拽 选择Entity   隐藏轴 V 选择Entity   切换为本地变换视图 Alt+L 选择Entity   切换为世界变换视图 Alt+W 选择Entity   打开模型材质视图 M+单击鼠标 选择Entity       地形 按键 编辑器模式     全选所有地形节点 Ctrl + A 选择地形   当选择提高时下降海拔 Alt + 点击 地形海拔   当选择下降时提高海拔 Alt + 点击 地形海拔   平整地形 Ctrl +鼠标左键 地形海拔   平滑地形 Shift + 点击 地形海拔   当选择平整地形时，以该高度为平整海拔 Alt + 单击 地形海拔   添加植被（不在图层上增加） 鼠标左键 涂色Entity   重新规划当前植被面积大小 按住B+鼠标左右拖拽 涂色Entity   放置单个植被 Ctrl + 左键单击 涂色Entity       NAVMESH HOTKEYS 按键 编辑器模式     填充最近的4个顶点（形成一个面） Shift +单击 添加导航网格   填充最末端的4个顶点（形成一个面） Ctrl + 空格 添加导航网格   不用选择也可以挪动顶点 Ctrl +拖拽 添加导航网格   删除面并留下顶点 Alt + 单击 添加导航网格   删除面及其顶点 Alt + X + 单击 添加导航网格   选择顶点模式 1 选择导航网格   选择边模式 2 选择导航网格   选择面模式 3 选择导航网格   选择连接的所有顶点，边和面、 Ctrl + A 选择导航网格   删除顶点/边/面 Delete 选择导航网格    "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/path_editing/",
	"title": "编辑路径",
	"tags": [],
	"description": "",
	"content": "关卡设计师 (Level designer) 可以在场景编辑器 (Scene Editor) 中轻易的增加、修改和删除路径 (Path) 和路径点 (Path Point)。\n添加一个新的了路径 用户可以使用在工具栏上部的 添加新路径 (Add New Path) 按钮，可以为每一个路径设计一个独特的名字。路径添加之后，编辑器的编辑状态 (Editing State) 会变成“路径选择”(\u0026ldquo;Path Select\u0026rdquo;) 状态。此时按空格 (space) 或者 点击工具栏上部的添加一个新路径点 (Add a new path point) 按钮。用户可以回到 \u0026ldquo;路径点添加\u0026rdquo; (Path Node Add) 模式然后添加新的路径点。每点击一次就会在当前选中的路径上添加一个新的路径点。此时再按空格，用户就可以选择并且编辑当前的路径点。每一条路径点都有 3 转换点 (Transform Points)：中心方块 (Center Cube) 和两条切线球面 (Tagent Spheres)。用户可以鼠标悬停于此然后点击鼠标左键选中他们。然后，按 T 键开始产生这 3 个转换点，之后便可以移动他们。每一步操作都可以通过 \u0026ldquo;Control + Z\u0026rdquo; 组合来取消操作。选中的路径点可以通过 \u0026ldquo;Del\u0026rdquo; 键移除。选中的路径也可以通过 \u0026ldquo;Del\u0026rdquo; 键移除。同时，如果想选中另一条路径，可以鼠标悬停在那条路径其中一个点并点击鼠标左键。\n   添加一条新路径 添加一个新的路径点 选中一个路径点           "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/meshes/",
	"title": "网格",
	"tags": [],
	"description": "",
	"content": "网格(Meshes)包含了多边形的位置和渲染时使用的属性。每个网格都会有一个材质以定义其的渲染行为。它们在网格内将按照其LOD级别进行分组。同时，在同一个LOD级别中可以同时有多个不同材质的网格。若想了解更多关于将网格导入引擎的信息,请参阅 Material Editor.\n细节级别 (LOD) 现代引擎通常使用LOD(Level of detail)系统，以确保相机近处位置使用的GPU资源量多于远处位置。这将通过增加摄像头的距离时减少网格质量来实现。这一系统将确保每个像素的多边形比例在整个屏幕上都尽可能的相似。默认的LOD距离将包含：15, 22.5, 30, 50, 70, 130, 210米。这些距离设置将保证最佳的图形质量，通过在游戏中设置环境和人物质量可以对其进行调节。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/scripts/",
	"title": "脚本",
	"tags": [],
	"description": "",
	"content": "脚本组件是附加在实体上的可执行脚本，可以用来实现各种游戏功能。在《霸主》中，很多游戏逻辑都是通过脚本组件来编写的。例如椅子、掉落的武器、攻城器械。有很多不同的回调函数，可以被继承并填充在这些脚本组件中。\n回调函数  Constructor: 在构造函数中，我们需要给它的公有变量分配默认值（可以被场景制作者改变的变量）。在构造函数中，脚本组件不会被分配给实体或场景。另外，不要在这里写任何有副作用的逻辑，因为即使创建了脚本组件，由于升级等级系统的原因，一旦打开场景，脚本组件就可能会被删除。 OnPreInit: 当脚本组件被分配给场景中的所有者实体后，这个回调被调用。一旦你进入了这个回调，那么该脚本实例中的用户定义变量就被设置了。然而，其他实体的脚本组件可能还没有被分配。因此，在预初始化中，不应该有任何依赖于其他脚本组件的逻辑代码。例如，在预初始化中， ManagedObject 将自己注册到当前任务实例中的托管对象数组。 OnInit: 当任务被加载且所有实体的脚本组件被初始化，这个回调就会被立刻调用。你可以在这个回调里面使用任何类型的逻辑代码。运行时实例化的脚本也会得到这个回调的调用。 OnEditorInit: OnInit 的编辑器版本，在从编辑器加载场景时被调用。当场景从编辑器中加载时，它会被调用。确保编辑器中没有任务或游戏状态。 OnTick: 对于每个脚本组件，该任务在同一线程的任务的每个帧中都被调用。 OnEditorTick: OnTick 的编辑器版本。 IsOnlyVisual: 如果你有一个脚本组件，只是可视化的，没有任何应该在服务器版本上运行的逻辑代码，你应该在这个函数中返回 true 。这确保了这种类型的脚本不会在服务器版本上运行。 OnEditorVariableChanged: 在编辑器中，每当用户改变该脚本组件中的公有变量时，就会调用这个回调。如果艺术家需要在编辑器场景中得到即时反馈，这个回调可以用于任何视觉-逻辑状态的改变。 OnRemoved: 当实体或脚本组件被移除时调用。如果你有任何已分配内存的对象被存储在其他地方（例如静态容器），你可以使用这个回调来确保它们被回收，避免泄露内存。  "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/tactical_positions/",
	"title": "行动的战术位置",
	"tags": [],
	"description": "",
	"content": "战术阵地和战术区域 这些是让AI了解地形特征的脚本实体。与攻城战中不同，AI不会总是使用你放置的战术阵地或区域。他们会在自己认为有利的条件下使用它们。\n由于玩家的移动路径和AI刷入路径随机化，在战斗中可能出现的情况非常多。因此，最好尽可能多地标记有意义的阵地和区域。漏掉一些有意义的阵地标记将不会导致像攻城战中那样明显的错误，但会导致战斗的趣味性降低，因为AI不会意识到他们周围的环境。下面是关于战术阵地和战术区域的类型以及使用方法。\n战术阵地 高地（High ground），坡面方向 这些是面向一个方向的有利高地阵地。如果敌人从战术阵地面对的方向靠近，AI可以守住这些阵地。 方向是最重要的部分。要防守的阵地将面对阵地的前进方向（编辑器中的绿色箭头）。参数如下。\n山顶(Top of Hill)，可全方位防御 这是丘陵顶部的高地阵地，易于防御所有方向。无论敌人的进近方向如何，AI都可以守住这些阵地。AI会面朝敌人在山顶布阵。方向并不重要。\n隘口（Choke Points） 这种类型是两边有不可逾越障碍的隘口。人数较少的AI可以尝试守住这些隘口，以减轻自己的人数劣势。\n悬崖（Cliff Positions） 这种战术阵地本身毫无意义。它们应该放在隘口战术阵地下的实体层次结构中。如果放在隘口下，而AI使用了这个隘口，才会使用悬崖阵地。\n战术区域（TACTICAL REGIONS） 这些都是用于标记场景中的区域。只给出一个半径的圆形区域。显然，场景中会有完全自定义/随机形状的森林、险要地貌和开阔地。因此应该定义多个由不同圆形区域组成的战术区域，可以根据需要添加多个圆形区域。每个战术区域的圆形区域半径可以是一个粗略的估计，不需要精确。\n森林区域（Forest Areas） 如果敌人拥有更多的远程和骑兵部队，则AI可以在森林区域内使用阵地，因为弓箭手和骑兵在森林中的效能较低。任何对远程部队和骑兵都不利的地区都可以指定为一个森林区域，它不一定必须是一片有树木的森林，也可以是一个有很多障碍物和掩护物的市场。\n障碍地形（Difficult Terrain） 这包括岩石地形以及沼泽，甚至可能是集市或一些地面有很多障碍物的阵地，任何不妨碍范围性火力(如森林)但阻碍和减缓骑兵的区域都应该被考虑并标记为障碍地形。如果敌方的骑兵部队数量占优，AI可以在困难地形区域内使用阵地。\n开阔地形（Open Areas） 能让骑兵快速移动和清除远程火力的地形。这个区域类型是用来标记合适的战场。如果AI拥有优势或同等数量的射手和骑兵单位，可以选择在开阔区域进行防御。\n战术区域和阵地组合 A节中描述的战术阵地也可以放在战术区域实体下，它们的_tacticalRegionMembership应该被正确选择。在这种情况下，AI会意识到隘口也在森林区域，在合适的条件下，可以相应地选择该隘口或高地。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/overriding_scenes_prefabs/",
	"title": "覆盖场景和预制件",
	"tags": [],
	"description": "",
	"content": "你可以通过在同一个游戏中创建新的方式来覆盖现有的场景 (scenes) 以及预制件 (prefabs)。\n预制件 (Prefabs) 预制件在 xml 文件中的定义在 Prefabs 以及其子目录下可以找到。\n场景 (Scenes) 场景储存在 Mod 目录下的 SceneObj 和 SceneEditData 文件夹中。SceneObj 目录保存了在客户端模式 (Client Mode) 中打开场景所需要的文件，而 SceneEditData 目录保存了编辑场景所需要的文件。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-browser/",
	"title": "资产浏览器",
	"tags": [],
	"description": "",
	"content": "Asset browser shows assets 5256+2+56\n"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/",
	"title": "资产管理",
	"tags": [],
	"description": "",
	"content": "创建一个Mod - 快速入门常见问题解答资产浏览器资产类型"
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-types/",
	"title": "资产类型",
	"tags": [],
	"description": "",
	"content": "AnimationsNaming ConventionsPathsSkeletons实体及预制件材质添加与覆盖资产物体纹理网格脚本覆盖场景和预制件"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/",
	"title": "资源编辑器",
	"tags": [],
	"description": "",
	"content": "Material EditorSkeleton EditorCloth SimulationModel Viewer元模型编辑器纹理编辑器"
},
{
	"uri": "http://localhost:4444/zh_cn/playing-sounds/",
	"title": "音乐",
	"tags": [],
	"description": "",
	"content": "给你的Mod添加音乐"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/entity_inspector/",
	"title": "Entity Inspector",
	"tags": [],
	"description": "",
	"content": "Transform Panel Transform panel allows you to change position, rotation and scale properties of the selected entities. All of these values are relative to the parent of the selected entity. If Entity has no parent, then they are the Global values. (in Worldspace).\nScale Locked If the lock icon is in locked state, changing any component of scale parameter will set all scale components to the same value, entity will be in uniform scaling mode.\nUnlocked If the lock icon is in unlocked state, every scale component can be changed independently, and will allow non-uniform scaling.\nTransform with Gizmo Transform modes All of the transformation can also be done using Gizmo. Gizmo can be activated by selecting an entity (or multiple entities) and pressing one of the hotkeys below.\n   Rotate Translate Scale     Hotkey: R Hotkey: T Hotkey: Y         Transform spaces Gizmo can work in three different spaces; Worldspace, Localspace and Screenspace.\nWorld space World coordinates is just a fixed, parent coordinate system. This is the global coordinate system that everything is defined relative to. World Coordinate has a fixed [1, 0, 0] in the Xdirection, [0, 1, 0] in the Ydirection, and [0, 0, 1] in the Zdirection.\nLocal space Local coordinates are relative to the entity itself, every transform is defined such as that the center of the entity is center of the universe.\nScreen space Screen space coordinates are relative to the camera. Right of your viewport is always the Xaxis, Top is always the Yaxis, and forward is always the -Z(minus Z) axis.\nEntity Tag System An entity on editor can be identified by a tag defined by the user.\nAdding Tags In the Entity Inspector, under the \u0026ldquo;Tags\u0026rdquo; title, there is a button with label \u0026ldquo;Add New Tag\u0026rdquo;. This button opens a window asking for the name of the tag.\nUsing an Existing Tag After clicking on the \u0026ldquo;Add New Tag\u0026rdquo; button, from the dropdown menu in the window, you can select tags, which were added to the current scene entities before.\nA Special Case: Prefabs If you are modifying a prefab entity, adding tags to the prefab does not break it. In other words, if you change the prefab after tagging the prefab entity in the scene, the scene entity will have all the changes as well. The tags are stored in the xml files with \u0026ldquo;\u0026lt; tags \u0026gt;\u0026hellip; \u0026lt; / tags \u0026gt;\u0026rdquo; syntax. (without the white spaces between characters)\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/nav_mesh_inspector/",
	"title": "导航网格查看器",
	"tags": [],
	"description": "",
	"content": "工具 这些工具可以帮助您生成和操作导航网格：\n生成工具（Generation Tools）  Auto Generate: 顾名思义，将根据上述参数自动生成导航网格物体。 Generate Grids: 仅为地形生成格子状导航网格。它会忽略场景中的实体。 Create New Face: 在相机所在的坐标上创建一个新的导航网格四边形面。 Extrude: Remove: 删除选定的导航网格边。 Fill: 在选定的导航网格顶点之间填充并形成一个面。 Grow Selection: 选择选定元素的相邻元素来扩大选择范围（适用于所有顶点，边和面结构）。 Connect: 绘制一条边来连接选定的两个导航网格顶点。 Subdivide: 通过在顶点的中间放置一个顶点来划分它。该顶点连接到相邻的顶点并划分感兴趣的面。 Weld: 移除边而代之以单个顶点。它将旧边的相邻顶点连接到新生成的顶点。 Import Faces From Prefabs: 导入之前导出的面。 Import Body: \u0026lt;not_known\u0026gt; Make Quads When Possible: 选择相邻的三角形面，这些面可以构造四边形（不形成凹多边形）。这不会构造出具有最大表面积的面的最佳导航网格，但是它将局部选择形成最大表面积的三角形。仍然会大大减少面的总数。  调试工具（Debugging Tools）  X-Z Keys: 每个键放入两个不同的球体，当两个球体都放入时，给出这两个球体之间定义路径的统计。 Select Vertices Below Entities: 选择实体下面的顶点。 Select Unwalkable Edges: \u0026lt;not_known\u0026gt; Fix Concave Faces: 使凹面凸出。 Select Unconnected Faces: \u0026lt;not_known\u0026gt; Calculate Auto Weld Points: \u0026lt;not_known\u0026gt; Select Inverted Faces: 查找并选择面向地形的反面。 Find Path: \u0026lt;not_known\u0026gt; Paste Copied Faces: 粘贴复制的面。 Copy Selected Faces: 复制选定的面。 Export Faces as Prefab: 导出所选面以供以后使用。 Ensure Faces Are Not Below Ground: 确保面不在地下。 Remove Unreachable Faces: 删除孤岛面（其中有一个生成点）。（生成点是根据Prefabs/editor_spawnpoints.xml中的实体来确定的，该实体还包含AnimationPoint脚本。） Find Tight Faces: 查找表面积低于所需值的面，然后选择它们。您可以按“删除”按钮删除这些面孔。完成此操作后，请不要忘记“删除未使用的顶点”，我将在下面提到几行。 Remove Unused Vertices: 删除未连接到任何面的顶点。 Select Vertices At The Edges: 选择仅连接到2条边，因此不成为连续面组件的一部分的顶点。 Select Vertices Without Edges: 这将只选择未连接到任何边或面的面。 Mark Elevation Problem Faces: 到底部（网格或地形）的距离大于1.2米的面将被选中以进行调试。  自动生成参数（Auto Generation Parameters） 这些参数决定导航网格生成的精度、扩展和操作细节。参数说明如下：\n Build Detailed Nav Mesh: 选中此框将使用以下参数，并根据这些参数构建详细的导航网格物体。如果未选中，则以下参数不会生效。 Cell Size: 定义Recast库测试的样本体素的水平边缘长度。 Cell Height: 定义Recast库测试的样本体素的垂直边缘长度。 Agent Max Slope: agent可以攀爬的最大角度（单位度）。 Agent Height: agent高度。 Agent Max Climb: agent每次攀爬的最大幅度。 Agent Radius: agent可以攀爬的半径。 Edge Max Length: Recast库生成的多边形的最大边长。 Edge Max Error: 简化后的等高线边界与原始等高线的最大偏差。(定义来自Recast文档) Region Min Size: 允许形成孤岛区域的细胞[voxels]的最小数量。(定义来自Recast文档) Region Merge Size: 跨度计数小于此值的任何区域，将与较大的区域合并。(定义来自Recast文档) Detail Sample Distance: 设置生成细节网格时要使用的采样距离。仅适用于高度细节。(定义来自Recast文档) Detail Sample Max Error: 细节网格面与高度场数据的最大距离。仅适用于高度细节。(定义来自Recast文档)  自动生成步骤 (Auto Generation Steps)  首先，在“parameters”标签中填写空白字段。您可能还希望保留默认参数。 单击““Auto Generate”按钮(generation tools)，然后等待操作结束。 单击“Make Quads When Possible”按钮(generation tools)以对形成凸形的三角形进行四边形化。 点击 \u0026ldquo;Find Tight Faces\u0026quot;按钮(debugging tools)，查找并选择边框上的紧面。 按下键盘上的“Delete”按钮以删除这些选定的面。 如果边框上仍然出现紧面，请应用相同的步骤，直到结束为止。 单击“Remove Unused Vertices”按钮(debugging tools)以删除不再连接到任何面的顶点。 手动校正由于去除了紧密面而破裂的区域。 您可以使用前面提到的工具进一步调试和完善。  "
},
{
	"uri": "http://localhost:4444/zh_cn/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/alignment_and_snapping/",
	"title": "Alignment and Snapping Tools",
	"tags": [],
	"description": "",
	"content": "Pivot Alignment Tool The Pivot alignment toolapplies the chosen transform values of one entity to another entity. The tool makes it easier for users to create overlapping or precisely aligned entities. If an entitity is selected in the editor, the user can set up the alignment tool by pressing Alt + A.This will register the currently selected entity as the input entity. Selecting a second entity with the left mouse button, will then open the interface screen of the alignment tool.\n Translation checkboxeswill translate first entity on the given axis/axes. Rotation checkboxeswill rotate the first entity without breaking the local scale. Up, side and forward vectors will be aligned depending on the checkboxes. If the scale checkboxesare checked, first entity’s scale component of the selected axis or axes will be set as second entity’s scale value which is shown at the inspector. If checkboxes are unchecked, first entity will be transformed to its initial frame. Align by Pivotbutton will apply the alignment depending on the active checkboxes and close the interface. Revert and Closebutton will transform the entity to its initial frame and revert any transform operation applied to pivot.  Example Usage Surface Snapping Feature The Surface Snapping Featureallows a user to snap an entity\u0026rsquo;s pivot to the surface of another entity. Holding down the I hot-keycontinuously snaps the pivot of the currently selected entity to a surface that the mouse cursor intersects with. Control + Zreverts the transformation. This feature aligns the entity’s local y vector with the intersection point’s normal map, so it won’t require the user to make additional adjustments to align the entity with the surface.\nBeware that this will lead to clipping, if the pivot of the entity that you seek to snap to a surface is not located on its own surface.\nExample Usage Vertex Snapping Feature The Vertex snapping featureallows users to choose any vertex from a selected entity and place that vertex in the same position as any vertex from another entity of their choosing.\nAlt + Vactivates and deactivates the vertex snapping feature. It only becomes active if an entity has been selected in the editor. There is a button on the editor toolbar as well, which acts like the hot-key.\nAfter activating the tool and while the left mouse button is in a “down” state, the chosen entity’s selected vertex will continuously snap to the vertex of another, highlighted entity that is closest to the mouse ray’s intersection point. If the distance between the intersection point and the closest vertex is bigger than 2.0f or there is no second entity highlighted, nothing will happen.\nAlso, a yellow sphere will be rendered on the vertex to provide head-up display. Thus, user can choose any vertex by moving the mouse. This will be the first vertex. Also, sphere is scaled with respect to camera position’s distance.\nAfter deciding on the first vertex, the snap operation can be done by holding down the left mouse buttonand moving the mouse.\nExample Usage If user releases the left mouse button when the line’s color is green, the snap will be successful. If user releases the left mouse button when the line’s color is yellow, there won’t be any snap and entity will be translated to its initial frame.\nAxis Constraints When snap tool is active, you will see a gizmo on top of the nearest vertex. You can use axes of this gizmo to constraint axial movement or drag from middle to snap freely.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/cloth_simulation/",
	"title": "Cloth Simulation",
	"tags": [],
	"description": "",
	"content": "Preparing Mesh Cloth simulation system uses alpha channels of vertices of meshes. Values in the alpha channel represents how much a vertex can move away from its original position. 0.1 of alpha means vertex can be moved 0.1 units from its original position by cloth simulation. If you set zero to alpha value that means that vertex will be fixed to its position and will not be updated by simulation.\n   Shaded Vertex Alpha          Black parts are driven by skinning system while white parts are simulated. It is worth to mention that skinning calculations are done for all vertices whether they are fixed or not. Positions of skinned vertices are used as anchor points for simulated vertices. You can imagine that a simulated vertex can only move inside a sphere with radius R and center C. Here alpha channel of the vertex color is used as radius and skinned position is used as center.\n   Shaded Vertex Alpha          Simulation Types Direct simulation In direct simulation, vertices of rendered mesh are simulated directly by cloth simulation. This technique can be used for meshes with simple topology(like grid) and small amount of vertices. As the number of vertices increases performance hit of simulation will be greater.\nMapped simulation In some cases, your mesh may not be suitable for cloth simulation. Some examples are armors with double sided polygons, clothes with more than one layer or meshes with high numbers of polygons. For such cases a separate mesh can be used for simulation. If a separate simulation mesh is used vertices of this mesh are simulated by cloth simulation. Vertices of original mesh will be mapped to simulated mesh and move with them.\nIn the above images, meshes on the right side are used for simulation and the left ones are rendered according to simulated results. To achieve realistic results, your simulation mesh should tightly map to render mesh and it must never cover it. In other words, render mesh should never penetrate to simulation mesh. If it does, since collision calculations are done for simulation mesh you may see collision artifacts like penetrating leg to armor.\nCloth Editor To enable cloth simulation for a mesh some ingame settings must be adjusted. Cloth editor is used to setup a mesh for simulation. Cloth editor can be opened from toolbar menu in editor.\nPreview properties Preview mesh To start working with a mesh you should select it from Preview mesh menu and select the sub meshes which will be simulated from Render mesh cloth properties panel. If alpha channels of mesh painted properly it should start to be simulated on the preview window.\nSimulation mesh If you want to use a separate simulation mesh, select it from Simulation mesh menu. Alpha channel of this mesh must also be painted because it is the actual mesh being simulated. In this case alpha channel of preview mesh is used to determine if a vertex will be mapped to the simulation mesh or it will be rendered with original skinning data. Alpha values greater than zero means that vertex must be mapped to simulation mesh. Vertices with zero alpha values will use the original skinning data. Since simulation mesh has less polygon count than the original mesh, this can be used to increase skinning quality of original mesh for non-simulated parts.\nHelper mesh You can select a helper mesh to preview your actual simulation mesh with an arbitrary mesh. Selecting a horse mesh for a simulated mane mesh is a good example.\nPreview skeleton If you want to work on a skinned mesh and preview collision capsules and animations, you should select corresponding skeleton.\nPreview body You can assign an existing collision body to your Preview mesh with Preview body menu. Modification of collision bodies can be done from Cloth Bodies panel.\nPreview animation name You can test your cloth with an animation. You must write its name in asset folder, not the one in animations*.xml and its start and end frame numbers and duration. You can start and stop animation with Toggle Animation button.\nScene update coef Slow motion can be simulated by decreasing this value. Default value is 1 which means all simulations are done normally.\nRender mesh cloth properties You can select which submeshes will be simulated by checking checkbox next to each submesh. Different cloth materials can be assigned to each submesh by Cloth material column. Max distance multiplier is used to scale vertex color paintings of mesh which controls how much a vertex can move away from its original position. 0.5 value of vertex alpha with 3.0 max distance multiplier value means that, that vertex can move 1.5 units away from its original position. \\\nIf you are using a separate simulation mesh, max distance value and cloth material of simulation mesh overrides these settings. All submeshes will use same cloth material assigned to simulation mesh.\nSimulation mesh cloth properties If you use a separate simulation mesh, you can adjust its settings from here just like render mesh properties mentioned above. Cloth material and max distance value selected here will be used for all sub meshes of render mesh.\nCollision Bodies Collision presets can be created and modified from Collision bodieswindow. You can open Collision bodieswindow from Edit \u0026gt; Edit collision bodiesmenu. A capsule consists of two end points. These points can be skinned to a skeleton separately by assigning owner bones and weights. One capsule point can be skinned to at most two bones. Like mesh skinning, weights are used to determine influence of that bone on the selected capsule.\nCloth materials All simulation parameters to customize cloth behaviour is supplied with cloth materials. Cloth material presets can be created and modified from Material templateswindow. You can open this window from Edit \u0026gt; Edit merial templatesmenu. Materials shown in this windows are presets so changing these presets does not affect configurations of existing cloth meshes. To change parameters of an existing cloth mesh, you can click Change parametersbutton in Simulation/Render mesh properties panel and adjust each settings in Mesh specific parameterswindow. Current parameters are as follows:\nBending, Stretching, Shearing, Stiffness Determines how much a fabric constraint will resist to the corresponding case.\nAnchor Stiffness This constraint strictly limits the freedom of a vertex. It tries to keep distances constant between simulated and fixed vertices. You can try to increase this value if your mesh stretches too much.\nDamping Dampening values for vertices. Determines the fraction of current frame\u0026rsquo;s velocity to transfer to the next frame.\nLinear Inertia Since our cloth simulation is done in local space, global frame changes are transferred to cloth virtually. This value determines how much of acceleration of entity will be transferred to cloth. You can test this by adding a cloth mesh into a scene and shake its entity randomly.\nAir drag For a cloth mesh moving with a constant velocity this value determines how much air force will affect its vertices.\nWind You can control how much wind force the cloth will use. This value is a multiplier for actual wind force of scene. If there is no wind in the scene increasing this value has no effect.\nGravity Constant gravity force affecting each simulated vertex. You can decrease this value to achieve a silky cloth behaviour.\nIteration Frequency How many times a cloth mesh will be simulated in a second. You can leave this parameter with its default value unless your mesh has big triangles or it moves so fast that collision capsules can not catch simulated vertices. Increasing this value results in more stable collision behaviour but performance hit also increases linearly.\nPrecise Simulation We trade accuracy with performance by doing some compressions during simulation. As a result simulated mesh might move to a different state than its rest state slightly. If this accuracy is important for your mesh, you can enable this option to get more correct results.\nDummy Collision Particles If simulated mesh has big triangle sizes with respect to collision capsules, capsules may not collide with cloth mesh properly. To overcome this we place dummy vertices in every triangle of mesh. These vertices are not simulated but only used during collision stage. This option has big performance hit so you should avoid enabling this as much as possible.\nCloth Content Files Our simulation system generates two files with *.tccand *.tcmextensions. Tcc files contains preprocessed data used by cloth simulation like constraint indices, constraint lengths etc. Tcm files contains mapping data of a render mesh to a simulation mesh. You must commit both these files to Plastic SCM to ensure that nobody will wait for cooking process to complete during scene loading stage.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/bannerlord_destructible_component/",
	"title": "Destructible Component",
	"tags": [],
	"description": "",
	"content": "The destruction system which gives artists a lot more freedom is explained below.\nCharacteristics It is a ScriptComponent which can be applied to any entity in a scene, as long as that entity has a collision body.\nWhen not given any information, the script will just make the entity disappear after being destroyed. It will also re-appear when the mission resets.\nThe script can be used to destroy entities in one or more states, with optional sound, particles and dynamic objects spawning in each state.\nAny existing prefab that has a DestructibleComponent script (Siege towers, gates, ballistas, ..) will continue to work even when you remove that script. It will only no longer be destructible.\nOne entity can have multiple DestructibleComponent scripts. E.g. the battering ram is destructible, but it also has individual rooftiles which can be destroyed too. Any damage that is applied to a child will also be applied to the parent(s).\nDestroyed prefabs can always be tweaked and improved later without breaking any scenes, because they are not part of the intact entity (They are spawned at runtime).\n   Example Script of Siege Tower        DestructionStates, can be one or more prefabs. Seperated by \u0026ldquo;,\u0026rdquo; (comma).   DestroyedByStoneOnly, True means that only projectiles from mangonels or trebuchets can damage this entity. False means anything can damage this entity.   CanBeDestroyedInititally, defines if this entity can be destroyed already when loading the scene. This is controlled from the campaign map based on a destruction percentage from bombardements. This is generally only true on wall merlons. But it can also be used on aesthetic entities to make the scene look more destroyed from the start. Entities to be destroyed are selected randomly.   MaxHitPoint are the starting hitpoints from this entity. Every time the mission resets, the entity will also have its current hitpoints set back to the MaxHitPoints.   ReferenceEntityTag is an optional tag for when a DestructionState prefab has a different frame than its parent or to copy animation states. You can add an extra entity (under the entity with the DestructibleComponent script) with a correct frame and supply it with a reference tag, so that the spawned DestructionState prefab will use that frame. If there is no ReferenceEntity, the frame of the entity with the DestructibleComponent script will be used. Reference entity can also be used in special scenarios like a castlegate (opening/closing animations), to get the animation state from the reference entity and apply it to the newly spawned damaged entity.   OriginalStateTag is only required when you have multiple DestructionStates. Usually, when an entity is destroyed, we hide the entity which has the script component applied, and spawn a new entity from the DestructionState (without a parent). But for some entities (like gates), we do not want to hide the entire entity because it has to keep functioning as a gate until it is fully destroyed. Using the OriginalStateTag, we will only hide the entity which has this tag applied, and the rest of the hierarchy (particles, standing points, ..) will still be visible. Any DestructibleComponent that has more than one destructionState will spawn the damaged prefabs as child entities.   HeavyHitParticlesTag is a tag which can be applied to any child-entities that have a particle-system. These particles will burst once, when a certain amount of damage is taken in a single blow. This particle system is generally shared between all destruction states (It\u0026rsquo;s not part of the entities that get hidden/spawned).   HeavyHitParticlesThreshold is the minimum damage that is required to be taken in a single blow, to trigger particles with HeavyHitParticlesTag tag.    Effects Generally, we try to keep the spawned prefabs as small as possible for performance reasons, and also to avoid entity duplication. You have access to the following functionality to add effects:\n On the damaged prefab, when spawned: All particle systems on every entity in the hierarchy, will automatically be bursted once. On the damaged prefab, when spawned: All dynamic bodies on every entity in the hierarchy, will automatically receive the impulse from the last hit that destroyed the previous state. On the damaged prefab, when spawned: All other meshes on every entity in the hierarchy, will remain in place if they have no dynamic body-flag. Part of the entity hierarchy: Heavy hit particles have to be shared between all destruction states, and are played whenever the DestructibleComponent takes HeavyHitParticlesThreshold damage. You can play custom animations on DestructibleComponents that have a skeleton (e.g. castlegate being hit by battering ram). The animation progress will transfer to the newly spawned damaged entities. You can add a script of type AmbientSoundEmitter on a damaged prefab and provide the sound event. It will automatically play when the entity is spawned. Apart from using multiple states, you can also add multiple child entities with DestructibleComponents (e.g. battering ram rooftiles which are individually destructible). Keep in mind that any damage that is applied to a child DestructibleComponent is also applied to every parent in the hierarchy. Currently, we don\u0026rsquo;t know the performance implications of having too many of these.  Examples Example 1: Wall with breakable merlons For walls, we can only destroy the merlons and nothing else. They can only be damaged by mangonels/trebuchets and they will only take one hit before being destroyed.\n   Hierarchy of WallSegment     This is what our scene hierarchy looks like for a single wall piece. European_castle_wall_a_l3 is an entity with script WallSegment. It does not care if it has destructible children or not. Every merlon is a different child-entity that has its own DestructibleComponent script. Once they are destroyed, they all spawn the same destroyed prefab. Every merlon has a debris_holder entity, which is an empty entity. It just hold a ReferenceEntityTag tag, and the correct frame to spawn the destroyed prefab from (Important because of mesh bending: Location and rotation may change compared to the parent).       Script example of a single merlon     Every merlon has the exact same script. They will all spawn the \u0026ldquo;debris\u0026rdquo; prefab when destroyed. We decided to make them destroy after a single hit from a mangonel, so they have very low hitpoints. DestroyedByStoneOnly makes them ignore damage from all other weapons (arrows, swords, axes, ..). Because of CanBeDestroyedInititally, these merlons have a chance to already be broken when entering the mission. The merlons need a ReferenceEntity entity to determine the spawn frame for the broken prefabs.    Origin of wall and merlon pieces\n          Each merlon is a unique mesh, which has its origin point at the bottom of the wall (same as the wall).    Every merlon shares the same destroyed prefab, which has a local origin. debris_holder has a ReferenceEntityTag.    Every child of the debris prefab is an entity with flag \u0026ldquo;dynamic\u0026rdquo; and has a collision body. When spawned, it will automatically receive the last impulse that the DestructibleComponent received when destroyed.    Example 2: Siege Barricade Siege barricades are very simple objects. They are static entities and their only function is to block incoming projectiles. However, they can be destroyed in multiple stages. Each stage looking more destroyed than the one before.\n   The different destruction states of a siege barricade     Currently, the different states do not have any special particles or dynamic entities, but they can easily be added later on. Entities with the \u0026ldquo;dynamic\u0026rdquo; body flag, and particle systems will automatically trigger when spawned.       Hierarchy of siege barricade in scene Siege Barricade script component          siege_barricade_a is an empty parent. It just holds the script. siege_barricade_a_state1 is the actual mesh + body and has the \u0026ldquo;original_state\u0026rdquo; tag. When the barricade takes enough damage, siege_barricade_a_state1 will be made invisible, the next damaged prefab will be spawned and added to siege_barricade_a as a child. This is important because the DestructibleComponent needs to be informed of hits, and it can only do that if it has a (visible) collision body on itself or on a child.\nthe last state (state_5 in this case) will be spawned when the entity has 0 health (fully destroyed). The other ones will be used in between MaxHitPoints and 0.\nWhen the mission is reset (Health is reset to MaxHitPoint), the original entity (entity with tag \u0026ldquo;original_state\u0026rdquo;) will be made visible again.\nEvery DestructionState prefab has the same origin and rotation, so we don\u0026rsquo;t have to use a ReferenceEntity.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/model_viewer/",
	"title": "Model Viewer",
	"tags": [],
	"description": "",
	"content": " The Model Viewer can be accesed from; Editor \u0026gt;Window \u0026gt;Show Model Viewer From the left panel, you can change Atmosphere, hide/show ground, or add as many entities as you want. The entities can either be Humanor simple Mesh.Pressing Add Entitywill open a modal window for you to select the entity type. Transform From this panel, you can set entities Tranform, Rotation, and Scale.\nAnimation From this panel, you can choose Skeleton type, and Animation. \\\nYou can also filter animations by their name. \\\nFiltering system is quite strong through all the engine, so you can fine tune your filtering. Some examples; \\\nidle = Will filter animations that contains \u0026ldquo;idle\u0026rdquo; \\\n.idle = Will filter animations that starts with \u0026ldquo;idle\u0026rdquo; \\\nidle. = Will filter animations that ends with \u0026ldquo;idle\u0026rdquo; \\\n-idle = Will filter animations that does not contain \u0026ldquo;idle\u0026rdquo; \\\n\u0026mdash; You can also use combinations of those filters by putting a space between them \\\n\u0026ldquo;idle -barmaid 2.\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, and does not contains \u0026ldquo;barmaid\u0026rdquo;, and ends with \u0026ldquo;2\u0026rdquo;. (like \u0026ldquo;guard_idle_2\u0026rdquo; which fits this condition) \\\n\u0026ldquo;idle hangout 7\u0026rdquo; = Will filter animations that contains \u0026ldquo;idle\u0026rdquo;, \u0026ldquo;hangout\u0026rdquo;, and \u0026ldquo;7\u0026rdquo;. (like \u0026ldquo;anim_hangout_idle_7\u0026rdquo; which fits this condition)\n\u0026mdash; You can also blend an another animation using the blend panel.\nVisuals From this panel, you can put any mesh at any part of the human, and you can choose this humans gender.\nSave / Load scene You can also Save / Load the current working scene, by clicking; File \u0026gt;Save Scene \u0026gt;..Save Name.. \\\nThen you can load it with; File \u0026gt;Load Saved Scene \u0026gt;..Write Saved Name.. \\\nWhich will restore everyting to the state where you saved it.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/prt/",
	"title": "Precomputed Radiance Transfer - GI System",
	"tags": [],
	"description": "",
	"content": "We introduce a new global illumination system to the engine. It is based on a pre-baked system called \u0026ldquo;Precomputed Radiance Transfer\u0026rdquo;. This technique allow us to bake the local ambient in the scene and display it in an optimized manner at runtime. Baked data is independent from the atmospheres. Thus, we can light the scene with the same bake data for every atmosphere.\n   With Without          Baking Procedure Scene baking is divided into a couple of parts:\n First, the artist should place the border probes to identify the GI boundaries of the scene.  Side Note 1: If you minimize the GI boundaries as much as possible(not extending it to distant places from navigatable area) , you can decrease the grid dimensions and thus you will have more precision inside the town where it matters the most. For town scenes, we generally use grid dimensions of 1.5 meters width and 2.5 meters height.\nSide Note 2: For the pixels outside the GI borders, we use a fallback probe from the scene. The default is the highest active probe near to the left corner of the GI order. Artist can select any other probe from the scene by first selecting probe and checking the \u0026ldquo;Fallback Probe\u0026rdquo; checkbox in the UI.\n AT the next pass, the GI probes are created. The initial positions of the probes computed automatically by using the navigation mesh of the scene. With the navigation mesh, we place the probes where the agents can move and also to everywhere visible from those navigation points. The probes are generated within a 3d grid structure. A directional ambient data is computed for every probe position. Using these ambient light values, every pixel in the screen is illuminated by the nearest 8 probes. In some cases, when the lighting between neighbour probes have a very high difference, light or shadow leaking can occur. In order to fix these issues, we render shadowmaps from the probes just like point lights. Probes with shadowmaps are named as \u0026ldquo;Visibility Probes\u0026rdquo;. For memory usage issues, there is a limit for these Visibility Probes, which is 2048. At the automatic placement phase, the system also tries to find the most probable leak positions and assign those probes as Visibility Probes. It takes into account the ambient light difference. For additional leak fixes, the system leaves the last 5 percent Visibility Probe limit empty, so that the scene designer can fix the remaining leak issues.  PRT Files Just like the scene edit data system, prt data is divided into two parts. prt_data.bin is located inside the SceneObj folder and is the compressed version which is stripped of any editing data. This file should be sent to the source control. The other file is the edit data file. It is very big (at around 2 - 3 gb) and automaticaly sent to the edit data folder inside the network. Once you open a pre-baked scene in editor, only the compressed data is loaded. To be able to edit the bake data, you should Load the edit data with the \u0026lsquo;Load\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nImportant Node : After any changes to the prt data, do not forget to save the data with the \u0026lsquo;Save\u0026rsquo; button in the \u0026ldquo;General Info\u0026rdquo; panel of the PrtInspector.\nPRT Operations  Load : Loads the edit data from the server. Save : Saves the current edit data to the server. Auto Height Boundary : Adjusts the PRT boundary probes\u0026rsquo;s height to the min/max of the scene. Bake Single Level : Bakes the scene with the current levels, should be used for the interior scenes Bake All Levels : Bakes the scene with the pre-defined multiple levels(namely level-1/level-2/level-3 and siege/civilian) combinations.  Probe Placement Parameters:  Grid Width : Determines the probe grid cell size in XY plane. For towns, you can use 1.5. For interiors scenes, you can use between 0.5 to 1.0. Grid Height : Determines the probe grid cell height. For towns, you should use a value near 2.5. For interiors scenes, you can use between 0.5 to 1.0.  Selection Tools: To ensure fast and smooth editing of probes, various selection tools are implemented.\n Select All : Selects all probes. Grow : Grows the selection to include neighbour probes in XY plane. Shrink : Shrink the selection to only include the inner neighbour probes in XY plane. Fill : Finds the inner probes of the current selected probe group and selectes them. Select Border : Finds and selects the border probes of the current selection. Select Inner Border : Finds and selects the inner border of the current selection. Select Outer Border : Finds and selects the outer border of the current selection. Lasso Tool : We implemented a screen space lasso tool for easy selection of a group of probes. It can be started by pressing \u0026lsquo;r\u0026rsquo; and finished by either double clik or pressing \u0026lsquo;r\u0026rsquo; again.  Visibility Tools  Show Active Probes : Shows all active probes Show Deactive Probes : Show deactived probes. Show Visibility Probes : Show the Visibility probes (the ones with the visibility calculation to prevent leaking). Level To Show : Selects the Z level to show. -1 means all levels. Show Probe Radius : Determines the probe radius for debug visualization. Box Tool : Enables a mode where you .  Side Not : This system only renders the nearest 100 probes with respect to the camera.\nUseful Shortcuts  Left Ctrl + x: Enable/Disable the selected probes Left Ctrl + c: Toggles the \u0026ldquo;Visibility Probe\u0026rdquo; status Left Alt + Left Mouse Click: Select the probes that influences a pixel (very neat tool for fixing the leak issue, select the pixel and use the toggle visibility status shortcut to fix the issue)  "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/scene_barrier_builder/",
	"title": "Scene Barrier Builder",
	"tags": [],
	"description": "",
	"content": "Introduction Barrier Builder is a tool that helps artist to generate barriers over walls to prevent agents to fall down.\nUsage   Create a path, you can use the button on toolbar   Give a name to path   Build your path as you wish   Press \u0026ldquo;Enable Barrier Build\u0026rdquo; chekbox on path inspector, it will create your barrier entity for you.   You can go to that entity with \u0026ldquo;Go to Entity\u0026rdquo; Button and chnage its options like height, the entity named as \u0026ldquo;path_barrier_PATHNAME\u0026rdquo;\n  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/level_system/",
	"title": "Scene Level System",
	"tags": [],
	"description": "",
	"content": "Level System New level system replaces the old, hardcoded system with a much more extandable and unified system. \\\nAddinga new level (or deletingan existing one) to a scene can be done in Levelspanel under SceneOptionsinspector.\nLevels in Game - Bannerlord - Currently, Bannerlord recognizes a few levels that has a meaning in-game. \\\nWhich are: \\\n level_1 \\ level_2 \\ level_3 \\ siege \\ civilian  Setting Entity visibilities Making an entity only visible in a certain level combinations can be done with selecting an entity then going in Scene Level Visibilitiespanel under Entity Inspector. Select the levels you want this entity to be visible. Entity levels in missions are checked as a whole.Example If you select both level_1 and siege, and if you open a mission that has level_2 and siege, this entity will NOT be visible since it does not has \u0026ldquo;level_2\u0026rdquo;. \\\nIf you select both level_1 and siege, and if you open a mission that has level_1 and civilian, this entity will NOT be visible since it does not has \u0026ldquo;siege\u0026rdquo;. \\\nIt will only and only be visible if you open a mission that has level_1 and siege.\nSo if you want an entity to be visible in both level_1 and level_2 and only in civilian mission, select level_1, level_2, and civilian; \\\nso this entity will not be visible in ANY siege missions, and will not be visible in ANY mission as level_3.\nTesting visibility in editor There are two options to see entities with different level visibilities.\n1) Require all levels (Same as missions) \\\n2) Require at least one level (Editor only, to see all entities at once)\nRequire all levels In this mode, visibility system will work as same as the missions, you can use this mode to test what entities will be visible in what combinations. \\\nIf you select level_1 and siege, you will only see entities that has both level_1 and siege, not the others.\nRequire at least one level This is an editor only mode, if you select a level, it will be visible, no matter what combinations that entity has; if entity has that level, it will be visible. \\\nCan be useful if you want to see all civilian entities no matter what level they are, or you can see level_1 entites no matter if they are siege or civilian.\nTesting a scene For this purpose, Start mission as window modified in a way that allows you to select level combinations. If you want to test a castle scene with level_1 and siege mode, Select these leves and press OK. The mission will start in Level 1 Siege mode.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/bestpractices/scene_performance_guide/",
	"title": "Scene Performance Guide",
	"tags": [],
	"description": "",
	"content": "Performance Requirements of Mount\u0026amp;Blade Bannerlord  Singleplayer Scenes: Very High Config / 60 FPS / Gtx 1060. Multiplayer Scenes: Very High Config / 60 FPS / Gtx 970.  Possible Performance Bottlenecks Missing occluders Occluders are physical objects that define occlusion boundaries for meshes. If an object’s bounding box is fully occluded by an occluder, those objects are not rendered. Occluders drastically reduce the performance problems of wide and large scenes. At runtime, all of the occluders are rendered to a different screen and the depth values of every pixel in this screen is checked with every mesh' bounding box. In your scene, all of the building blocks and big meshes should have occluders. If the “Enable Occlusion Culling” and “Show Occluders” options are enabled from the “Visibility” tab, the occluders of every mesh are rendered with debug meshes. If any of the big meshes in your scene has missing occluders, you should contact the ART team.\nToo much pointlight overdraw \u0026amp; unnecessary shadow maps Our engine uses a grid based point light rendering system. This system divides the screen into fixed size grids. Then, the visible point lights are registered to every grid in which it’s bounding box intersects. Then, every shaded pixel in the screen uses all of the point lights inside its tile to shade itself. Every pointlight in your scene should have the minimum possible radius. Also, to not increase the overdraw, you should not use too many point lights. You can use the “Debug Tiled Lights” debug renderer to fix issues like too much point light in tight spots or lights with high radius. If there are any grid tiles with yellowish or red color, than those tiles probably have low performance. Those areas of the scene should be re-adjusted by either decreasing the point light radiuses or decreasing the point light count.\nOuter Areas Flora Usage The grass like flora that we use in our scenes has a limited viewing range. Also, we can cull out (decide to not render) these floras in high ranges. However, this flora will have a major memory impact in the scenes, also there will be a mild CPU culling cost as well. Thus, for the outer areas where the grass would not be rendered, you should not use terrain layers with high grass density.\nToo many meshes without LOD’s For modern GPUs, performance wise, polygon density per pixel is much more important than the total polygon count. In this case, the worst situation are meshes without LOD. This can be checked by switching into wireframe mode. Every triangle in the scene should contain a healthy amount of pixels inside, not the other way around. You should contact the ART team if you find a mesh without LOD’s.\nTerrain LOD Multiplier and Vertex Density Always check your terrain vertex density. In many cases, the terrain resolution can be reduced without any noticeable change. Also, try not to use terrain LOD multiplier for terrain nodes. Having more nodes and only using terrain LOD multiplier in nodes with detailed curvature will increase your scene\u0026rsquo;s performance.\n"
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/scene_spawn_points_guide/",
	"title": "Scene Spawn Point Guide",
	"tags": [],
	"description": "",
	"content": "How to design fully featured scenes in Bannerlord Each scene has own basic necessities to run without crashing and has extras to give better experience to player. Designers can check these necessities with \u0026ldquo;Spawn Point Debug Tool\u0026rdquo; to be sure that their scene will not crash.\n1. Town Center Scene Player will be spawned on the \u0026ldquo;sp_player_outside\u0026rdquo; prefab if he/she is entering the city for the first time, because of this feature \u0026ldquo;sp_player_outside\u0026rdquo; must be placed far from city\u0026rsquo;s entrance; otherwise player will be spawned on \u0026ldquo;sp_player\u0026rdquo; and this spawnpoint can be next to the entrance gate. Town center scene has some mandatory characters as follows:\n   Player Spawn Point     When player enters the town center from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than 1 in order increase variation. The scale of the conversation prefab must not change.       Traders     Traders such as armorers, blacksmiths and horse merchants are mandatory for town center scenes. If scene has more than one market place, it is ok to have more then one trader NPCs. Traders in market places may have their own sets. These sets can be considered as prefabs with some spawn points in it. For example, for weaponsmith there can be 3 points in weaponsmith set but there must be 1 spawned weaponsmith. This NPC will go to these points randomly, in a word NPC may go to his/her selling table and start trading or go to the backside of his/her shop and sit on a chair for some time. Designer may want to change these wait times between actions with \u0026ldquo;MinWaitInSeconds\u0026rdquo; and \u0026ldquo;MaxWaitInSeconds\u0026rdquo; parameters. (-1: forever).       Notables    Notable Parent Prefab Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city. Every notable have their own spawn point tag and every notable have their unique helper characters.\n   Notable Spawn Point Tag Helper Character Tag     Preacher sp_notable_preacher sp_preacher_notary   Gang Leader sp_notable_gangleader sp_gangleader_bodyguard   Rural Notable sp_notable_rural_notable sp_rural_notable_notary   Artisan sp_notable_artisan sp_artisan_notary   Merchant sp_notable_merchant sp_merchant_notary    Notables have one parent prefab named \u0026ldquo;sp_notables_parent\u0026rdquo;. Each notable has 1 set as child so, parent prefab has 5 child notable sets.\nArtists must place this parent prefab and put it in a prominent place of town center. Also prefab must be seen easily by player. After mission start, game logic will activate the notable set according to the notables in the town center.\nIn the notable sets, every notable will have unique helper character and their spawn point as well. (bodyguards for gangleader, notary for merchant\u0026hellip;).\nIn the picture below. There were 2 parent prefabs in the scene. After mission start, one prefab is activated for gangleader and her bodyguards. Other prefab is activated for merchant and his notary.\n   Guards     There are some idle guards and patrolling guards. Patrolling guards are programmed as moving one point to another while activating the next point and deactivating the current one.       Passages     Town center scene must include all passages to other scenes such as Tavern, Arena, Lords hall\u0026hellip;       Battle Sets     For town scenes, battle sets are only used for common area clearing. so they should not be too far apart, and should be placed to represent a fight between gangs rather than a battle between armies.       Townsfolk     NPCs are always moving around the city. In order to prettify the scene, designer may want to use some extra prefabs. If scene has \u0026ldquo;sp_npc_repair_set\u0026rdquo;, one NPC will go to that point and start hammering away while other NPC complains about the situation or scene may have some beggars begging for townsfolk help.    2. Tavern Scene    Player Spawn Point     Spawnpoint for player, \u0026ldquo;sp_player\u0026rdquo;, must be placed nearby to the town center passage. Scene must include at least one \u0026ldquo;sp_player_conversation\u0026rdquo; prefab or more. The scale of the conversation prefab must not change.       Game Hosts (Gambler NPCs)     Each tavern scene must have gambler (game host) NPC. The chair underneath NPC must have \u0026ldquo;gambler_npc\u0026rdquo; and \u0026ldquo;npc_wait\u0026rdquo; tags both. The chair which player will use to join game must have \u0026ldquo;gambler_player\u0026rdquo; and \u0026ldquo;reserved\u0026rdquo; tags both.    3. Lords Hall Scene    Player Spawn Point     Player spawn points for Lords Hall scene is as same as Tavern scene. Spawn point for player must be placed nearby to the town center passage.    4. Village Scene    Player Spawn Point     Village scene don\u0026rsquo;t have \u0026ldquo;sp_player_outside\u0026rdquo; prefab. \u0026ldquo;sp_player\u0026rdquo; prefab must not be placed far from village center nor very near. When spawned, player must see the walking villagers from afar. When player enters the village from top right panel in the map scene, player and the conversation NPC will be spawned on \u0026ldquo;sp_player_conversation\u0026rdquo; prefab. Scene must have these prefabs more than one in order to increase variation. The scale of the conversation prefab must not change.       Notables     Scene must have some notables. In order to find them easy, notable spawn points must be placed near center area of the city.       Villagers     Villagers have lots of extra activities in village center such as collecting grapes, repairing something or grooming horse. The activities must be balanced between physical and social activities. Villager NPC may go and clean walls then sit and chat with others.       Common areas     Each village has 3 common areas which are not in the village center. Any type of spawn points can be used inside of the common area. \u0026ldquo;common_area_NUMBER\u0026rdquo; prefabs should be placed to specify the area. This prefabs has a script attached named \u0026ldquo;CommonAreaScript\u0026rdquo;. The script has some parameters as follows:   AreaRadius : Artist can change this parameter script to extend or reduce the area.   AreaIndex : Already set in prefabs for three common areas   Type : Type of the area should be set from the list below       Area Types Scene Explanation     Backstreet Town Center Back alley where thugs are spawned   Clearing Town Center Open area   Waterfront Town Center Near coast or port   Pasture Village Pasture, forage (usually a heath or moor)   Thicket Village Shrubbery   Bog Village Swampy area   Forest Village Lots of trees   Ravine Village Valley or canyon   Spring Village Puddle in desert   Cove Village Bay   Marsh Village Swampy area near river   Wadi Village Valley, does not have rocks on both sides       Battle Spawnpoints     If game is opening the scene with battle mode. Battle sets will be initiated and battle troops will be spawned on each. Battle sets must be placed far from each other, and with defender and attacker sides in mind.    "
},
{
	"uri": "http://localhost:4444/zh_cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/meta_mesh_editor/",
	"title": "元模型编辑器",
	"tags": [],
	"description": "",
	"content": "导入设置  分解为网格 (Grid)：把元模型 (meta mesh) 分成网格，并且添加所有生成的模型部分到子模型 (submesh) 中。 移除多余的顶点 (Vertices)：功能如其名。 重新计算法线 (Normals)：导入元模型时，计算所有子模型的法线向量，而不是单单全部导入。 法线计算：决定法线向量的计算是否依靠面部区域 (Face Area)，是 (weighted) 或者是 否 (default). 重新计算切线 (Tangents)：导入元模型时，计算所有子模型的切线向量，而不是单单全部导入。 抗锯齿 (whiten)：为每个像素点计算其顶点色和白色的线性插值 (linear interpolation amount)。  多细节层次 (Lod) 模型  所有的在用的元模型的子模型都可以在这儿被看到。材料属性，模型参数以及标签都可以在这个界面被修改。  没用到的模型  这里展示了子模型的使用情况。如果勾选了忽略复选框 (ignore checkbox)，这意味着对应的子模型是处于非激活状态。当需要修改 lod 模型的状态时，请点击 “应用忽略 (Apply Ignores)” 按钮来应用并且保存你的修改。  保存  保存元模型的所有改变。  "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/spawn_point_debug_tool/",
	"title": "出生点 Debug 工具",
	"tags": [],
	"description": "",
	"content": "介绍 这个可以添加进场景的工具有一个预制件 (prefab) 叫做“SpawnPointDebugView”。预制件有附带一个“SpawnPointDebugView”脚本，工具可以通过查看器选项 (Inspector Toggle) 打开。工具有 3 个选项卡，分别叫做“Scene basic information tab”，“Scene entity check tab”和“Navigation mesh check tab”。\n1. 场景基础信息选项卡 (Scene Basic Information Tab) 这个选项卡可以决定场景的类型，从而找到一些场景必须品。如果检测出的类型不正确，设计师可以通过下面的选项按钮 (toggle button) 来重写类型。\n2. 场景实体检查选项卡 (Scene Entity Check Tab) 这个选项卡计算了出生点 (Spawn Point) 数量，并且在数量不在场景规则 (Scene Criteria) 中时提醒设计师。点击“Count Entities”按钮，并且勾选分类，便可以填充计算表了。“DONT USE”选项代表了场景中绝对不能包含的过期的实体。表格的最后一栏体现了多少行为者 (agent) 会在当前出生点生成。\n在每一行的结尾，有一个按钮可以展开所有的游戏预制件，每一个都带着点击过按钮 (clicked button) 的标签 (tag)。点击这个按钮将会打开一个新的窗口，其中展示了所有预制件以及其特有的标签。\n3. 导航网格检查选项卡 (Navigation Mesh Check Tab) 这个工具标记了没在导航网络或者被“Navigation Mesh Deactivator”停用的导航网络中的出生点。如果一个场景没有“Navigation Mesh Deactivator”那么停用的面部 ID 将会为 0，同时场景实体检查选项卡中会提醒设计师要放一个上去。点击“CHECK”按钮，同时勾选分类，将给不合法的出生点生成对应分类颜色 Debug 线。\n导航网格检查工具展示了场景级别 (Scene Level) 的出生点。每一个勾选框将会激活两个按钮，分别叫做“Previous”和“Next”。点击这两个按钮可以分别使编辑器镜头 (Camera) 一个一个聚焦于放错的出生点。\n这个选项卡同时可以检查在任务 (mission) 边界外的出生点，不过这个功能只在任务中有用。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_mesh_blend/",
	"title": "地形网格混合系统",
	"tags": [],
	"description": "",
	"content": "在此介绍一个新的地形网格的混合 (blending) 系统。特定的地形 (terrain) 层可以和选中的网格 (mesh) 混合起来。可以修改混合的高度，平滑度以及随机高度偏移量。\n这些值可以存在预制件 (prefabs) 中或者是在场景中根据网格而改变。高度图 (Heightmap) 混合还可以根据网格的高度图来改变不同的混合行为。\n   有混合 没有混合          地形层限制 地形层需要在变成网格混合层 (mesh blend layer) 之前满足一部分限制。\n 漫反射贴图 (Diffuse Texture) 应该有 (2048, 2048) 尺寸并且是 DXT1 格式 （没有 alpha）。 普通贴图 (Normal Texture) 应该有 (2048, 2048) 尺寸并且是 BC5 格式。 高光贴图 (Specular Texture) 应该有 (2048, 2048) 尺寸并且是 DXT1 格式。 每一层级不应该应用 “diffuse alpha” 和 “ground slope” 标记 (flag)。  材料属性 网格应该有一个带着 “terrain_mesh_blend_shader” 着色器 (shader) 的材料。为了应用高度图混合，需要指定一个高度图纹理并应用着色器的标记。\n网格属性 可以从实体查看器 (Entity Inspector) 的 Components/Mesh/Vector 参数窗口中改变网格属性。\n 混合高度阈值：地形混合的最大距离。 混合平滑度：更高的值意味着更平滑的转移。 随机量：混合高度阈值可以根据这个值在像素点的位置增加或者减少。 随机瓦片 (Tile)：调整随机高度图修改的瓦片。 高度图因子 (Factor)：控制网格的高度图因子。更大意味着在高度图更高的位置，混合的更少。  "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/resource-editors/mipmap_editor/",
	"title": "纹理编辑器",
	"tags": [],
	"description": "",
	"content": " 纹理编辑器 (Texture Editor) 可以通过 编辑器 (Editor) \u0026gt;窗口 (Windows) \u0026gt;资源展示浏览器 (Show Resource Browser) \u0026gt;寻找目标纹理 (..Search for Texture..) \u0026gt;双击找到的纹理 (..Double Click on Texture..)\n从右侧面板中的 纹理查看器 (Texture Inspector) 中，你可以通过选中 使用纹理细节混合 (Use Mipmap Blending) 启用/禁用 纹理细节混合 (MipMap Blending) 功能。当时启用该功能的时候，你会在预览框 (Preview Windows) 中看到所有的被选中贴图的所有纹理细节层级。\n点击 纹理细节量 (MipMap Blend Amounts) 将会打开一个新的窗口，在这个窗口中你可以修改每一层级混合的数量。\n你可以选中 细节纹理混合颜色 (MipMap Blend Color) (1)并点击 重新编译 (Recompile) (2)来应用混合。结果会立即显示在预览框和游戏中。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/mass_selection/",
	"title": "群体选择",
	"tags": [],
	"description": "",
	"content": "群体选择 (Mass Selection) 允许你选中多个游戏中的物品 (Objects)，并且进行旋转等操作。你可以重新放置，或者是平移、旋转和缩放有 mass_selection 属性的实体。\n包围盒限制 (Bounding Box Constraint) 属性允许你选中有比这个属性更小值的物品。\n   定位选中框 选中之后 随机旋转之后           "
},
{
	"uri": "http://localhost:4444/zh_cn/authoring-mission-scenes/script-components/callbacks/",
	"title": "脚本组件回调函数",
	"tags": [],
	"description": "",
	"content": "以下为脚本组件 (Script Components) 的回调函数 (Callbacks)。\n构造函数 (Constructor) 在构造函数中，需要指定一些公共变量 (Public Variables) 的默认值（变量可能会被场景设计师修改）。在构造函数中，脚本组件是不会指定到一个特定的实体或者场景的。同时，你不应该在构造函数中写任何有副作用 (Side Effect) 的逻辑代码，因为即使创建了，脚本组件也可能会在场景打开时，因为关卡系统 (Level System) 的升级而被删除。\nOn Pre Init 当一个脚本组件被指定一个场景中的实体时，调用本函数。当你回调该函数时，你要确定用户在脚本中定义的变量都是设定好的。但是，其他实体的脚本组件可能还没有指定。所以，在 pre init 函数中，不应该有任何需要调用其他脚本组件的逻辑代码。例如，ManagedObject 在 pre-init 函数中指定它自己到当前任务实例中的对象数列 (managed object array) 中。\nOn Init 这个函数在任务载入的时候被调用，函数会初始化脚本组件中的所有实体。你可以在此回调函数中添加任何类型的逻辑代码。运行实例化脚本 (Run Time Instantiated Scripts) 也会调用该函数。\nOn Editor Init 编辑器版本的 On Init 函数。这个函数是在场景在编辑器中加载时候调用的。值得注意的是，在编辑器中没有任务或者游戏状态 (game state)。\nOn Tick 在同一个线程下，每一个脚本组件的任务的每一帧都会调用这个函数。\nOn Editor Tick 编辑器版本的 On Tick 函数。\nIs Only Visual 如果你的脚本组件是仅供查看，即不会在专用服务器 (dedicated server) 上运行任何逻辑代码，那么你想要在函数中设置返回值为 真 (True)。这个可以确保这个类型的脚本不会在服务器上运行。\nOn Editor Variable Changed 在编辑器中，当一个脚本组件中的公共变量被用户修改的时候，调用该函数。当设计者需要在编辑场景中得到即时反馈的时候，该函数可以被用于任何视觉和逻辑上的状态改变。\nOnRemoved 当实体或者是脚本组件被移除的时候，调用该函数。当你有一些分配好的对象存在其他地方的时候（例如存在静态容器中），你可以用这个回调函数来确保他们不会出现内存泄漏的问题。\n"
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/terrain_resize/",
	"title": "调整地形大小",
	"tags": [],
	"description": "",
	"content": "调整地形大小 如果需要，地形节点数量可以在 Terrain Inspector的 Resize Terrain面板调整。\n 你可以从 4 个方向添加新的节点或移除已有的节点。+X, +Y, -X, -Y（分别是南，东，北，西）（上色和 Gizmo 一致） 添加和移除节点会自动重新在新的位置分配现存的实体 (entities) 和植物 (floras)。新的节点由于他们的高度信息还未定义，可能会显得无法和其他地形连接。设计者应该可以用编辑器内置的高度笔刷 (Height Brushes) 来修改，或者导出高度图在其他高度图生成软件中修改，之后在导入回编辑器中。 如果在地形的一边输入正数，那么地形像那一边扩展那么多的节点。如果你往每一边写了 +2，那么地形就会像每一边扩展 2 格。如果你写了 +3 在 +X 方向，其他方向为 0 那么地形只会往 +X 方向扩展 3 格。 如果你输入一个负数，那么将会减少相应的节点数。 如果你输入 0（默认值），那么将不会有改变。     添加 删除          "
},
{
	"uri": "http://localhost:4444/zh_cn/editor/scene-editor/distance_tool/",
	"title": "距离工具",
	"tags": [],
	"description": "",
	"content": "测距工具 Distance Tool 可以测量场景内两个点之间的距离。 可以通过按 Alt + D 快捷键 或者点击编辑器工具栏上的对应按钮来激活距离测量模式 (Distance Measure Mode)。\n使用时，按住 鼠标左键 ，在场景内从一个点拖动鼠标到另一个点来测量距离。如果靠近一个点过近，工具会默认吸附在顶点上，按住 左 Shift来取消吸附。\n该模式可以通过按 Alt + D 或者点击编辑器工具栏上对应按钮来取消（操作）。为了以后方便，测量的图标 (Gizmo) 在取消模式后也会一直可见。按住 Alt + Shift + D 来清除屏幕中的测量图标。\n 绿线 展示了点之间的实际距离。 蓝线 展示了经纬度坐标距离。 黄色圆圈 描述了范围。  "
},
{
	"uri": "http://localhost:4444/zh_cn/asset-management/asset-browser/filterqueries/",
	"title": "过滤器查询",
	"tags": [],
	"description": "",
	"content": " 你可以使用 SQL 语法 查询资产 (assets) 中特定的属性 (properties)，比如查找分辨率大于 1024 的纹理 (Textures)。你可以在额外菜单 (extras menu) 中使用查询模式：\n从右边栏的纹理检查器 (Texture Inspector)中，你可以通过勾选 Use Mipmap Blending来启用/禁用 混合纹理映射。 当你启用 混合纹理映射 (MipMap Blending) 的时候，你可以在预览界面 (Preview Window) 看到所有的选中纹理的映射层级。\n点击 MipMap Blend Amounts将会打开一个新的窗口，在这个窗口中你可以调整每一层映射的混合量 (amounts)。\n之后你可以选中 MipMap Blend Color (1)然后点击 Recompile (2)来应用混合。结果会立即在预览界面和游戏中显示。\n"
}]