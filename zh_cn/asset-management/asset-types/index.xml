<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>资产类型 on Taleworlds Documentation</title>
    <link>http://localhost:4444/zh_cn/asset-management/asset-types/</link>
    <description>Recent content in 资产类型 on Taleworlds Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://localhost:4444/zh_cn/asset-management/asset-types/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Animations</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/animations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/animations/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Naming Conventions</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/asset_naming_conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/asset_naming_conventions/</guid>
      <description>To distinguish and organize assets and simplfy asset authoring process there are some predefined rules to consider.
Meshes All meshes imported from a single geometry file(e.g. fbx) are grouped by their names. To add a LOD mesh simply append &amp;quot;.lod&amp;lt;n&amp;gt;&amp;quot; to the name of your mesh. Here n is the number of lod.
Consider an fbx file as below :
asset.fbx :
 wall_damaged wall_damaged_v2 wall_damaged_v2.lod1 wall_damaged.lod1 wall_damaged.lod2  Two meshes will be imported from asset.</description>
    </item>
    
    <item>
      <title>Paths</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/path/</guid>
      <description>在 RGL 中，“路径”是由场景中连续的点 (Point) 组成的。他们一般都有独特的命名并且被游戏逻辑 (Gameplay Logic) 调用。路径在任务中定义了攻城器械的移动路线。同时。在遭遇战中，起始的出生点也是通过路径定义的。出生点逻辑可以根据双方军队的人数编制设定两个初始位置。关于路径修改的细节信息可以在 路径编辑 (Path Editing)中查看。</description>
    </item>
    
    <item>
      <title>Skeletons</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/skeletons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/skeletons/</guid>
      <description></description>
    </item>
    
    <item>
      <title>实体及预制件</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/prefabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/prefabs/</guid>
      <description>在RGL中，实体是包含所有网格，粒子，脚本组件，遮挡物和物理对象的容器。它们可以容纳其他实体来作为其子实体。这些子实体有自己的变体存在，决定了它们在整个世界中的位置，比例和旋转角度。
预制件(Prefabs) 预制件(Prefabs)属于模板实体，即便是复杂的实体可以直接一次构造，并在之后保存为预制物件，以便在任何场景中随时使用。后期对预制件的更新也会对已经完成的场景造成影响。在《霸主》中，几乎所有的任务对象和场景道具都是预制件。
连接规则(Connection Rules) 一旦一个预制件被放置到场景中，预制件下的所有值（网格颜色、子实体变换、脚本数值）都与原预制件相连，并且在每次改变原预制件后都会更新。在场景中，任何对这些值的改变都会切断连接。需要注意的是，在场景中对预制件进行的任何 &amp;ldquo;增加 &amp;ldquo;操作，都会将预制件的连接全部断开。例如：添加一个新的网格、粒子系统、光线、子实体或脚本组件</description>
    </item>
    
    <item>
      <title>材质</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/materials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/materials/</guid>
      <description>材质（Materials）定义了网格模型的渲染特性。它们包含着色器和纹理信息，也包含渲染标志（由着色器和全局标志定义）。一个网格模型可以拥有一个材质。在第三方网格编辑程序中，网格材质的初始值将通过它的材质名称来分配。材质可以通过材质浏览器来创建和编辑，而材质浏览器则可以通过资源浏览器来访问。材质也可以在运行时通过脚本和行为进行编辑。更多关于材质编辑和引擎默认材质的信息可以可以参阅 材质编辑器 (Material Editor) 章节。</description>
    </item>
    
    <item>
      <title>添加与覆盖资产</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/overriding_assets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/overriding_assets/</guid>
      <description>在 RGL 中，您可以轻松地覆盖现有资产或在编辑器中为自定义模组创建新资产。覆盖机制的生效方式是将现有资产替换为你的模组资产目录中提供的对应资产。 它会尝试匹配您的自定义资产与其他模块先前通过其名称注册的资产。模块的加载顺序会影响这一过程。
如果除了 Native 模块之外还分别加载了 模组 A 和 模组 B ，则最终资产及其来源列表如下：
当前可在自定义模组中替换的资产类型为：
 材质 (Material) 网格模型 (Mesh) 纹理 (Texture) 物理形状 (Physics Shape)  文件夹结构 资产系统会根据模块目录中的某些文件夹名称进行处理。这是这些文件夹及其用法的列表：
 Assets : 包括可编辑的 *.tpac 文件，该文件存储每个资产的元数据。 AssetSources : 包括导入资产（.psd，.fbx）的源文件。 AssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于客户端构建时，将生成该文件。 EmAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于编辑器构建时，将生成该文件。 DsAssetPackages : 包括只读 *.tpac 文件。当一个模组被打包用于服务器构建时，将生成该文件。 RuntimeDataCache : 包括引擎所需的对每个资产自动生成的数据。可以删除，但在启动过程中从头开始生成可能会花费时间。  Modding Permissions 资产系统会根据游戏运行的可执行文件的版本寻找不同的文件夹。根据这些文件夹的存在与否，它判定一个模块是否可以被修改，或只能在只读模式下使用。如果您想发布您的模块，您可以打包您的资产并共享打包后的文件夹，而不需要发布成千上万的文件及其源文件。您有三个选项来打包您的资产。
 Client : 其他人可以激活您的模组并运行。您必须分发 AssetPackages 文件夹。 Editor : 其他人可以在编辑器中使用您的模组，但不能修改它。如果您希望其他人从您的模组派生模组，则使用它。您必须分发 EmAssetPackages 文件夹。 Server : 用于服务器构建。需要剥离与服务器无关的所有数据。您必须分发 DsAssetPackages 文件夹。  您也可以像使用您的模组一样共享您的模组，以允许其他人修改它。在这种情况下，你必须分发 Assets、AssetSources 和可选的 RuntimeDataCache 文件夹。</description>
    </item>
    
    <item>
      <title>物体</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/bodies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/bodies/</guid>
      <description>物体定义了物体的物理边界，它们可以被分配给场景或者预制物件的实体。用户可以编辑“物体标识”（Body Flag) 来改变其行为。
物体标识(Body Flags)  双面（Two Sided）：让物理引擎可以使用多边形的两面。 Ai限制器（AI Limiter）：用来标记只针对AI使用的物体，不包括玩家。 可破坏的门（Destructible Door）: 通过自动导航网格生成器来使用，而非将导航网格直接置于可破坏的门之下。 禁用（Disabled）:禁用预制物体，或者实体实例的物理特性。 边界（Barrier）：使对象可以顺利移出物体内部 排除路径对齐（Exclude Path Snap）：适用于路径点无法对齐物体的情况 避免镜头碰撞（Don’t Collide With Camera）：玩家的镜头不会和对应物品产生碰撞。 动态化（Dynamic）：可以让物理引擎会模拟实体的运动 可移动化（Moveable）：该标识标志该物品及其所有的实体可以移动 梯形化（Ladder）：赋予梯形网格，从而使其正常运行。 台阶化（Has Steps）：决定是否将实体物品楼梯化，使得对象能够正确地攀爬楼梯。(楼梯的物体应与实体的其他部分分开)。  自主体的物理引擎要求平滑和低多边形的物理对象来保证性能。投射物则要求更高的精度，以达到能更好的模拟投射物卡顿效果。以下的标识可以用于让每个物体拥有两个不同的机体，以适应两种不同的情况。若两者均未被标记，投射物和自主体都会对该物体做出反应。
 仅限自主体（Agent Only）: 只有自主体会对该物体做出反应。 仅限投射物（Missile Only）: 只有投射物会对该物体做出反应。  遮蔽器（Occluders） 遮蔽器被用于网格模型表面，从而让渲染系统不会去渲染物体的另一面。通常来说，它们对物理模拟过程通常作用不大。但对于大城镇和村庄来说，精心布置的遮蔽器将会非常有用。用户可以直接在场景中放置遮蔽器，也可以将其附加到到实体物品和预制件上。</description>
    </item>
    
    <item>
      <title>纹理</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/textures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/textures/</guid>
      <description>纹理 (Textures) 可以通过资产浏览器 (Asset Browser) 导入。可以通过材质编辑器 (Material Editor) 给纹理指定一些材质。PBR ( 基于物理的渲染 Physically Based Rendering) 材质的纹理槽 (Texture Slot) 可以在 材质编辑器 (Material Editor)中找到。</description>
    </item>
    
    <item>
      <title>网格</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/meshes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/meshes/</guid>
      <description>网格(Meshes)包含了多边形的位置和渲染时使用的属性。每个网格都会有一个材质以定义其的渲染行为。它们在网格内将按照其LOD级别进行分组。同时，在同一个LOD级别中可以同时有多个不同材质的网格。若想了解更多关于将网格导入引擎的信息,请参阅 Material Editor.
细节级别 (LOD) 现代引擎通常使用LOD(Level of detail)系统，以确保相机近处位置使用的GPU资源量多于远处位置。这将通过增加摄像头的距离时减少网格质量来实现。这一系统将确保每个像素的多边形比例在整个屏幕上都尽可能的相似。默认的LOD距离将包含：15, 22.5, 30, 50, 70, 130, 210米。这些距离设置将保证最佳的图形质量，通过在游戏中设置环境和人物质量可以对其进行调节。</description>
    </item>
    
    <item>
      <title>脚本</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/scripts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/scripts/</guid>
      <description>脚本组件是附加在实体上的可执行脚本，可以用来实现各种游戏功能。在《霸主》中，很多游戏逻辑都是通过脚本组件来编写的。例如椅子、掉落的武器、攻城器械。有很多不同的回调函数，可以被继承并填充在这些脚本组件中。
回调函数  Constructor: 在构造函数中，我们需要给它的公有变量分配默认值（可以被场景制作者改变的变量）。在构造函数中，脚本组件不会被分配给实体或场景。另外，不要在这里写任何有副作用的逻辑，因为即使创建了脚本组件，由于升级等级系统的原因，一旦打开场景，脚本组件就可能会被删除。 OnPreInit: 当脚本组件被分配给场景中的所有者实体后，这个回调被调用。一旦你进入了这个回调，那么该脚本实例中的用户定义变量就被设置了。然而，其他实体的脚本组件可能还没有被分配。因此，在预初始化中，不应该有任何依赖于其他脚本组件的逻辑代码。例如，在预初始化中， ManagedObject 将自己注册到当前任务实例中的托管对象数组。 OnInit: 当任务被加载且所有实体的脚本组件被初始化，这个回调就会被立刻调用。你可以在这个回调里面使用任何类型的逻辑代码。运行时实例化的脚本也会得到这个回调的调用。 OnEditorInit: OnInit 的编辑器版本，在从编辑器加载场景时被调用。当场景从编辑器中加载时，它会被调用。确保编辑器中没有任务或游戏状态。 OnTick: 对于每个脚本组件，该任务在同一线程的任务的每个帧中都被调用。 OnEditorTick: OnTick 的编辑器版本。 IsOnlyVisual: 如果你有一个脚本组件，只是可视化的，没有任何应该在服务器版本上运行的逻辑代码，你应该在这个函数中返回 true 。这确保了这种类型的脚本不会在服务器版本上运行。 OnEditorVariableChanged: 在编辑器中，每当用户改变该脚本组件中的公有变量时，就会调用这个回调。如果艺术家需要在编辑器场景中得到即时反馈，这个回调可以用于任何视觉-逻辑状态的改变。 OnRemoved: 当实体或脚本组件被移除时调用。如果你有任何已分配内存的对象被存储在其他地方（例如静态容器），你可以使用这个回调来确保它们被回收，避免泄露内存。  </description>
    </item>
    
    <item>
      <title>覆盖场景和预制件</title>
      <link>http://localhost:4444/zh_cn/asset-management/asset-types/overriding_scenes_prefabs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:4444/zh_cn/asset-management/asset-types/overriding_scenes_prefabs/</guid>
      <description>你可以通过在同一个游戏中创建新的方式来覆盖现有的场景 (scenes) 以及预制件 (prefabs)。
预制件 (Prefabs) 预制件在 xml 文件中的定义在 Prefabs 以及其子目录下可以找到。
场景 (Scenes) 场景储存在 Mod 目录下的 SceneObj 和 SceneEditData 文件夹中。SceneObj 目录保存了在客户端模式 (Client Mode) 中打开场景所需要的文件，而 SceneEditData 目录保存了编辑场景所需要的文件。</description>
    </item>
    
  </channel>
</rss>
